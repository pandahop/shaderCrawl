<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (19) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XtX3Rr","date":"1417633586","viewed":26253,"name":"Neptune Racing","username":"Dave_Hoskins","description":"Another landscape. This time using a stack of 8 distance field sphere scoops, enabling anti-aliasing and DOF.\n\nThanks to vgs ([url]https:\/\/www.shadertoy.com\/view\/MdBSDt[\/url]) for the stack idea.","likes":220,"published":3,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Neptune Racing. December 2014\n\/\/ https:\/\/www.shadertoy.com\/view\/XtX3Rr\n\n\n\/\/ Uses sphere tracing to accumulate direction normals across the landscape.\n\/\/ Materials are calculated after the tracing loop from alphas and distances\n\/\/ stored in a stack.\n\/\/ Change ScoopRadius for depth of field.\n\n#define PI 3.141596\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 moon  = vec3(  45000., 30000.0,  -30000. );\nconst vec3 sunColour = vec3(.4, .6, 1.);\n#define FOG_COLOUR vec3(0.07, 0.05, 0.05)\nvec4 aStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\n\n\/\/--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/-----------------------------------------------------------------------------------\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.46, -0.48,\n                    -0.60, -0.38,  0.64 ) * 2.43;\nfloat Turbulence( vec3 p )\n{\n    float f;\n    f  = 0.5000*Noise( p ); p = m*p;\n    f += 0.2500*Noise( p ); p = m*p;\n    f += 0.1250*Noise( p ); p = m*p;\n    f += 0.0625*Noise( p ); p = m*p;\n    f += 0.0312*Noise( p ); \n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\/\/-----------------------------------------------------------------------------------\nfloat Terrain( in vec2 q, float bias )\n{\n\tfloat tx1 = smoothstep( 0.,.4, textureLod( iChannel0, 0.000015*q, bias ).y);\n    tx1   = mix(tx1, textureLod( iChannel1, 0.00003*q, bias ).x, tx1);\n\treturn tx1*355.0;\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat Map( in vec3 p )\n{\n\tfloat h = Terrain( p.xz, -100.0 );\n\tfloat  turb =Turbulence( p * vec3(1.0, 1., 1.0)*.05 ) * 25.3;\n\treturn p.y-h+turb;\n}\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),4.);\n\tvec3  sky = mix(vec3(.0,0.01,.04), vec3(.1, .04, .07), v);\n\t\/\/sky *= smoothstep(-0.3, .0, rd.y);\n\tsky = sky + sunColour * sunAmount * sunAmount * .15;\n\tsky = sky + sunColour * min(pow(sunAmount, 1800.0), .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\/\/--------------------------------------------------------------------------\n vec3 GetClouds(vec3 p,vec3 dir)\n {\n    float n = (1900.0-p.y)\/dir.y;\n    vec2 p2 = p.xz + dir.xz * n;\n    vec3 clo = textureLod(iChannel3, p2*.00001+.2,0.).zyz * .04;\n\tn = (1000.0-p.y)\/dir.y;\n\tp2 = p.xz + dir.xz * n;\n    clo += textureLod(iChannel0, p2*.00001-.4, 0.0).zyz * .04;\n    clo = clo * pow(max(dir.y, 0.0), .8)*3.0;\n     return clo;\n\n }\n\n\/\/--------------------------------------------------------------------------\nfloat ScoopRadius(float t)\n{\n\tt = abs(t-150.) * 1.;\n\tt = t*0.006;\n\treturn clamp(t*t, 256.0\/iResolution.y, 20000.0\/iResolution.y);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir, in float d,in vec3 sky)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0));\n\tmat += vec3(0.01, .01,.02) * max(normal.y, 0.0);\n    normal = reflect(eyeDir, normal);\n    mat += pow(max(dot(sunLight, normal), 0.0), 50.0)  * sunColour * .5;\n    mat = mix(sky,mat, min(exp(-d*d*.000002), 1.0));\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n    \/\/float t = 0.0;\n\tfloat t = 8.0 * Hash(fcoord);\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 95; j++ )\n\t{\n\t\tif (hits == 8  || t > 1250.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = ScoopRadius(t);\n\t\tfloat h =Map(p);\n\t\tif(h < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the alphas...\n\t\t\tfloat alpha = (1.0 - alphaAcc) * min(((sphereR-h) \/ sphereR), 1.0);\n            \/\/ If high enough to contribute nicely...\n            if (alpha > (1.\/8.0))\n            {\n\t\t\t\t\/\/ If a peice of the lanscape is scooped as a suitable alpha,\n                \/\/ then it's put on the stacks...\n\t\t\t\/\/ put it on the 2 stacks, alpha and distance...\n                aStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;\n                aStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n                dStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n                dStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n                alphaAcc += alpha;\t\n                hits++;\n            }\n            \n\t\t}\n\t\tt +=  h * .5 + t * 0.004;\n       \n\t}\n    \n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n\n\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\trgb *= .5+0.5*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xyz;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\/\/--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel1, pos*.01, nor).xzy + TexCube(iChannel3, pos*.02, nor);\n    return col * .5;\n}\n\n\/\/--------------------------------------------------------------------------\n float cross2(vec2 A, vec2 B)\n {\n\treturn A.x*B.y-A.y*B.x;\n }\n\n\/\/--------------------------------------------------------------------------\n\/\/ Angle between 2 vectors...\n float GetAngle(vec2 A, vec2 B)\n {\n\treturn atan(cross2(A,B), dot(A,B));\n    \/\/return  atan(B.y, B.x) - atan(A.y, A.x);\n    \/\/return (acos((A.x * B.x + A.y * B.y)\/((sqrt(A.x*A.x + A.y*A.y) * sqrt(B.x*B.x + B.y*B.y))))\/3.141);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    float s = smoothstep(.0, 3.0, t);\n\tvec3 pos = vec3( t*30.0*s +120.0, 1.0, t* 220.* s -80.0);\n\t\n\tfloat a = t\/4.0;\n\tpos.xz += vec2(1350.0 * cos(a), 350.0*sin(a));\n    pos.xz += vec2(1400.0 * sin(-a*1.8), 400.0*cos(-a*4.43));\n\n\treturn pos;\n} \n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = 0.0;\/\/(iMouse.x\/iResolution.x)*10.0;\n\tfloat gTime = ((iTime+135.0)*.25+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\t\n\tfloat hTime = mod(gTime+1.95, 2.0);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime + 0.0);\n\tvec3 camTarget \t= CameraPath(gTime + .25);\n    vec3 far\t \t= CameraPath(gTime + .5);\n    \n\n    vec2 v1 = (far.xz-cameraPos.xz);\n    vec2 v2 = (camTarget.xz-cameraPos.xz);\n    float roll = clamp(GetAngle(v1 , v2)*2., -.9, .9  );\n    \n    \n\tfloat t = Terrain(cameraPos.xz, .0)+13.0;\n    float t2 = Terrain(camTarget.xz, .0)+13.0;\n    cameraPos.y = camTarget.y= t;\n\t\n\t\/\/roll = roll;\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\n\tvec3 col = vec3(0.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n        aStack[i] = vec4(0.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir);\n\t\n     vec3 sky = GetSky(dir);\n    \/\/ Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n\t\t{\n            float d = dStack[s][i];\n            if (d < .0) continue;\n            float sphereR = ScoopRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            float occ = max(1.2-Turbulence(pos * vec3(1.0, 1., 1.0)*.05 )*1.2, 0.0);\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 c = Albedo(pos, normal);\n\t\t\tcol += DoLighting(c, normal, dir, d, sky)* aStack[s][i]*occ;\n        }\n    }\n    \n   col += sky *  (1.0-alpha);\n    \n    if (alpha < .8)\n    {\n        \/\/ Do a quick moon...\n        float t = SphereIntersect(cameraPos, dir, vec4(moon, 14000.0));\n        if (t> 0.0)\n        {\n            vec3 moo = cameraPos + t * dir;\n            vec3 nor = normalize(moo-moon);\n            moo = TexCube(iChannel3, moo*.00001, nor)* max(dot(sunLight, nor), 0.0);\n            \n            sky = mix(sky, moo, .2);\n        }\n        else\n        {\n            float stars = pow(texture(iChannel2, vec2(atan(dir.x, dir.z), dir.y*2.0), -100.0).x, 48.0)*.35;\n            stars *= pow(max(dir.y, 0.0), .8)*2.0;\n            sky += stars;\n        }\n        sky += GetClouds(cameraPos, dir);\n\t\tcol = mix(sky ,col, alpha);\n    }\n\n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    float s = smoothstep(.0, 3.0, t);\n\tvec3 pos = vec3( t*30.0*s +120.0, 1.0, t* 220.* s -80.0);\n\t\n\tfloat a = t\/4.0;\n\tpos.xz += vec2(1350.0 * cos(a), 350.0*sin(a));\n    pos.xz += vec2(1400.0 * sin(-a*1.8), 400.0*cos(-a*4.43));\n\n\treturn pos;\n}\n\nvec2 Hash( vec2 n)\n{\n\tvec4 p = textureLod( iChannel0, n*vec2(.78271, .32837), 0.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\nfloat rockets(float t)\n{\n    t  = texture(iChannel0, vec2(t*.3, t*.1731), -100.0).x-.5;\n    t += texture(iChannel0, vec2(t*.2, t*.01731), -100.0).t-.5;\n    return t;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float gTime = (time+135.0)*.25;\n    vec3 ca = CameraPath(gTime);\n    vec3 ct = CameraPath(gTime+.05);\n    float f = length(ct-ca)*.1;\n    vec2 audio;\n    audio = FBM(vec2(gTime*120.0, gTime*1200.0)) * 5.0 * f;\n    audio += FBM(vec2(gTime*200.0* f, gTime*200.0)) * 4.5;\n    audio *= .1;\n    \n    float g = mod(f*gTime, 8.0);\n    \/\/audio *= g < 4.0 ? 1.0:0.0;\n    return audio * smoothstep(.0, 2.0, time) * smoothstep(180.0, 170.0, time);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"Ms2SWW","date":"1357121825","viewed":26230,"name":"Deform - square tunnel","username":"iq","description":"A 2D square tunnel. If done naively, the tunnel will have a discontinuity in the left side of the screen where the atan() function branches. Taking derivatives on the right where there's no branch and applying them on the left side fixes the problem.","likes":97,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\n\/\/ This shader shows one way to fix the texturing discontinuities created by \n\/\/ fetching textures with atan(), which you can see if you set IMPLEMENTATION \n\/\/ to 0, depending on your screen resolution. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/tunnel\n\n\n\/\/ 0 naive\n\/\/ 1 explicit derivatives\n#define IMPLEMENTATION 1\n\n\/\/ 0 : circular\n\/\/ 1 : squareish\n#define SHAPE 0\n\nconst float kPi = 3.1415927;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;  \/\/ normalized coordinates - \u5f52\u4e00\u5316\u5750\u6807\n\n    float a = atan(p.y,p.x);                                \/\/ angle of each pixel to the center of the screen - \u6bcf\u4e2a\u50cf\u7d20\u5230\u5c4f\u5e55\u4e2d\u5fc3\u7684\u89d2\u5ea6 \u8fd4\u56de\u503c\u4e3a\u5f27\u5ea6\uff0c\u591a\u5c11\u591a\u5c11pi\n\n    #if SHAPE==0\n    float r = length(p);                                    \/\/ cylindrical tunnel - \u5706\u67f1\u96a7\u9053\n    #else\n    vec2 p2 = p*p, p4 = p2*p2, p8 = p4*p4;                  \/\/ square tunnel - \u6b63\u65b9\u5f62\u96a7\u9053\n    float r = pow(p8.x+p8.y, 1.0\/8.0);   \n    #endif\n    \n    vec2 uv = vec2( 0.3\/r + 0.2*iTime, a\/kPi );             \/\/ index texture by radious and angle - \u7d22\u5f15\u7eb9\u7406\u7684 \u534a\u5f84\u548c\u89d2\u5ea6\n\n    #if IMPLEMENTATION==0\n    vec3 col = texture(iChannel0, uv).xyz;                  \/\/ naive fetch color - \u4f20\u7edf\u7684\u91c7\u6837\n\t#else\n    vec2 uv2 = vec2(uv.x, atan(p.y,abs(p.x))\/kPi);          \/\/ fetch color with correct texture gradients to prevent discontinutity - \u7528\u6b63\u786e\u7684\u7eb9\u7406\u68af\u5ea6\u53d6\u989c\u8272\uff0c\u4ee5\u9632\u6b62\u4e0d\u8fde\u7eed\u6027\n    vec3 col = textureGrad(iChannel0, uv, dFdx(uv2), \n                                          dFdy(uv2)).xyz;\n\t#endif\n    \n    col = col*r;                                            \/\/ darken at the center - \u4f7f\u4e2d\u95f4\u53d8\u6697\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MltXzN","date":"1478555625","viewed":26170,"name":"BuckleUp","username":"dila","description":"What the hell.","likes":93,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat mat = 0.0;\nfloat ss = 0.5;\n\nfloat map(vec3 p)\n{\n    p.x += sin(p.z * ss);\n    p.y += cos(p.z * ss);\n    \n    float sc = (sin(p.z) * 0.5 + 1.0) * 0.5;\n    \n    vec3 r = p;\n    \n    r.xy = vec2(atan(r.x, r.y) \/ 3.14159265359 * 2.0, length(r.xy));\n    \n    r.x += r.z * 0.125;\n    r.x = (fract(r.x) - 0.5) * 4.0;\n    \n    r.y -= 3.0;\n    \n    r.z = fract(r.z) - 0.5;\n    \n    vec3 q = r;\n    float d = 1000.0;\n    \n    vec3 s = vec3(0.5, 0.125, 0.125);\n    vec3 as = vec3(1.0, 0.0, 0.0);\n    float u = 1.0;\n    \n    const int n = 4;\n    for (int i = 0; i < n; ++i) {\n        float fi = float(i) \/ float(n - 1);\n        \n        q = abs(q) - 0.3;\n\n        q.xy *= rot(3.14159 * 0.125);\n        \n        float k = sdBox(q, s);\n        \n        if (k < d) {\n            d = k;\n            mat = float(i);\n        }\n        \n        s = s.yzx * 0.75;\n        as = as.yzx;\n        u *= 0.5;\n    }\n    \n    float c = 1.0 + r.y;\n    \n    d = max(d, -c);\n    \n\treturn d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t) * 0.6;\n    }\n    return t;\n}\n\nvec3 textex(sampler2D channel, vec3 p)\n{\n    vec3 ta = texture(channel, p.xy).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.yz).xyz;\n    return (ta * ta + tb * tb + tc * tc) \/ 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 4.0);\n    o.x -= sin(o.z * ss);\n    o.y -= cos(o.z * ss);\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.33));\n\n    r.xy *= rot(sin(o.z * ss * 0.5) * 3.14159 * 0.5);\n    r.xz *= rot(sin(o.z * ss) * 3.14159 * 0.25);\n    r.yz *= rot(cos(o.z * ss) * 3.14159 * 0.25);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    float fd = map(w);\n    vec3 sn = normal(w);\n    \n    vec3 tex = textex(iChannel0, w);\n    if (mat < 3.0) {\n        tex *= 0.25;\n    }\n    \n    vec3 sk = vec3(0.0);\n    const int n = 8;\n    for (int i = 0; i < n; ++i) {\n        float fi = float(i + 1) \/ float(n + 1);\n        float fr = o.z + fi * 4.0;\n\t\tvec3 sp = vec3(0.0, 0.0, floor(fr));\n        fr = fract(fr);\n        fr = 4.0 * fr * (1.0 - fr);\n        float st = 0.0;\n        for (int i = 0; i < 4; ++i) {\n            vec3 sq = o + r * st - sp;\n            st += 5.0 - length(sq);\n        }\n        vec3 sw = o + r * st - sp;\n        sw.xz *= rot(3.14159 * 2.0 * fi);\n        vec3 stex = textex(iChannel1, sw * 0.5);\n        sk += stex * fr * 0.25;\n    }\n    \n    vec3 ldir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 ref = reflect(-ldir, sn);\n    float prod = max(dot(r, ref), 0.0);\n    prod = pow(prod, 4.0);\n    vec3 pcol = textex(iChannel2, w * 0.1) * prod;\n    \n    float fog = 1.0 \/ (1.0 + t * t * 0.01);\n    float edge = 1.0 \/ (1.0 + fd * 100.0);\n    vec3 fc = (tex * fog + pcol) * edge;\n    \n    fc = mix(fc, sk, 1.0 - fog);\n    \n    vec3 nfc = vec3(dot(fc, vec3(0.299, 0.587, 0.114)));\n    nfc.y += fc.y * 0.25;\n    nfc.x += fc.z * 0.5;\n    nfc.z += fc.x * 0.75;\n    nfc *= 2.0;\n    \n\tfragColor = vec4(sqrt(nfc), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lssGRM","date":"1366414346","viewed":25765,"name":"Angels","username":"iq","description":"Some flying creatures. I need to find a cheap way to do volumetric rays!","likes":183,"published":3,"flags":1,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\/\/ ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nconst vec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    \/\/ animation\n    float atime = iTime+12.0;\n    vec2 o = floor( 0.5 + p.xz\/50.0 );\n    \n    float o1 = hash1( o );\n    float f = sin( 1.0 + (2.0*atime+31.2*o1)\/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    \n    p = mod( p+25.0, 50.0 )-25.0;\n    \n    if( abs(o.x)>0.5 ) p += (-1.0+2.0*o1)*10.0;\n    \n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    \/\/ modeling\n\tfor( int i=0; i<16; i++ )\n\t{\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n\tfloat d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    return vec2( d, 0.5+p.z );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    const float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) t=-1.0;\n    return vec2( t, d );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao \/= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nconst vec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    \/\/ render\n    vec3 bgc = 0.6*vec3(0.8,0.9,1.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    \/\/ raymarch\n    vec2 tmat = raycast(ro,rd);\n    float dis = tmat.x;\n    if( tmat.x>0.0 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        \/\/ material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,1.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        \/\/ lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        \/\/ lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        \/\/ surface-light interacion\n        col = mate * brdf;\n        \/\/ fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        \/\/ sun\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        col += sun;\n        dis = 140.0;\n    }\n    \n    \/\/ god rays\n    #if 0\n    float gr = 0.0;\n    float t = 10.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    \/\/ sun scatter\n    col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    \/\/ postprocessing\n    \/\/ gamma\n    col = pow( col, vec3(0.45) );\n    \/\/ contrast\/brightness\n    col = 1.3*col-0.1;\n    \/\/ tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec2 m = (iMouse.z>0.0) ? iMouse.xy\/iResolution.xy : vec2(0.5);\n    \n    \/\/ camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    \/\/ render\n    vec3 col = render( ro, rd, fragCoord );\n    \n    \/\/ vigneting\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 3.0, 0.0, 14.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4lSXzh","date":"1441330609","viewed":25731,"name":"Traced Minkowski Tube","username":"Shane","description":"A point lit, rounded square tunnel, produced without the use of ray marching.","likes":132,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n    Simplified, Traced Minkowski Tube.\n    ----------------------------------\n    \n    This was inspired by Shadertoy user Akaitora's \"Worley Tunnel\" which you can find here:\n    https:\/\/www.shadertoy.com\/view\/XtjSzR\n    \n    Akaitora had a question, but I didn't have room to answer, so this is for anyone who's interested\n    in understanding the reasoning behind the oldschool tunnel effect. I see a \"lot\" of them around.\n    \n    I'll assume most know that the endless tunnel effect is a simplification of a raytraced, \n    cylindrically-mapped inner cylinder. Without going into detail, by restricting the \"XY\" coordinates \n\tof the ray origin (camera position) \"ro\" to zero, the ray intersection equation becomes almost \n\ttrivial. For a 3D unit ray-direction vector, \"rd,\" the solution is something along the lines of:\n    \n    float distance = 1.\/length(rd.xy);\n    \n    Applying the intesection point formula (sp = ro + rd*dist), the 3D surface point is simply: \n\tvec3 sp = vec3(0, 0, time) + rd\/length(rd.xy); \/\/ ro.xy is fixed to the origin moving along Z.\n    \n    The surface point coordinates enable you to color the surface using a 3D method, or in the case of \n\tthe endless tunnel effect, cylindrically map a texture, or texture-function, (preferably seamless) \n\tonto the surface:\n    \n\tvec3 color = TexFunction(vec3 sp) { return texUV(scaleU*atan(sp.y, sp.x)\/6.2832, scaleV*sp.z); }\n    \n    You can see that \"sp.z\" is equal to: ro.z(time)*scaleV + rd.z*scaleV(constant)\/length(rd.xy);\n    \n    The light attenuation is usually a scaled inverse of the distance, or \"k*length(rd.xy)\" and the \n    normal vector is about as straight forward as it gets: normalize(vec3(-sp.xy, 0.));\n    \n    Anyway, to save cycles, 1990s demo coders threw out the 3D surface information, bypassed the \n    normalization of the ray-direction vector, and a bunch of other stuff, until there was virtually \n\tnothing left to calculate other than the texture coordinates and distance attenuation.\n\n\tThe point is, for the price of just a few extra lines and almost no extra effort on the part of the\n\tGPU, you could have a 3D \"lit\" tunnel, which is more visually enticing. Like the oldschool tunnel \n\tdemos, you could also have square, rounded square tunnels, etc.\n    \n    Hence, this simple demonstration. It's a point lit, rounded square tunnel, produced without the use \n\tof raymarching. As a point of interest that's probably not interesting, there's not a single \"for \n\tloop\" or \"if statement\" used in the code. Do I get points for that? :)\n\n\tIf you ignore the 3D Voronesque function (which I'll explain another time), bump mapping, amateur\n\tcamera movement and extra lighting, there's barely any code here. In fact, I believe you could fit \n\ta 3D lit, 3D-function mapped, possibly bumped, tunnel into a tweet or two... but I'll leave that to \n\tFabrice Neyret, Greg Rostami, etc. ;-)\n\n\t\n\tUpdate: Here's a private link to a cylindrically mapped tube I put together. It's for those who'd \n\tlike to see how to apply repeated 2D functions and textures:\n\thttps:\/\/www.shadertoy.com\/view\/ltSSR1\n\n*\/\n\n\n\/\/ 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\/\/ 3D Voronoi-like function. Cheap, low quality, 1st and 2nd order 3D Voronoi imitation.\n\/\/\n\/\/ I wrote this a while back because I wanted a stand-alone algorithm fast enough to produce regular, or \n\/\/ 2nd order, Voronoi-looking patterns in a raymarching setting. Anyway, this is what I came up with. \n\/\/ Obviously, it wouldn't pass as genuine 3D Voronoi, but there's only so much you can do with a few lines. \n\/\/ Even so, it has a Voronoi feel to it. Hence, Voronesque.\n\/\/\n\/\/ Here's a rough explanation of how it works: Instead of partitioning space into cubes, partition it into \n\/\/ its simplex form, namely tetrahedrons. Use the four tetrahedral vertices to create some random falloff \n\/\/ values, then pick off the two highest, or lowest, depending on perspective. That's it. If you'd like to \n\/\/ know more, the function is roughly commented, plus there's a simplex noise related link below that should \n\/\/ make it more clear.\n\/\/\n\/\/ Credits: Ken Perlin, the creator of simplex noise, of course. Stefan Gustavson's paper - \"Simplex Noise \n\/\/ Demystified.\" IQ, other \"ShaderToy.com\" people, Brian Sharpe (does interesting work), etc.\n\/\/\n\/\/ My favorite simplex-related write up: \"Simplex Noise, keeping it simple.\" - Jasper Flick?\n\/\/ http:\/\/catlikecoding.com\/unity\/tutorials\/simplex-noise\/\n\/\/\nfloat Voronesque( in vec3 p ){\n    \n    \/\/ Skewing the cubic grid, then determining the first vertex.\n    vec3 i  = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    \/\/ Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    \/\/ intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    \/\/ Using the above to calculate the other three vertices. Now we have all four tetrahedral vertices.\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n    \n    vec3 rnd = vec3(7, 157, 113); \/\/ I use this combination to pay homage to Shadertoy.com. :)\n    \n    \/\/ Falloff values from the skewed point to each of the tetrahedral points.\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    \/\/ Assigning four random values to each of the points above. \n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    \n    \/\/ Further randomizing \"d,\" then combining it with \"v\" to produce the final random falloff values. \n    \/\/ Range [0, 1]\n    d = fract(sin(d)*262144.)*v*2.; \n \n    \/\/ Reusing \"v\" to determine the largest, and second largest falloff values. Analogous to distance.\n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n   \n    \/\/ Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    return  max(v.x, v.y) - max(v.z, v.w);  \n    \n    \/\/return max(v.x, v.y); \/\/ Maximum, or regular value for the regular Voronoi aesthetic.  Range [0, 1].\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates, plus some movement about the center.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y + vec2(.5*cos(iTime*.5), .25*sin(iTime*.5));\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    rd.xy *= rot(sin(iTime*.25)*.5); \/\/ Very subtle look around, just to show it's a 3D effect.\n    rd.xz *= rot(sin(iTime*.25)*.5);\n \n    \/\/ Screen color. Initialized to black.\n    vec3 col = vec3(0);\n    \n    \/\/ Ray intersection of a cylinder (radius one) - centered at the origin - from a ray-origin that has XY \n    \/\/ coordinates also centered at the origin.\n    \/\/float sDist = max(dot(rd.xy, rd.xy), 1e-16); \/\/ Analogous to the surface function.\n    \/\/sDist = 1.\/sqrt(sDist); \/\/ Ray origin to surface distance.\n    \n    \/\/ Same as above, but using a Minkowski distance and scaling factor. I tried it on a whim, and it seemed \n    \/\/ to work. I know, not scientific at all, but it kind of makes sense. They'll let anyone get behind a \n    \/\/ computer these days. :)\n    vec2 scale = vec2(.75, 1);\n    float power = 6.;\n    \/\/ Analogous to the surface function.\n    float sDist = max(dot( pow(abs(rd.xy)*scale, vec2(power)), vec2(1) ), 1e-16); \n    sDist = 1.\/pow( sDist, 1.\/power ); \/\/ Ray origin to surface distance.\n    \n    \/\/if(sDist>1e-8){\n        \n        \/\/ Using the the distance \"sDist\" above to calculate the surface position. Ie: sp = ro + rd*t;\n        \/\/ I've hardcoded \"ro\" to reduce line count. Note that \"ro.xy\" is centered on zero. The cheap\n        \/\/ ray-intersection formula above relies on that.\n        vec3 sp = vec3(0, 0, iTime*2.) + rd*sDist;\n \n        \/\/ The surface normal. Based on the derivative of the surface description function. See above.\n        \/\/vec3 sn = normalize(vec3(-sp.xy, 0.)); \/\/ Cylinder normal.\n        vec3 sn = normalize(-sign(sp)*vec3(pow(abs(sp.xy)*scale, vec2(power-1.)), 0.)); \/\/ Minkowski normal.\n        \n        \/\/ Bump mapping.\n        \/\/\n        \/\/ I wanted to make this example as simple as possible, but it's only a few extra lines. Note the \n        \/\/ larger \"eps\" number. Increasing the value spreads the samples out, which effectively blurs the \n        \/\/ result, thus reducing the jaggies. The downside is loss of bump precision, which isn't noticeable \n        \/\/ in this particular example. Decrease the value to \"0.001\" to see what I'm talking about.\n        const vec2 eps = vec2(.025, 0.);\n        float c = Voronesque(sp*2.5); \/\/ Base value. Used below to color the surface.\n        \/\/ 3D gradient vector... of sorts. Based on the bump function. In this case, Voronoi.                \n        vec3 gr = (vec3(Voronesque((sp-eps.xyy)*2.5), Voronesque((sp-eps.yxy)*2.5), \n                        Voronesque((sp-eps.yyx)*2.5))-c)\/eps.x;\n        gr -= sn*dot(sn, gr); \/\/ There's a reason for this... but I need more room. :)\n        sn = normalize(sn + gr*.1); \/\/ Combining the bump gradient vector with the object surface normal.\n\n        \/\/ Lighting.\n        \/\/\n        \/\/ The light is hovering just in front of the viewer.\n        vec3 lp = vec3(0, 0, iTime*2. + 3.);\n        vec3 ld = lp - sp; \/\/ Light direction.\n        float dist = max(length(ld), .001); \/\/ Distance from light to the surface.\n        ld \/= dist; \/\/ Use the distance to normalize \"ld.\"\n\n        \/\/ Light attenuation, based on the distance above.\n        float atten = min(1.5\/max(1. + dist*.25 + dist*dist*.5, .001), 1.);\n        \n       \n        float diff = max(dot(sn, ld), 0.); \/\/ Diffuse light value.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 16.); \/\/ Specular highlighting.\n        \/\/ Adding some fake, reflective environment information.\n        float ref = Voronesque((sp + reflect(rd, sn)*.5)*2.5);\n       \n        \/\/ Coloring the surface with the Voronesque function that is used to bump the surface. See \n        \/\/ \"bump mapping\" above.\n        vec3 objCol = pow(min(vec3(1.5, 1, 1)*(c*.97 + .03), 1.), vec3(1, 3, 16)); \/\/ Cheap red palette.\n        \/\/vec3 objCol = vec3(c*c*.9, c, c*c*.4); \/\/ Cheap green palette.\n        \/\/vec3 objCol = vec3(pow(c, 1.6), pow(c, 1.7), c); \/\/ Purpley blue.\n        \/\/vec3 objCol = vec3(c); \/\/ Grey scale.\n\n        \/\/ Using the values above to produce the final color.\n        \/\/col = (objCol*(diff + ref*.25 + .25) + vec3(1., .8, .9)*ref*.25 + spec*vec3(.75, .9, 1.))*atten;\n        col = (objCol*(diff + ref*.35 + .25 + vec3(1, .9, .7)*spec) + (c + .35)*vec3(.25, .5, 1)*ref)*atten;\n        \/\/col = ((vec3(1, .97, .92)*diff + ref*.5 + .25)*c + vec3(1., .8, .9)*ref*.3 + \n        \/\/        vec3(.75, .9, 1.)*spec)*atten;\n        \n        \n         \n        \n    \/\/}\n    \n    \/\/ Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dsXWn","date":"1399216397","viewed":25625,"name":"Weather","username":"Dave_Hoskins","description":"Adjust cloud layer thickness with the upper and lower defines.\nMouse X to move through time.\nIt ray-casts to the bottom layer then steps through to the top layer. The larger steps at the horizon are not really noticeable.","likes":241,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ldlGRr","filepath":"https:\/\/soundcloud.com\/chill\/finding-hope-wonder-premiere","previewfilepath":"https:\/\/soundcloud.com\/chill\/finding-hope-wonder-premiere","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Weather. By David Hoskins, May 2014.\n\/\/ @ https:\/\/www.shadertoy.com\/view\/4dsXWn\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Who needs mathematically correct simulations?! :)\n\/\/ It ray-casts to the bottom layer then steps through to the top layer.\n\/\/ It uses the same number of steps for all positions.\n\/\/ The larger steps at the horizon don't cause problems as they are far away.\n\/\/ So the detail is where it matters.\n\/\/ Unfortunately this can't be used to go through the cloud layer,\n\/\/ but it's fast and has a massive draw distance.\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .7, .55);\nfloat gTime, cloudy;\nvec3 flash;\n\n#define CLOUD_LOWER 2800.0\n#define CLOUD_UPPER 3800.0\n\n#define TEXTURE_NOISE\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n\n\/\/--------------------------------------------------------------------------\n\n\/\/--------------------------------------------------------------------------\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat Hash(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\n\/\/--------------------------------------------------------------------------\n#ifdef TEXTURE_NOISE\n\n\/\/--------------------------------------------------------------------------\nfloat Noise( in vec2 f )\n{\n    vec2 p = floor(f);\n    f = fract(f);\n    f = f*f*(3.0-2.0*f);\n    float res = textureLod(iChannel0, (p+f+.5)\/256.0, 0.0).x;\n    return res;\n}\nfloat Noise( in vec3 x )\n{\n    #if 0\n    return texture(iChannel2, x*0.05).x;\n    #else\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    #endif\n}\n#else\n\n\/\/--------------------------------------------------------------------------\n\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n#endif\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 2.345;\n\/\/--------------------------------------------------------------------------\nfloat FBM( vec3 p )\n{\n\tp*= .0003;\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; \/\/p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; \/\/p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\/\/--------------------------------------------------------------------------\nfloat FBMSH( vec3 p )\n{\n\tp*= .1;\n        \n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; \/\/p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; \/\/p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat MapSH(vec3 p)\n{\n\t\n\tfloat h = -(FBM(p)-cloudy-.6);\n    \/\/h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\n    \/\/h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\n\treturn h;\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat SeaNoise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\nfloat SeaFBM( vec2 p )\n{\n    p*= .001;\n    float f;\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\n    \n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\n    \/\/f += 0.0625 * Noise(p);\n\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Map(vec3 p)\n{\n\tfloat h = -(FBM(p)-cloudy-.6);\n    \n\treturn h;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SeaMap(in vec2 pos)\n{\n\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\n{\n\tfloat p = .005 * d * d \/ iResolution.x;\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\n    height = nor.y;\n\tnor = cross(v2, v3);\n\treturn normalize(nor);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat GetLighting(vec3 p, vec3 s)\n{\n    float l = MapSH(p)-MapSH(p+s*200.);\n    return clamp(-l*2., 0.05, 1.0);\n}\n\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\t\/\/ Do the blue and sun...\t\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\n\t\n\t\/\/ Find the start and end of the cloud layer...\n\tfloat beg = ((CLOUD_LOWER-pos.y) \/ rd.y);\n\tfloat end = ((CLOUD_UPPER-pos.y) \/ rd.y);\n\t\n\t\/\/ Start position...\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\n\toutPos = p.xz;\n    beg +=  Hash(p)*150.0;\n\n\t\/\/ Trace clouds through that layer...\n\tfloat d = 0.0;\n\tvec3 add = rd * ((end-beg) \/ 55.0);\n\tvec2 shade;\n\tvec2 shadeSum = vec2(0.0, .0);\n\tshade.x = 1.0;\n\t\/\/ I think this is as small as the loop can be\n\t\/\/ for a reasonable cloud density illusion.\n\tfor (int i = 0; i < 55; i++)\n\t{\n\t\tif (shadeSum.y >= 1.0) break;\n\t\tfloat h = Map(p);\n\t\tshade.y = max(h, 0.0); \n\n        shade.x = GetLighting(p, sunLight);\n\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\n\n\t\tp += add;\n\t}\n\t\/\/shadeSum.x \/= 10.0;\n\t\/\/shadeSum = min(shadeSum, 1.0);\n\t\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\n    \/\/vec3 clouds = vec3(shadeSum.x);\n\t\n\t\/\/clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\n   \n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\n\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\n\t\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\n{\n\tvec3 sea;\n\tfloat d = -pos.y\/rd.y;\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\n\toutPos = p.xz;\n\t\n\tfloat dis = length(p-pos);\n    float h = 0.0;\n\tvec3 nor = SeaNormal(p, dis, h);\n\n\tvec3 ref = reflect(rd, nor);\n\tref.y = max(ref.y, 0.0015);\n\tsea = GetSky(p, ref, p.xz);\n\th = h*.005 \/ (1.0+max(dis*.02-300.0, 0.0));\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\n    fresnel = pow(fresnel, .3)*1.1;\n    \n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\n\t\n\tfloat glit = max(dot(ref, sunLight), 0.0);\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\n\t\n\treturn sea;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\n} \n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*30.0;\n\tgTime = iTime*.5 + m + 75.5;\n\tcloudy = cos(gTime * .25+.4) * .26;\n    float lightning = 0.0;\n    \n    if (cloudy >= .2)\n    {\n        float f = mod(gTime+1.5, 2.5);\n        if (f < .8)\n        {\n            f = smoothstep(.8, .0, f)* 1.5;\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\n        }\n    }\n    \n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\n       \n\t\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\t\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\n\tvec3 camTar\t   = CameraPath(gTime - .0);\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\n\tcamTar.y += 370.0;\n\t\n\tfloat roll = .1 * sin(gTime * .25);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\tvec3 col;\n\tvec2 pos;\n\tif (dir.y > 0.0)\n\t{\n\t\tcol = GetSky(cameraPos, dir, pos);\n\t}else\n\t{\n\t\tcol = GetSea(cameraPos, dir, pos);\n\t}\n\tfloat l = exp(-length(pos) * .00002);\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\n\t\n\t\/\/ Do the lens flares...\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.6;\n\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\n\t}\n\t\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\n\t\/\/ Rain...\n#ifdef TEXTURE_NOISE\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\n#else\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\n#endif\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\n\tcol = clamp(col, 0.0,1.0);\n\n\t\/\/ Stretch RGB upwards... \n\t\/\/col = (1.0 - exp(-col * 2.0)) * 1.1565;\n\t\/\/col = (1.0 - exp(-col * 3.0)) * 1.052;\n\tcol = pow(col, vec3(.7));\n\t\/\/col = (col*col*(3.0-2.0*col));\n\n\t\/\/ Vignette...\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\n\t\n\tfragColor=vec4(col, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mdf3zr","date":"1360979082","viewed":25606,"name":"edge glow","username":"jmk","description":"A simple edge detection (sobel) shader.","likes":228,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float d;\n\nfloat lookup(vec2 p, float dx, float dy)\n{\n    vec2 uv = (p.xy + vec2(dx * d, dy * d)) \/ iResolution.xy;\n    vec4 c = texture(iChannel0, uv.xy);\n\t\n\t\/\/ return as luma\n    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    d = sin(iTime * 5.0)*0.5 + 1.5; \/\/ kernel offset\n    vec2 p = fragCoord.xy;\n    \n\t\/\/ simple sobel edge detection\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0);\n    gx += -2.0 * lookup(p, -1.0,  0.0);\n    gx += -1.0 * lookup(p, -1.0,  1.0);\n    gx +=  1.0 * lookup(p,  1.0, -1.0);\n    gx +=  2.0 * lookup(p,  1.0,  0.0);\n    gx +=  1.0 * lookup(p,  1.0,  1.0);\n    \n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0);\n    gy += -2.0 * lookup(p,  0.0, -1.0);\n    gy += -1.0 * lookup(p,  1.0, -1.0);\n    gy +=  1.0 * lookup(p, -1.0,  1.0);\n    gy +=  2.0 * lookup(p,  0.0,  1.0);\n    gy +=  1.0 * lookup(p,  1.0,  1.0);\n    \n\t\/\/ hack: use g^2 to conceal noise in the video\n    float g = gx*gx + gy*gy;\n    float g2 = g * (sin(iTime) \/ 2.0 + 0.5);\n    \n    vec4 col = texture(iChannel0, p \/ iResolution.xy);\n    col += vec4(0.0, g, g2, 1.0);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ds3WS","date":"1378461634","viewed":25587,"name":"Minecraft","username":"reinder","description":"port of javascript minecraft: http:\/\/jsfiddle.net\/uzMPU\/ combined with voxel-shader by inigo quilez (https:\/\/www.shadertoy.com\/view\/4dfGzs).","likes":175,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Minecraft. Created by Reinder Nijhoff 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4ds3WS\n\/\/\n\/\/ port of javascript minecraft: http:\/\/jsfiddle.net\/uzMPU\/\n\/\/ original code by Markus Persson: https:\/\/twitter.com\/notch\/status\/275331530040160256\n\/\/ combined with voxel-shader by inigo quilez (https:\/\/www.shadertoy.com\/view\/4dfGzs)\n\/\/\n\n#define SEALEVEL -25.\n#define MAXSTEPS 180 \n\/\/#define HOUSE\n\nvec3 sundir = normalize( vec3(-0.5,0.6,0.7) );\n\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\nfloat hash( in vec3 x ) {\n\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453);\n}\nvec3 hash3( vec3 n ) {\n\treturn fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));\n}\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)\/256.0, 0.0 ).x;\n}\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\n\n\/\/ port of minecraft\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t\/\/ 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 1. - h * (96.\/255.);\n\tcolor = vec3( 150.\/255., 108.\/255.,  74.\/255.); \/\/ 0x966C4A;\n\t\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) \/ 4., 4.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 18.)) {\n\t\t\tcolor = vec3( 106.\/255., 170.\/255.,  64.\/255.); \/\/ 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 19.)) {\n\t\t\tbr = br * (2. \/ 3.);\n\t\t}\n\t}\n\tif (i == 4) {\n\t\tcolor = vec3( 127.\/255., 127.\/255., 127.\/255.); \/\/ 0x7F7F7F;\n\t}\t\n\tif (i == 7) {\n\t\tcolor = vec3( 103.\/255., 82.\/255.,  49.\/255.); \/\/ 0x675231;\n\t\tif ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\t\n\t}\t\n#ifdef HOUSE\n\tif (i == 5) {\n\t\tcolor = vec3( 181.\/255.,  58.\/255.,  21.\/255.); \/\/ 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y \/ 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\tcolor = vec3( 188.\/255., 175.\/255., 165.\/255.); \/\/ 0xBCAFA5;\n\t\t}\n\t}\n#endif\n\tif (i == 9) {\n\t\tcolor = vec3(  64.\/255.,  64.\/255., 255.\/255.); \/\/ 0x4040ff;\n\t}\t\n\tif (i == 8) {\n\t\tcolor = vec3(  80.\/255., 217.\/255.,  55.\/255.); \/\/ 0x50D937;\n\t\tif ( h < 0.5) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (i == 10) {\n\t\tcolor = vec3(0.65,0.68,0.7)*1.35; \n\t\tbr = 1.;\n\t}\n\tcolor *= br;\n\t\n\treturn true;\n}\n\n\/\/=====================================================================\n\/\/ Code by inigo quilez - iq\/2013:\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat mapTerrain( vec2 p ) {\n\tp *= 0.02;\n\n\tfloat f;\n    f  = 0.500*textureLod( iChannel1, p*0.01, 0. ).x;\n    f += 0.1250*noise( p*4.01 );\n\treturn  max( 50.0*f-30., SEALEVEL);\n}\n\nvec3 gro = vec3(0.0);\n\nbool map(in vec3 c ) {\n\tvec3 p = c + 0.5;\n    \n\tfloat f = mapTerrain( p.xz );\n\n\tvec2 fc = floor( c.xz * 0.05 );\n\tvec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );\t\n\tbool hit = false;\n\t\n\tif( h.z > 0.75 ) {\n\t\tvec2 tp = floor(fc*20.+mod(h.yx*154.43125, 10.)) + 5.5;\n\t\tfloat h = mapTerrain( tp );\n\t\tif( h > SEALEVEL ) {\t\t\n\t\t\tif( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; \/\/ treetrunk\n\t\t\tif( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; \/\/ leaves\n\t\t} \n\t}\n\t\n\thit = c.y < f ? true:hit; \/\/ ground\n\t\n\tif( c.y > 8. && \n\t   sin( (c.y-8.)*(3.1415\/32.)) * (10.\/(c.y-7.)) * noise( c*0.08+(0.7*iTime)*vec3(0.3, 0.07, 0.12) ) \n\t   > 0.6 ) hit = true; \/\/ clouds\n\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.)); \/\/ house\n\tif( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {\n\t\thit = true;\n\t\tif( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t\tif( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t}\n#endif\n\t\n\tif( distance( gro, c ) < 1.5 ) return false;\n\t\n\treturn hit;\n}\n\n\nint mapMaterial(in vec3 c ) {\n\tint mat = 0;\n\tvec3 p = c + 0.5;\n    \n\tfloat f = ceil( mapTerrain( p.xz ) ); \n\t\n\tif( p.y <= f ) mat = 1; \/\/ ground\n\telse if( p.y < f+3. ) mat = 7; \/\/ treetrunk\n\telse if( p.y < f+10. ) mat = 8; \/\/ leaves\n\telse mat = 10; \/\/ clouds\n\t\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.));\n\tif( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {\n\t\tmat = 5;\n\t\tif( !map( c+vec3(0.,1.,0.) ) ) mat = 6;\n\t}\n#endif\n\t\n\treturn mat;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ ) \n\t{\n\t\tif( hit ) break;\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\tif( map(pos) ) { hit = true;}\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    \/\/ intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn hit?t:0.;\n\n}\n\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<18; i++ ) \n\t{\n\t\tif( map(pos) ) {res=0.0; break; }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\t\n\treturn res;\n}\n\nvec3 path( float t ) {\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, mapTerrain(p)+2.+4.*(1.-cos(iTime*0.1)), p.y );\n}\n\n\n\/\/=====================================================================\n\/\/ Ambient occlusion \n\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx;\n\tvec3 v2 = vos + nor - dir.yzx;\n\tvec3 v3 = vos + nor + dir.zxy;\n\tvec3 v4 = vos + nor - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\n\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.z < 0. ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    \/\/ camera\n\t\n\tfloat cr = 0.2*cos(0.1*iTime);\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+4. );\n\tta.y = ro.y;\n\tgro = ro;\n\t\n\t\/\/ build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\t\n\tif( t>0.0 ) {\n\t\tvec3 nor = -dir*sign(rd);\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tint mMat = mapMaterial( vos );\t\t\t\n\t\tvec3 mpos = mod( pos * 16., 16. );\n\t\t\n\t\tif( mMat == 1 ) {\n\t\t\tif( map( vos + vec3(0., 1., 0. ) ) ) {\n\t\t\t\tmMat = hash(vos) > 0.5?2:4; \n\t\t\t\tif( map( vos + vec3(0., 2., 0. ) ) ) mMat = 4;\n\t\t\t}\n\t\t\tif ( vos.y < SEALEVEL ) mMat = 9;\t\n\t\t} \n\t\t\n\t\tvec3 mCol;\n\t\tgetMaterialColor( mMat, nor.y!=0.?mpos.xz:nor.x!=0.?-mpos.zy+vec2(32.,32.):-mpos.xy+vec2(32.,32.),mCol );\n\t\t\n\t\t\/\/ lighting\n\t\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n\t\tfloat amb = 1.0;\/\/clamp(0.75 + pos.y\/100.0,0.0,1.0);\n\t\t\t\n        \/\/ ambient occlusion\n\t\t\n        vec4 ed = edges( vos, nor, dir );\n        vec4 co = corners( vos, nor, dir );\n        vec3 uvw = pos - vos;\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\n        float occ = 0.0; \n        \/\/ (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        \/\/ (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ\/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n\t\t\n\t\t\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\n\t\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\n\t\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\n\t\n\t\t\n\t\tif( mMat == 10 ) {\n\t\t\tcol = mix( col, mCol*lin*0.6, 0.3);\t\t\n\t\t} else {\n\t\t\t\/\/ atmospheric\n\t\t\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\n\t\t}\t\t\t\n\t}\n\t\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\t\n\t\/\/ contrast\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\n\t\t\n    col = clamp( col, 0.0, 1.0 );\n\n\t\/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsKfWd","date":"1534515016","viewed":25313,"name":"Quake \/ Introduction","username":"adx","description":"Quake (1996) starting area, ray-traced.\n\nKey map (Buffer A):[code]\nmenu        \tTab\/Esc\nresolution  \t1-5, +\/-\nperf. info  \tP\nmove        \tWASD\/ZQSD\/arrows\/space\nfire        \tE\/F\nrespawn     \tHome\/Bksp\ntex. filter \tT\nlight shafts\tL[\/code]Aim for the sky ;)","likes":229,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if __VERSION__ < 300\n#\terror Sorry, this shader requires WebGL 2.0!\n#endif\n\n\/***************************************************************\n  Quake \/ Introduction\n  A textureless* shader recreating the first room of Quake (1996)\n  Andrei Drexler 2018\n\n  For some details on how this shader was made, see this Twitter thread:\n  https:\/\/twitter.com\/andrei_drexler\/status\/1217945589989748742\n\n  Many thanks to:\n\n- id Software - for creating not only a great game\/series, but also\n  a thriving modding community around it through the release of\n  dev tools, code, and specs, inspiring new generations of game developers:\n  https:\/\/github.com\/id-Software\/Quake\n\n- John Romero - for creating such memorable designs in the first place,\n  and then releasing the original map files:\n  https:\/\/rome.ro\/news\/2016\/2\/14\/quake-map-sources-released\n\n- Inigo Quilez (@iq) - for his many articles\/code samples on signed distance fields,\n  ray-marching, noise and more:\n  https:\/\/iquilezles.org\/articles\/distfunctions\n  https:\/\/iquilezles.org\/articles\/smin\n  https:\/\/iquilezles.org\/articles\/voronoilines\n  https:\/\/iquilezles.org\/www\/index.htm\n\n- Jamie Wong (@jlfwong) - for his article on ray-marching\/SDF's (and accompanying samples):\n  http:\/\/jamie-wong.com\/2016\/07\/15\/ray-marching-signed-distance-functions\/\n\n- Mercury - for the hg_sdf library:\n  http:\/\/mercury.sexy\/hg_sdf\n\n- Paul Malin (@P_Malin) - for his awesome QTest shader, that prompted me to resume work and replace\n  the AO+TSS+negative\/capsule lights combo with proper lightmaps, somewhat similar to his solution:\n  https:\/\/www.shadertoy.com\/view\/MdGXDK\n\n- Brian Sharpe - for his GPU noise library\/blog:\n  https:\/\/github.com\/BrianSharpe\/GPU-Noise-Lib\n  https:\/\/briansharpe.wordpress.com\n\n- Dave Hoskins (@Dave_Hoskins) - for his 'Hash without Sine' functions:\n  https:\/\/www.shadertoy.com\/view\/4djSRW\n\n- Marc B. Reynolds (@MBR) - for his 2D Weyl hash code\n  https:\/\/www.shadertoy.com\/view\/Xdy3Rc\n  http:\/\/marc-b-reynolds.github.io\/math\/2016\/03\/29\/weyl_hash.html\n\n- Morgan McGuire (@morgan3d) - hash functions:\n  https:\/\/www.shadertoy.com\/view\/4dS3Wd\n  http:\/\/graphicscodex.com\n\n- Fabrice Neyret (@FabriceNeyret2) - for his 'Shadertoy - Unofficial' blog:\n  https:\/\/shadertoyunofficial.wordpress.com\n\n- Alan Wolfe (@demofox) - for his blog post on making a ray-traced snake game in Shadertoy,\n  which inspired me to get started with this shader:\n  https:\/\/blog.demofox.org\/2016\/01\/16\/making-a-ray-traced-snake-game-in-shadertoy\/\n  https:\/\/www.shadertoy.com\/view\/XsdGDX\n\n- Playdead - for their presentation\/code on temporal reprojection antialiasing:\n  http:\/\/twvideo01.ubm-us.net\/o1\/vault\/gdc2016\/Presentations\/Pedersen_LasseJonFuglsang_TemporalReprojectionAntiAliasing.pdf\n  https:\/\/github.com\/playdeadgames\/temporal\n\n- Sebastian Aaltonen (@sebbbi) - for his 'Advection filter comparison' shader:\n  https:\/\/www.shadertoy.com\/view\/lsG3D1\n\n- Bart Wronski - for his Poisson sampling generator:\n  https:\/\/github.com\/bartwronski\/PoissonSamplingGenerator\n\n- And, of course, Inigo Quilez and Pol Jeremias - for Shadertoy.\n  \n  ---\n\n  If you're interested in other recreations of id Software games,\n  you might also like:\n  \n- Wolfenstein 3D by @reinder:\n  https:\/\/www.shadertoy.com\/view\/4sfGWX\n\n- [SH16C] Doom by @P_Malin - fully playable E1M1, pushing the Shadertoy game concept to its limits:\n  https:\/\/www.shadertoy.com\/view\/lldGDr\n\n- Doom 2 by @reinder:\n  https:\/\/www.shadertoy.com\/view\/lsB3zD\n\n- QTest by @P_Malin:\n  https:\/\/www.shadertoy.com\/view\/MdGXDK\n\n  ---\n\n  * The blue noise texture doesn't count!\n***************************************************************\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Image buffer:\n\/\/ - loading screen\/console\n\/\/ - rendered image presentation + motion blur\n\/\/ - pain blend\n\/\/ - performance graph\n\/\/ - text (console\/skill selection\/demo stage)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ config.cfg \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FPS_GRAPH_MAX\t\t\t60\n#define PRINT_SKILL_MESSAGE\t\t1\n#define GAMMA_MODE\t\t\t\t0\t\t\/\/ [0=RGB; 1=luma]\n\n#define USE_CRT_EFFECT\t\t\t1\n#define CRT_MASK_WEIGHT\t\t\t1.\/16.\n#define CRT_SCANLINE_WEIGHT\t\t1.\/16.\n\n#define USE_MOTION_BLUR\t\t\t1\n#define MOTION_BLUR_FPS\t\t\t60\n#define MOTION_BLUR_AMOUNT\t\t0.5\t\t\/\/ fraction of frame time the shutter is open\n#define MOTION_BLUR_SAMPLES\t\t9\t\t\/\/ recommended range: 7..31\n\n#define DEBUG_LIGHTMAP\t\t\t0\t\t\/\/ 1=packed (RGBA); 2=unpacked (greyscale)\n#define DEBUG_ATLAS\t\t\t\t0\n#define DEBUG_TEXTURE\t\t\t-1\n#define DEBUG_CLICK_ZOOM\t\t4.0\t\t\/\/ zoom factor when clicking\n\n\/\/ For key bindings\/input settings, check out Buffer A\n\n\/\/ For a more enjoyable experience, try my Shadertoy FPS mode script\n\/\/ https:\/\/github.com\/andrei-drexler\/shadertoy-userscripts\n\n\/\/ TODO (maybe) \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ - Improve texture quality\n\/\/ - Clean-up & optimizations\n\/\/ - Functional console\n\/\/ - Gameplay & HUD polish\n\n\/\/ Snapshots \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ For a comparison with the initial release, check out\n\/\/ https:\/\/www.shadertoy.com\/view\/MtVBzV\n\n\/\/ For a comparison with the last version to use negative\/capsule lights,\n\/\/ ambient occlusion and temporal reprojection (for denoising), check out\n\/\/ https:\/\/www.shadertoy.com\/view\/Ws2SR1\n\n\/\/ Changelog \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ 2021-01-06\n\/\/ - Added support for +\/- in Firefox (different keycodes...)\n\/\/\n\/\/ 2020-11-15\n\/\/ - Changed mouselook code to be compatible with recent Shadertoy update\n\/\/\n\/\/ 2020-03-26\n\/\/ - Slightly more Quake-like acceleration\/friction\n\/\/\n\/\/ 2020-03-21\n\/\/ - Improved mouse movement handling for less common aspect ratios (e.g. portrait)\n\/\/ - Switched to centered motion blur sampling (better near screen edges)\n\/\/ - Moved scene quantization to Buffer D (before motion blur)\n\/\/\n\/\/ 2020-03-20\n\/\/ - Added workarounds for old ANGLE error (length can only be called on array names, not on array expressions)\n\/\/   https:\/\/github.com\/google\/angle\/commit\/bb2bbfbbf443fe0c1f8af12bacfdf1a945aea5a4#diff-b7bae477c1aea4edd01d4479fda69a87L5488\n\/\/\n\/\/ 2019-09-03\n\/\/ - Added window projection when light shafts are enabled\n\/\/\n\/\/ 2019-09-01\n\/\/ - Added basic\/subtle CRT effect, with menu option (off by default)\n\/\/\n\/\/ 2019-08-26\n\/\/ - Added subtle light shaft animation (VOLUMETRIC_ANIM in Buffer D)\n\/\/\n\/\/ 2019-08-24\n\/\/ - Bumped default brightness up another notch\n\/\/ - Fixed muzzle flash texture\n\/\/\n\/\/ 2019-08-22\n\/\/ - Added 'light shafts' menu option (off by default)\n\/\/\n\/\/ 2019-08-21\n\/\/ - Added volumetric lighting player shadow\n\/\/ - Tweaked volumetric lighting falloff\n\/\/\n\/\/ 2019-08-20\n\/\/ - Added light shafts (RENDER_VOLUMETRICS 1 in Buffer D)\n\/\/\n\/\/ 2019-07-02\n\/\/ - Switched entity rotations to quaternions in order to reduce register\n\/\/   pressure => ~35% GPU usage @800x450, down from ~40% (both at 1974 MHz)\n\/\/ - Bumped default brightness up a notch\n\/\/ - Tweaked WINDOW02_1 texture\n\/\/\n\/\/ 2019-06-30\n\/\/ - Added texture filter menu option (shortcut: T)\n\/\/\n\/\/ 2019-06-19\n\/\/ - Tweaked console id logo background\n\/\/ - Added motion blur menu option\n\/\/\n\/\/ 2019-06-12\n\/\/ - Tweaked QUAKE, WINDOW02_1 and WBRICK1_5 textures\n\/\/ - Tweaked weapon model SDF, textures and movement anim range\n\/\/ - Tweaked console background and text\n\/\/ - Added back optional motion blur (USE_MOTION_BLUR 1 in Image tab)\n\/\/ - Simplified naming scheme for Dave Hoskins' Hash without Sine functions\n\/\/\n\/\/ 2019-06-07\n\/\/ - Replaced FOV-based weapon model offset with pitch adjustment, eliminating\n\/\/   severe perspective distortion at higher vertical FOV's (e.g portrait mode)\n\/\/ - Fixed console version string misalignment on aspect ratios other than 16:9\n\/\/\n\/\/ 2019-06-06\n\/\/ - Added FOV-based weapon model offset\n\/\/ - Added BAKE_LIGHTMAP macro in Buffer B (for lower iteration times)\n\/\/ - Tweaked weapon model SDF\n\/\/ - Tweaked QUAKE texture\n\/\/\n\/\/ 2019-06-04\n\/\/ - Baked collision map planes to Buffer A, reducing its compilation time by ~6%\n\/\/   (~8.3 vs ~8.8 seconds) on my system\n\/\/ - Baked font glyphs to Buffer C, reducing Image buffer compilation time by ~14%\n\/\/   (~3.7 vs ~4.3 seconds)\n\/\/ - Removed unused UV visualisation code, reducing Buffer D compilation time by ~47%\n\/\/   (~1.0 vs ~1.9 seconds)\n\/\/ - Optimized pow10 function used in number printing\n\/\/\n\/\/ 2019-05-10\n\/\/ - Fixed infinite loading screen on OpenGL (out vs inout)\n\/\/\n\/\/ 2019-05-05\n\/\/ - Freeze entity and texture animations when menu is open\n\/\/\n\/\/ 2019-05-02\n\/\/ - Added 'Show weapon' and 'Noclip' options\n\/\/ - Tweaked WBRICK1_5 texture\n\/\/\n\/\/ 2019-04-24\n\/\/ - Switched to MBR's 2D Weyl hash for UI textures (for consistency across platforms)\n\/\/ - More UI texture tweaks\n\/\/\n\/\/ 2019-04-22\n\/\/ - Tweaked engraved textures (QUAKE, Options title)\n\/\/ - Added QUAKE\/id image on the left side of the menu\n\/\/ - Added 'Show lightmap' menu option\n\/\/ - Removed left-over guard band code\n\/\/\n\/\/ 2019-04-18\n\/\/ - Tweaked brushwork for slightly better lightmap utilization\n\/\/ - Changed lightmap dimensions to potentially accomodate another UI texture\n\/\/   in Buffer C even in 240x135 mode (smallest? Shadertoy thumbnail size)\n\/\/ - Tweaked menu title texture\n\/\/\n\/\/ 2019-04-17\n\/\/ - Wired all options\n\/\/ - Changed menu definition to array of structs (from array of ints), fixing menu\n\/\/   behavior on Surface 3 (codegen bug?)\n\/\/ - Paused gameplay when menu is open\n\/\/ - Changed default GAMMA_MODE (Image tab) to RGB (authentic)\n\/\/\n\/\/ 2019-04-16\n\/\/ - Added Options menu stub\n\/\/\n\/\/ 2019-04-11\n\/\/ - Added strafe key (Alt)\n\/\/ - Added FPS display in demo mode\n\/\/\n\/\/ 2019-04-10\n\/\/ - Added macro-based RLE for runs of 0 in the lightmap tile array (-~270 chars)\n\/\/ - Changed lightmap encoding and sample weighting\n\/\/ - Changed lightmap padding to 0.5 texels (from 2), reduced number of dilation\n\/\/   passes to 1 (from 2) and disabled lightmap blur pass\n\/\/ - Added zoom click for DEBUG_* modes (Image tab)\n\/\/\n\/\/ 2019-04-09\n\/\/ - More texture tweaks\n\/\/ - Added LOD_SLOPE_SCALE option (Buffer D)\n\/\/ - Reduced potentially lit surface set (4.3k smaller shader code)\n\/\/ - Added basic compression for the lightmap tile array in Buffer A (-1k)\n\/\/ - Changed default rendering scale to 1 (was 0.5)\n\/\/\n\/\/ 2019-03-31\n\/\/ - Changed GENERATE_TEXTURES macro (Buffer A) from on\/off switch to bit mask,\n\/\/   enabling selective texture compilation (for faster iteration)\n\/\/ - Tweaked WBRICK1_5 and WIZMET1_1 textures\n\/\/\n\/\/ 2019-03-26\n\/\/ - Tweaked CITY4_6, BRICKA2_2 and WINDOW02_1 textures\n\/\/\n\/\/ 2019-03-24\n\/\/ - Snapped console position to multiples of 2 pixels to avoid shimmering\n\/\/\n\/\/ 2019-03-23\n\/\/ - Robust thumbnail mode detection (based on iTime at iFrame 0)\n\/\/ - Increased brightness, especially in thumbnail mode\n\/\/ - Disabled weapon rendering for demo mode cameras 1 and 3 and tweaked their locations\n\/\/\n\/\/ 2019-03-22\n\/\/ - Fixed shadow discontinuities on the floor at the start of the skill hallways\n\/\/ - Increased lightmap padding to 2 px\n\/\/ - Optimized brushwork to reduce lightmapped area\n\/\/ - Added 3 more viewpoints for the demo mode\/thumbnail view\n\/\/\n\/\/ 2019-03-20\n\/\/ - Lightmap baking tweaks: 8xAA + 1 blur step, ignored solid samples,\n\/\/   extrapolation, better (but still hacky) handling of liquid brushes,\n\/\/   uv quantization, reduced baking time on low-end devices (e.g. Surface 3)\n\/\/ - Added color quantization for console & composited scene\n\/\/\n\/\/ 2019-03-18\n\/\/ - Replaced AO+TSS combo with actual lightmaps. Saved old version as\n\/\/   https:\/\/www.shadertoy.com\/view\/Ws2SR1\n\/\/\n\/\/ 2019-03-17\n\/\/ - Octahedral encoding for gbuffer normals\n\/\/\n\/\/ 2019-03-15\n\/\/ - Major performance improvement for Intel iGPUs: 45+ fps\n\/\/   on a Surface 3 (Atom x7-Z8700), up from ~1.4 fps (window mode)\n\/\/ - Added luminance gamma option (GAMMA_MODE in Image tab)\n\/\/\n\/\/ 2019-03-07\n\/\/ - Tighter encoding for axial brushes & atlas tiles\n\/\/ - Added experimental TSS_FILTER (Buffer D), based on\n\/\/   https:\/\/www.shadertoy.com\/view\/lsG3D1 (by sebbbi)\n\/\/\n\/\/ 2019-01-10\n\/\/ - Added workaround for Shadertoy double-buffering bug on resize.\n\/\/   This fixes partially black textures when pausing the shader,\n\/\/   shrinking the window and then maximizing it again\n\/\/\n\/\/ 2019-01-05\n\/\/ - Reduced overall compilation time by ~30% on my system (~28.5s -> ~20s),\n\/\/   mostly from Buffer A optimizations (~14s -> ~6s) :>\n\/\/\n\/\/ 2019-01-03\n\/\/ - Minor map compiler tweaks: flat (degenerate) liquid brushes,\n\/\/   improved precision of certain operations\n\/\/ - Added extra wall sliding friction\n\/\/\n\/\/ 2018-12-21\n\/\/ - Added Z\/Q bindings for AZERTY users\n\/\/\n\/\/ 2018-12-20\n\/\/ - Added # of targets left to HUD\n\/\/ - Added HUD line spacing, shadow box and color highlight effect\n\/\/\n\/\/ 2018-12-16\n\/\/ - Blue noise (instead of white) for the motion blur trail offset\n\/\/\n\/\/ 2018-12-14\n\/\/ - Disabled TSS\/motion blur when teleporting\n\/\/ - Minor motion blur tweaks\n\/\/\n\/\/ 2018-12-10\n\/\/ - Added experimental motion blur code (Buffer D),\n\/\/   mostly for video recording; off by default\n\/\/\n\/\/ 2018-12-04\n\/\/ - Slightly more compact map material assignment\n\/\/ - Removed overly cautious fudge factor (-5%) from slide move code\n\/\/\n\/\/ 2018-11-28\n\/\/ - Disabled continuous texture generation (~11% perf boost)\n\/\/\n\/\/ 2018-11-26\n\/\/ - Changed USE_PARTITION macro (in Buffer B) to axial\/non-axial bitmask\n\/\/\n\/\/ 2018-11-25\n\/\/ - Added BVL for axial brushes\n\/\/ - Removed BVH code (USE_PARTITION 2), keeping just the BVLs\n\/\/\n\/\/ 2018-11-24\n\/\/ - Minor map brushwork optimization\n\/\/ - Increased number of leaves in non-axial brush BVH from 7 to 10\n\/\/ - Further reduced Buffer B compilation time by about 40%\n\/\/\n\/\/ 2018-11-22\n\/\/ - Reduced Buffer B compilation time (~10.8s vs ~12.6s) using Klems'\n\/\/   loop trick in normal estimation function\n\/\/ - Added USE_ENTITY_AABB macro in Buffer B\n\/\/\n\/\/ 2018-11-19\n\/\/ - Resolution-dependent ray marching epsilon scale\n\/\/\n\/\/ 2018-11-18\n\/\/ - Tweaked loading screen sparks\n\/\/ - Disabled weapon firing before console slide-out\n\/\/ - Invalidated ground plane when noclipping\n\/\/\n\/\/ 2018-11-14\n\/\/ - More BVH\/BVL tweaks: greedy split node selection instead of recursive,\n\/\/   leaf count limit instead of primitive count, sorted BVL elements\n\/\/   based on distance to world center\n\/\/\n\/\/ 2018-11-13\n\/\/ - Tweaked SAH builder to consider all axes, not just the largest one\n\/\/\n\/\/ 2018-11-12\n\/\/ - Added non-axial brush partition (USE_PARTITION in Buffer B)\n\/\/\n\/\/ 2018-11-10\n\/\/ - Fixed weapon model TSS ghosting\n\/\/\n\/\/ 2018-11-09\n\/\/ - Moved teleporter effect to Buffer C (lower resolution) and optimized\n\/\/   its hashing\n\/\/ - Added lightning flash on game start\n\/\/\n\/\/ 2018-11-08\n\/\/ - Added fast path for axial brush rendering\n\/\/\n\/\/ 2018-11-07\n\/\/ - Added entity AABB optimization (and DEBUG_ENTITY_AABB option in Buffer B)\n\/\/\n\/\/ 2018-11-06\n\/\/ - Slightly optimized raymarching using bounding spheres\n\/\/   (~5% lower overall GPU usage at max frequency for 800x450 @144 fps)\n\/\/\n\/\/ 2018-11-03\n\/\/ - Started adding persistent state structs\/macros to improve\n\/\/   code readability (e.g. game_state.level instead of fragColor.x);\n\/\/   see end of Common buffer\n\/\/ - Reduced Buffer B compilation time (~6.9s vs ~7.5s on my system)\n\/\/\n\/\/ 2018-11-02\n\/\/ - Added credits\n\/\/\n\/\/ 2018-10-29\n\/\/ - Removed demo mode voronoi halftoning\n\/\/ - Added two more balloon sets to provide some round-to-round variation\n\/\/ - Tweaked round timing: can you make it to level 18?\n\/\/\n\/\/ 2018-10-27\n\/\/ - Added INVERT_MOUSE option (Buffer A)\n\/\/ - Desaturated\/darkened balloons during the game over transition\n\/\/\n\/\/ 2018-10-26\n\/\/ - Fixed bug that caused popped balloons to reappear during\n\/\/   the game over animation\n\/\/ - Disabled balloon popping during game over animation\n\/\/ - Added 'Game over' message\n\/\/\n\/\/ 2018-10-25\n\/\/ - Minor polish: blinking timer when almost out of time,\n\/\/   animated balloon scale-out when game is over\n\/\/\n\/\/ 2018-10-24\n\/\/ - Added level start countdown\n\/\/ - Added game timer; game is over when time expires\n\/\/ - Match particle color with balloon color, if a balloon was hit\n\/\/\n\/\/ 2018-10-23\n\/\/ - Added very basic target practice mode and reduced shotgun spread;\n\/\/   aim for the sky!\n\/\/\n\/\/ 2018-10-17\n\/\/ - Added automatic pitch adjustment when moving and not using the mouse\n\/\/   for looking around; see LOOKSPRING_DELAY in Buffer A\n\/\/\n\/\/ 2018-10-16\n\/\/ - Fixed occasional stair detection stutter at low FPS\n\/\/\n\/\/ 2018-10-12\n\/\/ - Optimized entity normal estimation: ~6.2 seconds to compile Buffer B,\n\/\/   down from ~8.6\n\/\/\n\/\/ 2018-10-11\n\/\/ - Sample weapon lighting at the ground level instead of a fixed distance\n\/\/   below the camera\n\/\/ - Added sliding down slopes\n\/\/\n\/\/ 2018-10-10\n\/\/ - Fixed weapon model lighting seam when crossing a power-of-two boundary\n\/\/ - Clamped lighting to prevent weapon model overdarkening from negative lights\n\/\/ - Minor collision map brushwork tweak\n\/\/\n\/\/ 2018-10-09\n\/\/ - Optimized Buffer A compilation time a bit (~14.1 vs ~14.8 seconds on my system)\n\/\/ - Fixed cloud tiling on Linux\n\/\/\n\/\/ 2018-10-08\n\/\/ - Added weapon firing on E\/F (not Ctrl, to avoid closing the window on Ctrl+W)\n\/\/ - Fixed TSS artifact when climbing stairs\n\/\/\n\/\/ 2018-10-07\n\/\/ - Tweaked ray-marching loop to eliminate silhouette sparkles\n\/\/ - Tweaked weapon model colors (this time without f.lux...)\n\/\/ - Disabled TSS for the weapon model\n\/\/\n\/\/ 2018-10-06\n\/\/ - Added shotgun model. Set RENDER_WEAPON to 0 in Buffer B to disable it\n\/\/ - Minor brushwork optimizations\n\/\/\n\/\/ 2018-10-04\n\/\/ - Fixed brushwork that deviated from the original design in the playable area\n\/\/ - Tightened up map definition some more (-13 lines)\n\/\/\n\/\/ 2018-10-03\n\/\/ - Added NOCLIP option (Buffer A)\n\/\/\n\/\/ 2018-10-01\n\/\/ - Faked two-sided lava\/water surfaces\n\/\/ - Added simple lava pain effect\n\/\/\n\/\/ 2018-09-30\n\/\/ - Tweaked player movement a bit (air control, smoother accel\/decel, head bobbing)\n\/\/ - Changed console typing animation :>\n\/\/\n\/\/ 2018-09-29\n\/\/ - Added basic collision detection; needs more work\n\/\/\n\/\/ 2018-09-19\n\/\/ - Reduced BufferC compilation time (~3s vs ~4.2s on my system)\n\/\/\n\/\/ 2018-09-18\n\/\/ - Added particle trail early-out (using screen-space bounds)\n\/\/\n\/\/ 2018-09-17\n\/\/ - Tightened up map definition even more (<100 lines now)\n\/\/\n\/\/ 2018-09-15\n\/\/ - Particle trail tweaks\n\/\/\n\/\/ 2018-09-14\n\/\/ - Made particles squares instead of disks (more authentic)\n\/\/ - Added proper occlusion between particles\n\/\/\n\/\/ 2018-09-11\n\/\/ - Added fireball particle trail (unoptimized)\n\/\/\n\/\/ 2018-09-10\n\/\/ - Lighting tweaks\n\/\/\n\/\/ 2018-09-08\n\/\/ - Added option to reduce TSS when in motion (by 50% by default).\n\/\/   Seems counter-intuitive, but the end result is that the image\n\/\/   stays sharp in motion, and static shots are still denoised\n\/\/ - Fixed temporal supersampling artifacts due to unclamped RGB input\n\/\/ - Increased sky layer resolution (128x128, same as in Quake) and\n\/\/   adjusted atlas accordingly (mip 0 is 512x256 now, filled 100%)\n\/\/ - Increased sky speed to roughly match Quake (super fast)\n\/\/ - Added manual shadows for the spikes in the 'hard' area\n\/\/\n\/\/ 2018-09-07\n\/\/ - YCoCg for temporal supersampling (USE_YCOCG in the Common tab)\n\/\/ - More map optimizations (~23% smaller now compared to first version)\n\/\/\n\/\/ 2018-09-06\n\/\/ - Added temporal supersampling (Buffer D), mostly to denoise AO\n\/\/ - Disabled map rendering during loading screen\n\/\/\n\/\/ 2018-09-05\n\/\/ - Map optimizations: ~17% fewer brushes\/planes, tweaked material\n\/\/   assignment, aligned some non-axial planes\n\/\/ - Added basic FPS display (mostly for full-screen mode)\n\/\/ - Added text scaling based on resolution\n\/\/\n\/\/ 2018-09-03\n\/\/ - Added depth\/depth+angle mip-mapping (USE_MIPMAPS 2\/3 in Buffer C)\n\/\/ - Added mip level dithering (LOD_DITHER in Buffer C)\n\/\/ - Even more compact map data storage (Buffer B)\n\/\/ - Tweaked lava and water textures a bit\n\/\/\n\/\/ 2018-08-30\n\/\/ - Tweaked entity SDF's a bit\n\/\/ - Slightly more compact map data formatting\n\/\/\n\/\/ 2018-08-27\n\/\/ - Added version number and id logo to console\n\/\/ - More thumbnail time-shifting\n\/\/\n\/\/ 2018-08-26\n\/\/ - Rewrote font code\n\/\/ - Added console loading\/typing intro\n\/\/\n\/\/ 2018-08-24\n\/\/ - Added (static) console text\n\/\/ - Added skill selection message triggers\n\/\/\n\/\/ 2018-08-23\n\/\/ - Added demo mode captions (with basic fixed-width font code).\n\/\/   Had to move some of the demo code, including the master switch,\n\/\/   to the Common tab.\n\/\/\n\/\/ 2018-08-22\n\/\/ - Enabled demo mode automatically for thumbnails and adjusted\n\/\/   thumbnail time again\n\/\/\n\/\/ 2018-08-21\n\/\/ - Added mouse filtering (Buffer A). Useful for video recording;\n\/\/   off by default\n\/\/ - Added voronoi halftoning and DEMO_MODE_HALFTONE in Buffer C\n\/\/\n\/\/ 2018-08-20\n\/\/ - Use halftoning instead of blue noise dither for demo mode\n\/\/   transition (doesn't confuse video encoders as much)\n\/\/\n\/\/ 2018-08-19\n\/\/ - Reduced compilation time for Buffer B by almost 5 seconds\n\/\/   on my machine (~7.6 vs ~12.5)\n\/\/\n\/\/ 2018-08-18\n\/\/ - Generate lower-res atlas\/mip chain when resolution is too low\n\/\/   to fit a full-res one (e.g. thumbnails, really small windows)\n\/\/ - Show intro in thumbnail mode (by offsetting time by ~10s)\n\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SETTINGS_CHANNEL\tiChannel0\n#define PRESENT_CHANNEL\t\tiChannel2\n#define NOISE_CHANNEL\t\tiChannel1\n#define LIGHTMAP_CHANNEL\tiChannel3\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n\/\/ Font \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    _A_= 1, _B_= 2, _C_= 3, _D_= 4, _E_= 5, _F_= 6, _G_= 7, _H_= 8, _I_= 9, _J_=10, _K_=11, _L_=12, _M_=13,\n    _N_=14, _O_=15, _P_=16, _Q_=17, _R_=18, _S_=19, _T_=20, _U_=21, _V_=22, _W_=23, _X_=24, _Y_=25, _Z_=26,\n    _0_=27, _1_=28, _2_=29, _3_=30, _4_=31, _5_=32, _6_=33, _7_=34, _8_=35, _9_=36,\n    _SPACE_         =  0,\n    _CARET_         = 45,\n    _PLUS_          = 37,\n    _MINUS_         = 38,\n    _SLASH_         = 39,\n    _DOT_           = 40,\n    _COMMA_         = 41,\n    _SEMI_          = 42,\n    _EXCL_          = 43,\n    _LPAREN_        = 46,\n    _RPAREN_        = 47,\n    _LBRACKET_      = 49,\n    _RBRACKET_      = 50,\n    _HOURGLASS_     = 53,\n    _BALLOON_       = 54,\n    _RIGHT_ARROW_   = 55\n;\n\nconst ivec2 CHAR_SIZE\t\t\t\t\t\t= ivec2(8);\nint g_text_scale_shift\t\t\t\t\t\t= 0;\n\nivec2 raw_text_uv(vec2 fragCoord)\t\t\t{ return ivec2(floor(fragCoord)); }\nivec2 text_uv(vec2 fragCoord)\t\t\t\t{ return ivec2(floor(fragCoord)) >> g_text_scale_shift; }\nint text_width(int num_chars)\t\t\t\t{ return num_chars << 3; }\nint line_index(int pixels_y)\t\t\t\t{ return pixels_y >> 3; }\nint glyph_index(int pixels_x)\t\t\t\t{ return pixels_x >> 3; }\nint cluster_index(int pixels_x)\t\t\t\t{ return pixels_x >> 5; }\nint get_byte(int index, int packed)\t\t\t{ return int((uint(packed) >> (index<<3)) & 255u); }\n\nvoid init_text_scale()\n{\n\tg_text_scale_shift = int(max(floor(log2(iResolution.x)-log2(799.)), 0.));\n}\n\nvec2 align(int num_chars, vec2 point, vec2 alignment)\n{\n    return point + alignment*-vec2(num_chars<<(3+g_text_scale_shift), 8<<g_text_scale_shift);\n}\n\nvec4 glyph_color(uint glyph, ivec2 pixel)\n{\n    uint x = glyph & 7u,\n         y = glyph >> 3u;\n    pixel = ivec2(ADDR2_RANGE_FONT.xy) + (ivec2(x, y) << 3) + (pixel & 7);\n    return texelFetch(LIGHTMAP_CHANNEL, pixel, 0);\n}\n\nvoid print_glyph(inout vec4 fragColor, ivec2 pixel, int glyph, vec4 color)\n{\n    color *= glyph_color(uint(glyph), pixel);\n    fragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n}\n\nconst int MAX_POW10_EXPONENT = 7;\n\nuint pow10(uint e)\n{\n    uint result = (e & 1u) != 0u ? 10u : 1u;\n    if ((e & 2u) != 0u) result *= 100u;\n    if ((e & 4u) != 0u) result *= 10000u;\n    return result;\n}\n\nint int_glyph(int number, int index)\n{\n    if (uint(index) >= uint(MAX_POW10_EXPONENT))\n        return _SPACE_;\n    if (number <= 0)\n        return index == 0 ? _0_ : _SPACE_;\n    uint power = pow10(uint(index));\n    return uint(number) >= power ? _0_ + int((uint(number)\/power) % 10u) : _SPACE_;\n}\n\n\/\/ Perf overlay \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 fps_color(float fps)\n{\n    return\n        fps >= 250. ? vec3(.75, .75,  1.) :\n        fps >= 144. ? vec3( 1., .75,  1.) :\n        fps >= 120. ? vec3( 1.,  1.,  1.) :\n    \tfps >= 60.  ? vec3( .5,  1.,  .5) :\n    \tfps >= 30.  ? vec3( 1.,  1.,  0.) :\n    \t              vec3( 1.,  0.,  0.);\n}\n\nfloat shadow_box(vec2 fragCoord, vec4 box, float border)\n{\n    vec2 clamped = clamp(fragCoord, box.xy, box.xy + box.zw);\n    return clamp(1.25 - length(fragCoord-clamped)*(1.\/border), 0., 1.);\n}\n\nvoid draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box, float border)\n{\n    fragColor.rgb *= mix(1.-shadow_box(fragCoord, box, border), 1., .5);\n}\n\nconst float DEFAULT_SHADOW_BOX_BORDER = 8.;\n\nvoid draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box)\n{\n    draw_shadow_box(fragColor, fragCoord, box, DEFAULT_SHADOW_BOX_BORDER);\n}\n\nvoid draw_perf(inout vec4 fragColor, vec2 fragCoord)\n{\n    Options options;\n    LOAD(options);\n\n    if (uint(g_demo_stage - DEMO_STAGE_FPS) < 2u)\n        options.flags |= OPTION_FLAG_SHOW_FPS;\n    \n    if (!test_flag(options.flags, OPTION_FLAG_SHOW_FPS|OPTION_FLAG_SHOW_FPS_GRAPH))\n        return;\n\n    float margin = 16. * min(iResolution.x * (1.\/400.), 1.);\n    vec2 anchor = iResolution.xy  - margin;\n    \n    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS_GRAPH))\n    {\n        const vec2 SIZE = vec2(ADDR_RANGE_PERF_HISTORY.z, 32.);\n        vec4 box = vec4(anchor - SIZE, SIZE);\n        draw_shadow_box(fragColor, fragCoord, box);\n\n        if (is_inside(fragCoord, box) > 0.)\n        {\n            vec2 address = ADDR_RANGE_PERF_HISTORY.xy + vec2(ADDR_RANGE_PERF_HISTORY.z-(fragCoord.x-box.x),0.);\n            vec4 perf_sample = load(address);\n            if (perf_sample.x > 0.)\n            {\n                float sample_fps = 1000.0\/perf_sample.x;\n                float fraction = sample_fps * (1.\/float(FPS_GRAPH_MAX));\n                \/\/fraction = 1.\/sqr(perf_sample.y\/MIN_DOWNSCALE);\n                if ((fragCoord.y-box.y) \/ box.w <= fraction)\n                    fragColor.rgb = fps_color(sample_fps);\n            }\n            return;\n        }\n        \n        anchor.y -= SIZE.y + DEFAULT_SHADOW_BOX_BORDER * 2.;\n    }\n\n    int fps = int(round(iFrameRate));\n    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS) && uint(fps - 1) < 9999u)\n    {\n        const int FPS_TEXT_LENGTH = 8; \/\/ 1234 FPS\n        const int FPS_SUFFIX_GLYPHS = (_SPACE_<<24) | (_F_<<16) | (_P_<<8) | (_S_<<0);\n    \n    \tvec2 text_pos = anchor - vec2((CHAR_SIZE << g_text_scale_shift) * ivec2(FPS_TEXT_LENGTH,1));\n    \n        ivec2 uv = text_uv(fragCoord - text_pos);\n        if (line_index(uv.y) == 0)\n        {\n            int glyph = FPS_TEXT_LENGTH - 1 - glyph_index(uv.x);\n            if (uint(glyph) < 4u)\n                glyph = get_byte(glyph, FPS_SUFFIX_GLYPHS);\n            else if (uint(glyph) < uint(FPS_TEXT_LENGTH))\n                glyph = int_glyph(fps, glyph-4);\n            else\n                glyph = _SPACE_;\n\n\t\t\tif (glyph != _SPACE_)\n            {\n                vec4 color = vec4(vec3(.875), 1.);\n                print_glyph(fragColor, uv, glyph, color);\n            }\n        }\n    }\n}\n\n\/\/ Console state \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Console\n{\n    float loaded;\n    float expanded;\n    float typing;\n};\n    \nConsole g_console;\n\nvoid update_console()\n{\n    const float\n        T0 = 0.,\n    \tT1 = T0 + CONSOLE_XFADE_DURATION,\n    \tT2 = T1 + CONSOLE_SLIDE_DURATION,\n    \tT3 = T2 + CONSOLE_TYPE_DURATION,\n    \tT4 = T3 + CONSOLE_SLIDE_DURATION;\n    \n    \/\/ snap console position to multiples of 2 pixels to avoid shimmering\n    \/\/ due to the use of noise and dFd* functions\n    float ysnap = iResolution.y * .5;\n    \n    g_console.loaded = linear_step(T0, T1, g_time);\n    g_console.expanded = 1.+-.5*(linear_step(T1, T2, g_time) + linear_step(T3, T4, g_time));\n    g_console.expanded = floor(g_console.expanded * ysnap + .5) \/ ysnap;\n    g_console.typing = linear_step(0., CONSOLE_TYPE_DURATION, g_time - T2);\n}\n\n\/\/ Console text \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GCONSOLE_TEXT,CONSOLE_TEXT,int,145)(33,0,9,16,16,28,28,29,29,60,60,60,80,98,117,133,151,179,179,203,203,204,204,230\n,250,269,289,289,305,328,355,373,398,423,439,0xc030f0e,0xf001009,0xf0e320e,269028355,303304201,51708943,0xe0f0914,\n302323238,0xe0f0913,455613440,85131297,302323218,522006016,2302498,788730371,50665477,462345,0xf141501,50665477,\n0x7060328,50665477,462345,0x60e0f03,52954889,402982662,0xe090305,84148231,0xc150106,0x6032814,85460231,0x70e0903,\n18157824,304612619,420416003,50926611,0xf0e000b,0xf060014,0x9040e15,85078030,0xf0a0401,0x9141319,2755331,301993742,\n0xf101305,470094606,336921126,921364,320147213,369164293,17565953,637864962,0xe150f13,18022404,0x90c100d,301991694,\n704975873,454827008,85336093,0xf091312,2031630,318767635,336724244,320147477,462345,68868,0xe010803,787726,353309470,\n0x900040e,0x914090e,436800513,0xf091401,403968526,336530944,335873024,85197573,1970948,0xf030e09,302977042,67441665,\n303300648,522260233,18023702,455613696,0xd0f0300,17370128,16782350,336593156,472519173,2369566,17237261,85203202,\n17106944,85460240,488308778,707010602,318775067,503320581,605814811,85139748,0xc010912,0x9120400,1180950,336137737,\n0x90c0109,0x904051a,0xe001810,67113999,50664453,263444));\n\nvec2 closest_point_on_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float t = clamp(dot(ap, ab)\/dot(ab, ab), 0., 1.);\n    return ab*t + a;\n}\n\nvec2 lit_line(vec2 uv, vec2 a, vec2 b, float thickness)\n{\n    const vec2 LIGHT_DIR = vec2(0, 1);\n    uv -= closest_point_on_segment(uv, a, b);\n    float len = length(uv);\n    return vec2(len > 0. ? dot(uv\/len, LIGHT_DIR) : 1., len + -.5*thickness);\n}\n\nvoid print_console_version(inout vec4 fragColor, vec2 uv, vec2 mins, vec2 size)\n{\n    size.y *= .25;\n    mins.y -= size.y * 1.75;\n    \n    if (is_inside(uv, vec4(mins, size)) < 0.)\n        return;\n    uv -= mins;\n    uv *= 1.\/size;\n    \n    ivec2 iuv = ivec2(vec2(CHAR_SIZE) * vec2(4, 1) * uv);\n    \n    int glyph = glyph_index(iuv.x);\n    if (uint(glyph) >= 4u)\n        return;\n    \n    const int GLYPHS = (_1_) | (_DOT_<<8) | (_0_<<16) | (_6_<<24);\n    const vec4 color = vec4(.62, .30, .19, 1);\n    \n    fragColor.rgb *= .625;\n    glyph = get_byte(glyph, GLYPHS);\n    print_glyph(fragColor, iuv, glyph, color);\n}\n\nvoid print_console_text(inout vec4 fragColor, vec2 fragCoord)\n{\n    float MARGIN = 12. * iResolution.x\/800.;\n    const vec4 COLORS[2] = vec4[2](vec4(vec3(.54), 1), vec4(.62, .30, .19, 1));\n    const uint COLORED = (1u<<3) | (1u<<7);\n    const int TYPING_LINE = 1;\n    \n    fragCoord.y -= iResolution.y * (1. - g_console.expanded);\n    ivec2 uv = text_uv(fragCoord - MARGIN);\n    bool typing = g_console.typing < 1.;\n    int cut = int(mix(float(CONSOLE_TEXT.data[0]-1), 2., g_console.loaded));\n    if (g_console.typing > 0.)\n        --cut;\n    \n    int line = line_index(uv.y);\n    if (uint(line) >= uint(CONSOLE_TEXT.data[0]-cut))\n        return;\n    line += cut;\n    int start = CONSOLE_TEXT.data[1+line];\n    int num_chars = CONSOLE_TEXT.data[2+line] - start;\n    \n    if (num_chars == 1)\n    {\n        const vec3 LINE_COLOR = vec3(.17, .13, .06);\n        float LINE_END = min(iResolution.x - MARGIN*2., 300.);\n        vec2 line = lit_line(vec2(uv.x, uv.y & 7) + .5, vec2(4. ,4.), vec2(LINE_END-4., 4.), 4.);\n        line.x = mix(1. + .5 * line.x, 1., linear_step(-.5, -1.5, line.y));\n        line.x *= 1. + -.25*random(vec2(uv));\n\t\tfragColor.rgb = mix(fragColor.rgb, LINE_COLOR * line.x, step(line.y, 0.));\n        return;\n    }\n    \n    int glyph = glyph_index(uv.x);\n    if (line == TYPING_LINE)\n    {\n        float type_fraction = clamp(2. - abs(g_console.typing * 4. + -2.), 0., 1.);\n        num_chars = clamp(int(float(num_chars-1)*type_fraction) + int(typing), 0, num_chars + int(typing));\n    }\n    if (uint(glyph) >= uint(num_chars))\n        return;\n\n    if (typing && line == TYPING_LINE && glyph == num_chars - 1)\n    {\n        glyph = fract(iTime*2.) < .5 ? _CARET_ : _SPACE_;\n    }\n    else\n    {\n        glyph += start;\n        glyph = get_byte(glyph & 3, CONSOLE_TEXT.data[CONSOLE_TEXT.data[0] + 2 + (glyph>>2)]);\n    }\n    \n    uint is_colored = line < 32 ? ((COLORED >> line) & 1u) : 0u;\n    vec4 color = COLORS[is_colored];\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n\/\/ Menu \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GOPTIONS,OPTIONS,int,53)(13,0,11,23,33,44,58,72,86,97,109,119,132,143,149,320147213,269680645,0x9040505,302323214,0xf0d0014\n,33886997,0x8070912,319098388,302191379,918789,85592339,386861075,17958400,17958157,0x8130514,0x600170f,0x7001310,0x8100112,\n337118484,332309,336333062,0xf0d1205,0xe0f0914,353108480,0x7090c12,318772232,335937800,336724755,0x6060500,320078597,1511176,\n0x807090c,268504340,386861075,17110784,0xe0e0f10,0x90c030f,16));\n\nvoid draw_menu(inout vec4 fragColor, vec2 fragCoord, Timing timing)\n{\n    MenuState menu;\n    LOAD(menu);\n\n    if (menu.open <= 0)\n        return;\n\n    vec4 options = load(ADDR_OPTIONS);\n\n    if (!test_flag(int(options[get_option_field(OPTION_DEF_SHOW_LIGHTMAP)]), OPTION_FLAG_SHOW_LIGHTMAP))\n    {\n        \/\/ vanilla\n        fragColor.rgb *= vec3(.57, .47, .23);\n        fragColor.rgb = ceil(fragColor.rgb * 24. + .01) \/ 24.;\n    }\n    else\n    {\n        \/\/ GLQuake\n       \tfragColor.rgb *= .2;\n    }\n\n    \/\/g_text_scale_shift = 1;\n    int text_scale = 1 << g_text_scale_shift;\n    float image_scale = float(text_scale);\n    vec2 header_size = ADDR2_RANGE_TEX_OPTIONS.zw * image_scale;\n    vec2 left_image_size = ADDR2_RANGE_TEX_QUAKE.wz * image_scale;\n    float left_image_offset = 120. * image_scale;\n\n    vec2 ref = iResolution.xy * vec2(.5, 1.);\n    ref.y -= min(float(CHAR_SIZE.y) * 4. * image_scale, iResolution.y \/ 16.);\n\n    ref.x += left_image_size.x * .5;\n    if (fragCoord.x < ref.x - left_image_offset)\n    {\n        fragCoord.y -= ref.y - left_image_size.y;\n        fragCoord.x -= ref.x - left_image_offset - left_image_size.x;\n        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;\n        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_QUAKE.w) && uint(addr.y) < uint(ADDR2_RANGE_TEX_QUAKE.z))\n\t        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr.yx + ivec2(ADDR2_RANGE_TEX_QUAKE.xy), 0).rgb;\n        return;\n    }\n\n    ref.y -= header_size.y;\n    if (fragCoord.y >= ref.y)\n    {\n        fragCoord.y -= ref.y;\n        fragCoord.x -= ref.x - header_size.x * .5;\n        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;\n        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_OPTIONS.z) && uint(addr.y) < uint(ADDR2_RANGE_TEX_OPTIONS.w))\n\t        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr + ivec2(ADDR2_RANGE_TEX_OPTIONS.xy), 0).rgb;\n        return;\n    }\n\n    ref.y -= float(CHAR_SIZE.y) * 1. * image_scale;\n\n    const int\n        BASE_OFFSET\t\t= CHAR_SIZE.x * 0,\n        ARROW_OFFSET\t= CHAR_SIZE.x,\n        VALUE_OFFSET\t= CHAR_SIZE.x * 3,\n        MARGIN\t\t\t= 0,\n        LINE_HEIGHT\t\t= MARGIN + CHAR_SIZE.y;\n\n    ivec2 uv = text_uv(fragCoord - ref);\n    uv.x -= BASE_OFFSET;\n    int line = -uv.y \/ LINE_HEIGHT;\n    if (uint(line) >= uint(NUM_OPTIONS))\n        return;\n    \n    uv.y = uv.y + (line + 1) * LINE_HEIGHT;\n    if (uint(uv.y - MARGIN) >= uint(CHAR_SIZE.y))\n        return;\n    uv.y -= MARGIN;\n    \n    int glyph = 0;\n    if (uv.x < 0)\n    {\n        int begin = OPTIONS.data[1 + line];\n        int end = OPTIONS.data[2 + line];\n        int num_chars = end - begin;\n        uv.x += num_chars * CHAR_SIZE.x;\n    \tglyph = glyph_index(uv.x);\n        if (uint(glyph) >= uint(num_chars))\n            return;\n        glyph += begin;\n        glyph = get_byte(glyph & 3, OPTIONS.data[OPTIONS.data[0] + 2 + (glyph>>2)]);\n    }\n    else if (uint(uv.x - ARROW_OFFSET) < uint(CHAR_SIZE.x))\n    {\n        const float BLINK_SPEED = 2.;\n        uv.x -= ARROW_OFFSET;\n        if (menu.selected == line && (fract(iTime * BLINK_SPEED) < .5 || test_flag(timing.flags, TIMING_FLAG_PAUSED)))\n            glyph = _RIGHT_ARROW_;\n    }\n    else if (uv.x >= VALUE_OFFSET)\n    {\n        uv.x -= VALUE_OFFSET;\n\n        int item_height = CHAR_SIZE.y << g_text_scale_shift;\n\n        MenuOption option = get_option(line);\n        int option_type = get_option_type(option);\n        int option_field = get_option_field(option);\n        if (option_type == OPTION_TYPE_SLIDER)\n        {\n            const float RAIL_HEIGHT = 7.;\n            vec2 p = vec2(uv.x, uv.y & 7) + .5;\n            vec2 line = lit_line(p, vec2(8, 4), vec2(8 + 11*CHAR_SIZE.x, 4), RAIL_HEIGHT);\n            float alpha = linear_step(-.5, .5, -line.y);\n            line.y \/= RAIL_HEIGHT;\n            float intensity = 1. + line.x * step(-.25, line.y);\n            intensity = mix(intensity, 1. - line.x * .5, line.y < -.375);\n            fragColor.rgb = mix(fragColor.rgb, vec3(.25, .23, .19) * intensity, alpha);\n\n            float value = options[option_field] * .1;\n            float thumb_pos = 8. + value * float(CHAR_SIZE.x * 10);\n            p.x -= thumb_pos;\n            p -= vec2(4);\n            float r = length(p);\n            alpha = linear_step(.5, -.5, r - 4.);\n            intensity = normalize(p).y * .25 + .75;\n            p *= vec2(3., 1.5);\n            r = length(p);\n            intensity += linear_step(.5, -.5, r - 4.) * (safe_normalize(p).y * .125 + .875);\n\n            fragColor.rgb = mix(fragColor.rgb, vec3(.36, .25, .16) * intensity, alpha);\n            return;\n        }\n        else if (option_type == OPTION_TYPE_TOGGLE)\n        {\n            glyph = glyph_index(uv.x);\n            if (uint(glyph) >= 4u)\n                return;\n    \t\tconst int\n                OFF = (_O_<<8) | (_F_<<16) | (_F_<<24),\n    \t\t\tON  = (_O_<<8) | (_N_<<16);\n            int value = test_flag(int(options[option_field]), get_option_range(option)) ? ON : OFF;\n            glyph = get_byte(glyph & 3, value);\n        }\n    }\n    else\n    {\n        return;\n    }\n    \n    vec4 color = vec4(.66, .36, .25, 1);\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n\/\/ Loading screen\/console \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 loading_spinner(vec2 fragCoord)\n{\n    float radius = max(32.\/1920. * iResolution.x, 8.);\n    float margin = max(96.\/1920. * iResolution.x, 12.);\n    vec2 center = iResolution.xy - vec2(margin + radius);\n    float angle = atan(fragCoord.y-center.y, fragCoord.x-center.x) \/ (PI*2.);\n    float dist = length(fragCoord - center)\/radius;\n    angle += smoothen(fract(iTime*SQRT2));\n    angle = fract(-angle);\n\n    const float MAX_ANGLE = .98;\n    const float MIN_ANGLE = .12;\n    float angle_alpha = angle < MAX_ANGLE ? max((angle-MIN_ANGLE)\/(MAX_ANGLE-MIN_ANGLE), 0.) :\n    \t1.-(angle-MAX_ANGLE)\/(1.-MAX_ANGLE);\n    float radius_alpha = around(.85, mix(.09, .1, angle_alpha), dist);\n\n    vec3 color = sqr(1.-clamp(dist*.375, 0., 1.)) * vec3(.25,.125,0.);\n    color += sqrt(radius_alpha) * angle_alpha;\n    \n    return color;\n}\n\nvec3 burn_xfade(vec3 from, vec3 to, float noise_mask, float fraction)\n{\n    const float HEADROOM = .7;\n    fraction = mix(-HEADROOM, 1.+HEADROOM, fraction);\n    float burn_mask = linear_step(fraction-HEADROOM, fraction, noise_mask);\n    from *= burn_mask;\n    to = mix(from, to, linear_step(fraction, fraction-HEADROOM, noise_mask));\n    \n    const bool GARISH_FLAMES = false;\n    if (GARISH_FLAMES)\n    {\n        to *= 1. - around(.5, .49, burn_mask);\n        to += vec3(1.,.3,.2) * around(.80, .19, burn_mask);\n        to += vec3(1.,.5,.3) * around(.84, .15, burn_mask) * .25;\n        to += vec3(1.,1.,.4) * around(.94, .05, burn_mask);\n    }\n\n    return to;\n}\n\nfloat sdf_apply_light(float sdf, vec2 dir)\n{\n    vec2 grad = normalize(vec2(dFdx(sdf), dFdy(sdf)));\n    return dot(dir, grad);\n}\n\nfloat sdf_shadow(float sdf, float size, vec2 light_dir)\n{\n    vec2 n = sdf_normal(sdf);\n    float thresh = size * max(abs(dFdx(sdf)), abs(dFdy(sdf)));\n    float mask = clamp(sdf\/thresh, 0., 1.);\n    return clamp(1. - sdf\/size, 0., 1.) * clamp(-dot(light_dir, n), 0., 1.) * mask;\n}\n\nfloat sdf_modern_nail(vec2 uv, vec2 top, vec2 size)\n{\n    const float head_flat_frac = .025;\n    const float head_round_frac = .05;\n    const float body_thickness = .5;\n\n    float h = clamp((top.y - uv.y) \/ size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)\/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) \/ (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_modern_Q(vec2 uv, float age)\n{\n    float aspect_ratio = iResolution.x\/iResolution.y;\n    float noise = turb(uv * vec2(31.7,27.9)\/aspect_ratio, .7, 1.83);\n    float dist = sdf_disk(uv, vec2(.5, .68), .315);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .727), .267));\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, 1.1), .21));\n    dist = sdf_union(dist, sdf_modern_nail(uv, vec2(.5, .59), vec2(.08, .52)));\n    return dist + (noise * .01 - .005) * sqr(age);\n}\n\nvec2 embossed_modern_Q(vec2 uv, float age, float bevel, vec2 light_dir)\n{\n    float px = 2.\/iResolution.y, EPS = .1 * px;\n    vec3 sdf;\n    for (int i=0; i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_modern_Q(uv2, age);\n    }\n    vec2 gradient = normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, px);\n    bevel = clamp(1. + sdf.z\/bevel, 0., 1.);\n    return vec2(mask * (.5 + sqrt(bevel) * dot(gradient, light_dir)), mask);\n}\n\nvoid print_console_logo(inout vec4 fragColor, vec2 uv, vec2 mins, vec2 size, float noise)\n{\n    float inside = is_inside(uv, vec4(mins, size));\n    float fade = noise * -.01;\n    if (inside < fade)\n        return;\n    vec3 background = mix(vec3(.09, .05, 0), vec3(.38, .17, .11), sqr(smoothen(noise)));\n    fragColor.rgb = mix(fragColor.rgb, background, sqr(linear_step(fade, .001, inside)));\n    const float QUANTIZE = 32.;\n    uv = (uv - mins) \/ size;\n    uv = round(uv * QUANTIZE) * (1.\/QUANTIZE);\n    float logo = (sdf_id(uv) + noise*.015) * QUANTIZE;\n    float mask = clamp(2.-logo, 0., 1.) * linear_step(1., .25, noise);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), mask * .5);\n    mask = clamp(1.-logo, 0., 1.) * linear_step(1., .25, noise);\n    fragColor.rgb = mix(fragColor.rgb, vec3(.43, .22, .14), mask);\n}\n\nfloat sparks(vec2 uv, vec2 size)\n{\n    vec2 cell = floor(uv) + .5;\n    vec2 variation = hash2(cell);\n    cell += (variation-.5) * .9;\n    return sqr(variation.x) * clamp(1.-length((cell - uv)*(1.\/size)), 0., 1.);\n}\n\nvoid draw_console(inout vec4 fragColor, vec2 fragCoord, Lighting lighting)\n{\n    fragColor.rgb *= linear_step(1., .5, g_console.expanded);\n\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tif (uv.y < 1. - g_console.expanded)\n        return;\n    \n    float loaded = lighting.progress;\n    float xfade = clamp(g_time \/ CONSOLE_XFADE_DURATION, 0., 1.);\n    \n    uv.y -= 1. - g_console.expanded;\n    float vignette = 1. - clamp(length(uv - .5)*2., 0., 1.);\n  \n    float aspect_ratio = iResolution.x\/iResolution.y;\n    uv.x = (uv.x - 0.5) * aspect_ratio + 0.5;\n\n    float base = turb(uv * vec2(31.7,27.9)\/aspect_ratio, .7, 2.5);\n    \n    \/\/ loading screen (modern style) \/\/\n    \n    vec3 modern = vec3(linear_step(.45, .7, base) * 0.1);\n    if (xfade < 1.)\n    {\n        modern *= sqr(vignette);\n\n        const float MODERN_LOGO_SCALE = .75;\n\n        vec2 logo_uv = (uv - .5) * (1.\/MODERN_LOGO_SCALE) + .5;\n        vec4 modern_logo = embossed_modern_Q(logo_uv, loaded, .006, vec2(.7, .3)).xxxy;\n\n        float flame_flicker = mix(.875, 1., smooth_noise(2.+iTime*7.3));\n        float scratches = linear_step(.35, .6, turb(vec2(480.,8.)*rotate(uv, 22.5), .5, 2.) * base);\n        scratches += linear_step(.25, .9, turb(vec2(480.,16.)*rotate(uv, -22.5), .5, 2.) * base);\n\n        modern_logo.rgb *= vec3(.32,.24,.24);\n        modern_logo.rgb *= smoothstep(.75, .0, abs(uv.x-.5));\n        modern_logo.rgb *= 1.8 - 0.8 * linear_step(.55, mix(.15, .35, loaded), base);\n        modern_logo.rgb *= 1. - scratches * .4;\n        modern_logo.rgb *= 1. + 4. * sqr(clamp(1. - length(uv - vec2(.76, .37))*2.3, 0., 1.));\n        modern_logo.rgb *= 1. + flame_flicker*2.5*vec3(1.,0.,0.) * sqr(clamp(1. - length(uv - vec2(.20, .40))*3., 0., 1.));\n\n        modern = mix(modern, modern_logo.rgb, modern_logo.a);\n\n        float flame_vignette = length((uv - vec2(.5,0.))*vec2(.5, 1.3));\n        float flame_intensity = flame_vignette;\n        flame_intensity = sqr(sqr(clamp(1.-flame_intensity, 0., 1.)) * flame_flicker);\n        flame_intensity *=\n            turb(uv * vec2(41.3,13.6)\/aspect_ratio + vec2(0.,-iTime), .5, 2.5) +\n            turb(uv * vec2(11.3,7.6)\/aspect_ratio + vec2(0.,-iTime*.9), .5, 2.5);\n        modern += vec3(.25,.125,0.) * flame_intensity;\n\n        vec2 spark_uv = vec2(uv + vec2(turb(uv*1.3, .5, 2.)*.6, -iTime*.53));\n        float spark_intensity =\n            sparks(vec2(11.51, 3.13) * spark_uv,\t\t\t\tvec2(.06,.05)) * 2. +\n            sparks(vec2(4.19, 1.37) * spark_uv + vec2(1.3,3.7),\tvec2(.06,.05)) * 1.;\n        spark_intensity *= flame_intensity;\n\n        spark_uv = vec2(uv*.73 + vec2(turb(uv*1.25, .7, 1.9)*.4, -iTime*.31));\n        float spark_intensity2 = turb(vec2(25.1, 11.5) * spark_uv, .5, 2.);\n        spark_intensity2 = 0.*linear_step(.43, .95, spark_intensity2) * flame_intensity*.2;\n        modern += vec3(1.,1.,.3) * (spark_intensity + spark_intensity2);\n\n        modern += loading_spinner(fragCoord);\n    }\n    \n    \/\/ console (classic style) \/\/\n\n    const float CLASSIC_LOGO_SCALE = 1.1;\n    const vec2 CLASSIC_LOGO_CENTER = vec2(.5, .45);\n    const vec2 CLASSIC_LIGHT_DIR = vec2(0, 1.5);\n    float classic_shadow_size = mix(.01, .05, base);\n    vec2 CLASSIC_SHADOW_OFFSET = CLASSIC_LIGHT_DIR * classic_shadow_size;\n    float classic_logo_distortion = base * .015 - .01;\n    float classic_logo = sdf_Q((uv-CLASSIC_LOGO_CENTER) \/ CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;\n    \n    vec2 aspect = vec2(iResolution.x \/ iResolution.y, 1.);\n    vec2 box_size = vec2(.5) * aspect - mix(.005, .03, sqr(base));\n    float classic_console_box = sdf_centered_box(uv, vec2(.5), box_size);\n    \n    const vec2 CLASSIC_ID_LOGO_MARGIN = vec2(24.\/450., 48.\/450.);\n    const float CLASSIC_ID_LOGO_SIZE = 64.\/450.;\n    const float CLASSIC_ID_LOGO_BOX_JAGGEDNESS = 0.; \/\/0.02;\n    \n    vec2 logo_mins = vec2((.5+.5*aspect.x)-CLASSIC_ID_LOGO_MARGIN.x-CLASSIC_ID_LOGO_SIZE, CLASSIC_ID_LOGO_MARGIN.y);\n    \n    classic_console_box = sdf_exclude(classic_console_box,\n                                      4.*sdf_box(uv, logo_mins, logo_mins + CLASSIC_ID_LOGO_SIZE) +\n                                      (base*2.-1.) * CLASSIC_ID_LOGO_BOX_JAGGEDNESS);\n   \n    float noise2 = turb(uv*43.7, .5, 2.0)-.15;\n    classic_console_box = sdf_exclude(classic_console_box, noise2*.1);\n    \n    float bevel_size = mix(.001, .07, sqr(base));\n    float classic_sdf = sdf_exclude(classic_console_box, classic_logo+.01);\n    float classic_base = sdf_emboss(classic_sdf, bevel_size, CLASSIC_LIGHT_DIR).x;\n\n#if 1\n    \/\/ slightly odd, gradient-based automatic shadow\n    float classic_shadow = sdf_shadow(classic_sdf, classic_shadow_size, CLASSIC_LIGHT_DIR);\n#else\n    \/\/ smooth version with secondary SDF sample\n    \/\/ only sampling the Q logo SDF, not the composite one!\n    float classic_shadow_sample = sdf_Q((uv+CLASSIC_SHADOW_OFFSET-CLASSIC_LOGO_CENTER) \/ CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;\n    float classic_shadow = sdf_mask(classic_logo) * clamp(classic_shadow_sample\/classic_shadow_size+.3, 0., 1.);\n#endif\n\n    vec4 classic = vec4(mix(vec3(.07,.03,.02)*(1.+base*2.)*(1.-classic_shadow), vec3(.24,.12,.06), classic_base), 1.);\n    classic.rgb *= 1. - .05*linear_step(.35, .3, base);\n    classic.rgb *= 1. + .05*linear_step(.6, .65, base);\n    \n    print_console_logo(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE), base);\n\tprint_console_version(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE));\n    print_console_text(classic, fragCoord);\n    \n    classic.rgb = floor(classic.rgb * 64. + random(floor(uv*128.))) * (1.\/64.);\n\n\tfloat burn_fraction = xfade * (2.-clamp(length(uv-vec2(.5,0.)), 0., 1.));\n    fragColor.rgb = burn_xfade(modern, classic.rgb, base, burn_fraction);\n}\n\n\/\/ Skill selection message \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GSKILL_MESSAGES,SKILL_MESSAGES,int,27)(3,0,28,58,86,319358996,0xc010800,85131276,335742220,17104915,318773523,\n0xc0c090b,319358996,0xc010800,85131276,335742220,0xf0e0013,0xc010d12,0x90b1300,0x8140c0c,0x8001309,789505,84673811,\n1250307,68288776,0x90b1300,3084));\n\nvoid print_skill_message(inout vec4 fragColor, in vec2 fragCoord, vec3 cam_pos)\n{\n#if PRINT_SKILL_MESSAGE\n    float time = fract(iTime*.5);\n    if (time > .9375)\n        return;\n\n    MenuState menu;\n    LOAD_PREV(menu);\n    if (menu.open > 0)\n        return;\n    \n    ivec2 uv = text_uv(fragCoord - iResolution.xy*vec2(.5,.64));\n    if (line_index(uv.y) != 0)\n        return;\n    \n\tvec4 cam_angles = load(ADDR_CAM_ANGLES);\n    if (min(cam_angles.x, 360.-cam_angles.x) >= 90.)\n        return;\n\n    const vec3 PLAYER_DIMS = vec3(16., 16., 48.);\n    const vec3 SKILL_TRIGGER_BOUNDS[] = vec3[](\n        vec3(112,832,-32),vec3(336,1216,16),\n        vec3(448,832,-8),vec3(656,1232,40),\n        vec3(752,800,-24),vec3(976,1248,24)\n\t);\n    \n    int line = -1;\n    int num_skills = NO_UNROLL(3);\n    for (int i=0; i<num_skills; ++i)\n    {\n        int i2 = i + i;\n        vec3 mins = SKILL_TRIGGER_BOUNDS[i2];\n        vec3 maxs = SKILL_TRIGGER_BOUNDS[i2+1];\n        vec3 delta = clamp(cam_pos.xyz, mins, maxs) - cam_pos.xyz;\n        if (max_component(abs(delta) - PLAYER_DIMS) <= 0.)\n            line = i;\n    }\n    \n    if (line == -1)\n        return;\n\n    int start = SKILL_MESSAGES.data[1+line];\n    int num_chars = SKILL_MESSAGES.data[2+line] - start;\n    uv.x += text_width(num_chars) >> 1;\n    \n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return;\n    \n    glyph += start;\n    glyph = get_byte(glyph & 3, SKILL_MESSAGES.data[SKILL_MESSAGES.data[0] + 2 + (glyph>>2)]);\n\n    vec4 color = vec4(vec3(.6), 1);\n    print_glyph(fragColor, uv, glyph, color);\n#endif \/\/ PRINT_SKILL_MESSAGE\n}\n\n\/\/ Level start countdown \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GGAME_OVER,GAME_OVER,int,4)(9,84738311,85331712,18));\n\nbool print_countdown(inout vec4 fragColor, vec2 fragCoord)\n{\n    GameState game_state;\n    MenuState menu;\n    LOAD(game_state);\n    LOAD(menu);\n    if (game_state.level <= 0. && game_state.level == floor(game_state.level) || menu.open > 0)\n        return false;\n    \n    float remaining = fract(abs(game_state.level)) * 10.;\n    if (remaining <= 0. || remaining >= BALLOON_SCALEIN_TIME + LEVEL_COUNTDOWN_TIME)\n        return true;\n    \n    ivec2 uv = text_uv(fragCoord - iResolution.xy*vec2(.5,.66)) >> 1;\n    if (line_index(uv.y) != 0)\n        return true;\n    \n    bool go = remaining < BALLOON_SCALEIN_TIME;\n    \n    int num_chars = (game_state.level < 0.) ? GAME_OVER.data[0] : go ? 4 : 1;\n    \n    uv.x += (num_chars * CHAR_SIZE.x) >> 1;\n\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return true;\n    \n    const int GO_MESSAGE = (_SPACE_<<0) | (_G_<<8) | (_O_<<16) | (_SPACE_<<24);\n    \n    if (game_state.level < 0.)\n    \tglyph = get_byte(glyph & 3, GAME_OVER.data[1 + (glyph>>2)]);\n    else if (go)\n        glyph = (GO_MESSAGE >> (glyph<<3)) & 255;\n    else\n    \tglyph = _0_ + int(ceil(remaining - BALLOON_SCALEIN_TIME));\n    \n    vec4 color = vec4(vec3(.875), 1.);\n    if (fract(remaining - BALLOON_SCALEIN_TIME) > .875)\n        color.rgb = vec3(.60, .30, .23);\n    print_glyph(fragColor, uv, glyph, color);\n    \n    return true;\n}\n\n\/\/ Pain blend, skill message \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid add_effects(inout vec4 fragColor, vec2 fragCoord, bool is_thumbnail)\n{\n    if (is_demo_mode_enabled(is_thumbnail))\n        return;\n\n    vec4 cam_pos = load(ADDR_CAM_POS);\n    vec3 fireball = get_fireball_offset(g_animTime) + FIREBALL_ORIGIN;\n    float pain = linear_step(80., 16., length(cam_pos.xyz - fireball));\n    vec3 lava_delta = abs(cam_pos.xyz - clamp(cam_pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1]));\n    float lava_dist = max3(lava_delta.x, lava_delta.y, lava_delta.z);\n    if (lava_dist <= 32.)\n        pain = mix(.5, .75, clamp(fract(g_animTime*4.)*2.+-1., 0., 1.));\n    if (lava_dist <= 0.)\n        pain += .45;\n   \tfragColor.rgb = mix(fragColor.rgb, vec3(1., .125, .0), sqr(clamp(pain, 0., 1.)) * .75);\n    \n    if (!print_countdown(fragColor, fragCoord))\n    \tprint_skill_message(fragColor, fragCoord, cam_pos.xyz);\n}\n\n\/\/ Demo stage descriptions \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GDEMO_STAGES,DEMO_STAGES,int,24)(6,0,12,19,29,37,45,64,1638674,336791812,84086273,0xd120f0e,353569793,17638934,\n0xe091010,402985991,85071124,0x7090c13,0xe091408,402985991,85071124,2424851,0x807090c,0x70e0914));\n\nvoid describe_demo_stage(inout vec4 fragColor, vec2 fragCoord)\n{\n    int line = -1;\n    switch (g_demo_stage)\n    {\n        case DEMO_STAGE_DEPTH:\t\tline = 0; break;\n        case DEMO_STAGE_NORMALS:\tline = 1; break; \n        case DEMO_STAGE_UV:\t\t\tline = 2; break; \n        case DEMO_STAGE_TEXTURES:\tline = 3; break;\n        case DEMO_STAGE_LIGHTING:\tline = 4; break;\n        case DEMO_STAGE_COMPOSITE:\tline = 5; break;\n        default:\t\t\t\t\treturn;\n    }\n\n    int start = DEMO_STAGES.data[1+line];\n    int num_chars = DEMO_STAGES.data[2+line] - start;\n\n    vec2 margin = iResolution.xy * 16.\/450.;\n    vec2 ref = vec2(iResolution.x - margin.x, margin.y);\n    vec2 pos = align(num_chars, ref, vec2(1, 0));\n\n    vec4 box = vec4(pos, (ivec2(num_chars, 1) * CHAR_SIZE) << g_text_scale_shift);\n    float radius = 16. * exp2(float(g_text_scale_shift));\n    box += radius * (.25 * vec4(1, 1, -2, -2));\n    float intensity = (g_demo_stage == DEMO_STAGE_LIGHTING) ? .5 : .625;\n    fragColor.rgb *= mix(1., intensity, sqr(shadow_box(fragCoord, box, radius)));\n\n    ivec2 uv = text_uv(fragCoord - pos);\n    if (line_index(uv.y) != 0)\n        return;\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return;\n\n    glyph += start;\n    glyph = get_byte(glyph & 3, DEMO_STAGES.data[DEMO_STAGES.data[0] + 2 + (glyph>>2)]);\n\n    vec4 color = vec4(1);\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nWRAP(GGAME_HUD_STATS,GAME_HUD_STATS,int,12)(3,0,9,18,27,85329164,12,302060544,320079111,581<<18,1293,0));\n\nvoid draw_game_info(inout vec4 fragColor, vec2 fragCoord)\n{\n    GameState game_state;\n    LOAD(game_state);\n    if (game_state.level == 0.)\n        return;\n\n    const int NUM_LINES = GAME_HUD_STATS.data[0];\n    const int PREFIX_LENGTH = GAME_HUD_STATS.data[2] - GAME_HUD_STATS.data[1];\n    const int NUM_DIGITS = 4;\n    const int LINE_LENGTH = PREFIX_LENGTH + NUM_DIGITS;\n    \n    const float MARGIN = 16.;\n    vec2 anchor = vec2(MARGIN, iResolution.y - MARGIN - float((CHAR_SIZE*NUM_LINES) << g_text_scale_shift));\n    \n    ivec2 uv = text_uv(fragCoord - anchor);\n    int line = NUM_LINES - 1 - line_index(uv.y);\n    \n    \/\/ ignore last 2 lines (time\/targets left) if game is over\n    int actual_num_lines = NUM_LINES - (int(game_state.level < 0.) << 1);\n    \n    vec4 box = vec4(MARGIN, iResolution.y-MARGIN, ivec2(LINE_LENGTH, (actual_num_lines<<1)-1)<<g_text_scale_shift);\n    box.zw *= vec2(CHAR_SIZE);\n    box.y -= box.w;\n    draw_shadow_box(fragColor, fragCoord, box);\n    \n    \/\/ line spacing\n    if ((line & 1) != 0)\n        return;\n    line >>= 1;\n    \n    if (uint(line) >= uint(actual_num_lines))\n        return;\n       \n    int start = GAME_HUD_STATS.data[1+line];\n    int num_chars = GAME_HUD_STATS.data[2+line] - start;\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) < uint(num_chars))\n    {\n        glyph += start;\n        glyph = get_byte(glyph & 3, GAME_HUD_STATS.data[GAME_HUD_STATS.data[0] + 2 + (glyph>>2)]);\n    }\n    else\n    {\n        glyph -= num_chars;\n        if (uint(glyph) >= uint(NUM_DIGITS))\n            return;\n        \n        int stat;\n        switch (line)\n        {\n            case 0: stat = int(abs(game_state.level)); break;\n            case 1: stat = int(game_state.targets_left); break;\n            case 2: stat = int(game_state.time_left); break;\n            default: stat = 0; break;\n        }\n\t\tglyph = NUM_DIGITS - 1 - glyph;\n        glyph = int_glyph(stat, glyph);\n    }\n\n    const vec3 HIGHLIGHT_COLOR = vec3(.60, .30, .23);\n    vec4 color = vec4(vec3(.75), 1.);\n    if ((line == 0 && fract(game_state.level) > 0.) ||\n        (line == 1 && fract(game_state.targets_left) > 0.))\n    {\n\t\tcolor.rgb = HIGHLIGHT_COLOR;\n    }\n    else if (line == 2 && game_state.time_left < 10.)\n    {\n        float blink_rate = game_state.time_left < 5. ? 2. : 1.;\n        if (fract(game_state.time_left * blink_rate) > .75)\n            color.rgb = HIGHLIGHT_COLOR;\n    }\n\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid apply_motion_blur(inout vec4 fragColor, vec2 fragCoord, vec4 camera_pos)\n{\n#if !USE_MOTION_BLUR\n    return;\n#endif\n\n    \/\/ not right after teleporting\n    float teleport_time = camera_pos.w;\n    if (teleport_time > 0. && abs(iTime - teleport_time) < 1e-4)\n        return;\n    \n    vec3 camera_angles = load(ADDR_CAM_ANGLES).xyz;\n    vec3 prev_camera_pos = load(ADDR_PREV_CAM_POS).xyz;\n    vec3 prev_camera_angles = load(ADDR_PREV_CAM_ANGLES).xyz;\n    mat3 view_matrix = rotation(camera_angles.xyz);\n    mat3 prev_view_matrix = rotation(prev_camera_angles.xyz);\n\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame, iResolution.xy, g_downscale);\n    ndc_scale_bias.xy \/= iResolution.xy;\n    vec2 actual_res = ceil(iResolution.xy \/ g_downscale);\n    vec4 coord_bounds = vec4(vec2(.5), actual_res - .5);\n\n    vec3 dir = view_matrix * unproject(fragCoord * ndc_scale_bias.xy + ndc_scale_bias.zw);\n    vec3 surface_point = camera_pos.xyz + dir * VIEW_DISTANCE * fragColor.w;\n    dir = surface_point - prev_camera_pos;\n    dir = dir * prev_view_matrix;\n    vec2 prev_coord = project(dir).xy;\n    prev_coord = (prev_coord - ndc_scale_bias.zw) \/ ndc_scale_bias.xy;\n    float motion = length(prev_coord - fragCoord);\n\n    if (fragColor.w <= 0. || motion * g_downscale < 4.)\n        return;\n    \n    \/\/ Simulating a virtual shutter to avoid excessive blurring at lower FPS\n    const float MOTION_BLUR_SHUTTER = MOTION_BLUR_AMOUNT \/ float(MOTION_BLUR_FPS);\n    float shutter_fraction = clamp(MOTION_BLUR_SHUTTER\/iTimeDelta, 0., 1.);\n\n    vec2 rcp_resolution = 1.\/iResolution.xy;\n    vec4 uv_bounds = coord_bounds * rcp_resolution.xyxy;\n    vec2 trail_start = fragCoord * rcp_resolution;\n    vec2 trail_end = prev_coord * rcp_resolution;\n    trail_end = mix(trail_start, trail_end, shutter_fraction * linear_step(4., 16., motion * g_downscale));\n\n    float mip_level = log2(motion \/ (float(MOTION_BLUR_SAMPLES) + 1.)) - 1.;\n    mip_level = clamp(mip_level, 0., 2.);\n\n    const float INC = 1.\/float(MOTION_BLUR_SAMPLES);\n    float trail_offset = BLUE_NOISE(fragCoord).x * INC - .5;\n    float trail_weight = 1.;\n    for (float f=0.; f<float(MOTION_BLUR_SAMPLES); ++f)\n    {\n        vec2 sample_uv = mix(trail_start, trail_end, trail_offset + f * INC);\n        if (is_inside(sample_uv, uv_bounds) < 0.)\n            continue;\n        vec4 s = textureLod(iChannel2, sample_uv, mip_level);\n        \/\/ Hack: to avoid weapon model ghosting we'll ignore samples landing in that area.\n        \/\/ This introduces another artifact (sharper area behind the weapon model), but\n        \/\/ this one is harder to notice in motion...\n        float weight = step(0., s.w);\n        fragColor.rgb += s.xyz * weight;\n        trail_weight += weight;\n    }\n    \n    fragColor.rgb \/= trail_weight;\n}\n\nvoid present_scene(out vec4 fragColor, vec2 fragCoord, Options options)\n{\n    fragCoord \/= g_downscale;\n    vec2 actual_res = ceil(iResolution.xy \/ g_downscale);\n\n    \/\/ cover up our viewmodel lighting hack\n    bool is_ground_sample = is_inside(fragCoord, iResolution.xy - 1.) > 0.;\n    if (is_ground_sample)\n        fragCoord.x--;\n\n    vec4 camera_pos = load(ADDR_CAM_POS);\n    vec3 lava_delta = abs(camera_pos.xyz - clamp(camera_pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1]));\n    float lava_dist = max3(lava_delta.x, lava_delta.y, lava_delta.z);\n    if (lava_dist <= 0.) \n    {\n        fragCoord += sin(iTime + 32. * (fragCoord\/actual_res).yx) * actual_res * (1.\/192.);\n        fragCoord = clamp(fragCoord, vec2(.5), actual_res - .5);\n    }\n\n    fragColor = texelFetch(PRESENT_CHANNEL, ivec2(fragCoord), 0);\n    \n    if (test_flag(options.flags, OPTION_FLAG_MOTION_BLUR))\n    \tapply_motion_blur(fragColor, fragCoord, camera_pos);\n\n    fragColor.rgb = linear_to_gamma(fragColor.rgb);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid color_correction(inout vec4 fragColor, vec2 fragCoord, bool is_thumbnail)\n{\n    if (g_demo_stage != DEMO_STAGE_NORMALS)\n    {\n        Options options;\n        LOAD(options);\n    \t\n        float gamma = is_thumbnail ? .8 : 1. - options.brightness * .05;\n#if GAMMA_MODE\n    \tfragColor.rgb = gamma_to_linear(fragColor.rgb);\n    \tfloat luma = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    \tif (luma > 0.)\n\t    \tfragColor.rgb *= pow(luma, gamma) \/ luma;\n\t    fragColor.rgb = linear_to_gamma(fragColor.rgb);\n#else\n\t    fragColor.rgb = pow(fragColor.rgb, vec3(gamma));\n#endif\n    }\n    \n    \/\/ dithering, for smooth depth\/lighting visualisation (when not quantized!)\n    fragColor.rgb += (BLUE_NOISE(fragCoord).rgb - .5) * (1.\/127.5);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nbool draw_debug(out vec4 fragColor, vec2 fragCoord)\n{\n    if (iMouse.z > 0.)\n        fragCoord = (fragCoord - iMouse.xy) \/ DEBUG_CLICK_ZOOM + iMouse.xy;\n    ivec2 addr = ivec2(fragCoord);\n\n#if defined(DEBUG_TEXTURE) && (DEBUG_TEXTURE >= 0) && (DEBUG_TEXTURE < NUM_MATERIALS)\n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    vec4 tile = get_tile(DEBUG_TEXTURE);\n    vec2 uv = fragCoord \/ min_component(iResolution.xy\/tile.zw) + tile.xy;\n    fragColor = is_inside(uv, tile) < 0. ? vec4(0) :\n    \ttexelFetch(SETTINGS_CHANNEL, ivec2(ATLAS_OFFSET + uv * atlas_scale), 0);\n    return true;\n#endif\n\n#if DEBUG_ATLAS\n    fragColor = texelFetch(SETTINGS_CHANNEL, addr, 0);\n    return true;\n#endif\n\n#if DEBUG_LIGHTMAP >= 2\n    int channel = addr.x & 3;\n    addr.x >>= 2;\n    if (uint(addr.y) < LIGHTMAP_SIZE.x && uint(addr.x) < LIGHTMAP_SIZE.y\/4u)\n    {\n        LightmapSample s = decode_lightmap_sample(texelFetch(LIGHTMAP_CHANNEL, addr.yx, 0));\n        float l = s.values[channel], w = s.weights[channel];\n#if DEBUG_LIGHTMAP >= 3\n    \tfragColor = vec4(w <= 0. ? vec3(1,0,0) : l == 0. ? vec3(0,0,1) : vec3(l), 1);\n#else\n        fragColor = vec4(vec3(clamp(l, 0., 1.)), 1);\n#endif\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    return true;\n#elif DEBUG_LIGHTMAP\n    vec4 texel = texelFetch(LIGHTMAP_CHANNEL, addr, 0);\n    fragColor =\n        uint(addr.x) < LIGHTMAP_SIZE.x && uint(addr.y) < LIGHTMAP_SIZE.y\/4u ?\n        \tdecode_lightmap_sample(texel).values :\n    \t\ttexel;\n    return true;\n#endif\n\n    return false;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid crt_effect(inout vec4 fragColor, vec2 fragCoord, Options options)\n{\n#if USE_CRT_EFFECT\n\tif (!test_flag(options.flags, OPTION_FLAG_CRT_EFFECT))\n        return;\n    \n    vec2 uv = fragCoord \/ iResolution.xy, offset = uv - .5;\n    fragColor.rgb *= 1. + sin(fragCoord.y * (TAU\/4.)) * (CRT_SCANLINE_WEIGHT);\n    fragColor.rgb *= clamp(1.6 - sqrt(length(offset)), 0., 1.);\n    \n    const float\n        MASK_LO = 1. - (CRT_MASK_WEIGHT) \/ 3.,\n        MASK_HI = 1. + (CRT_MASK_WEIGHT) \/ 3.;\n\n    vec3 mask = vec3(MASK_LO);\n    float i = fract((floor(fragCoord.y) * 3. + fragCoord.x) * (1.\/6.));\n    if (i < 1.\/3.)\t\tmask.r = MASK_HI;\n    else if (i < 2.\/3.)\tmask.g = MASK_HI;\n    else\t\t\t\tmask.b = MASK_HI;\n\n\tfragColor.rgb *= mask;\n#endif \/\/ USE_CRT_EFFECT\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (draw_debug(fragColor, fragCoord))\n        return;\n    \n    Options options;\n    LOAD(options);\n    \n    g_downscale = get_downscale(options);\n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    \n    Lighting lighting;\n    LOAD(lighting);\n\n    UPDATE_TIME(lighting);\n    UPDATE_DEMO_STAGE_EX(fragCoord\/g_downscale, g_downscale, is_thumbnail);\n    init_text_scale();\n    update_console();\n\n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n\n    present_scene\t\t(fragColor, fragCoord, options);\n    add_effects\t\t\t(fragColor, fragCoord, is_thumbnail);\n    describe_demo_stage\t(fragColor, fragCoord);\n    draw_game_info\t\t(fragColor, fragCoord);\n    draw_perf\t\t\t(fragColor, fragCoord);\n    draw_menu\t\t\t(fragColor, fragCoord, timing);\n    draw_console\t\t(fragColor, fragCoord, lighting);\n    color_correction\t(fragColor, fragCoord, is_thumbnail);\n    crt_effect\t\t\t(fragColor, fragCoord, options);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ config.cfg \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DEMO_MODE\t\t\t\t0\n#define DEMO_STAGE_DURATION\t\t1.5\n#define DEMO_MODE_HALFTONE\t\t1\t\t\/\/ 0=blue noise dither; 1=disks\n\n#define GRAVITY\t\t\t\t\t800.0\n#define LOADING_TIME\t\t\t2.5\t\t\/\/ lower bound, in seconds\n#define LIGHTMAP_AA_SAMPLES\t\t8\n\n\/\/ Used for mipmap generation, texture filtering and light shafts\n\/\/ Lighting is performed in 'gamma' (non-linear) space for a more authentic look\n#define USE_GAMMA_CORRECTION\t2\t\t\/\/ 0=off; 1=sRGB; 2=gamma 2.0\n\n#define VIEW_DISTANCE\t\t\t2048.0\n\n\/\/ Debug switches \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define COMPILE_FASTER\t\t\t1\n#define USE_DISCARD\t\t\t\t1\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#if COMPILE_FASTER\n\t#define NO_UNROLL(k)\t\t((k)+min(iFrame,0))\n#else\n\t#define NO_UNROLL(k)\t\t(k)\n#endif\n\n#if USE_DISCARD\n\t#define DISCARD\t\t\t\tdiscard\n#else\n\t#define DISCARD\t\t\t\treturn\n#endif\n\n\/\/ Speed up your shaders on Intel iGPUs with this one weird trick!\n\/\/ No, seriously - on a Surface 3 (Atom x7-Z8700), wrapping global\n\/\/ arrays in structs increased framerate from ~1.4 FPS to 45+!\n\n\/\/ Side note: token pasting would be really handy right about now...\n#define WRAP(struct_name, name, type, count)\\\n    const struct struct_name { type data[count]; } name = struct_name(type[count]\n\n\/\/ Standard materials (cached in Buffer A) \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MATERIAL_WIZMET1_2      0\n#define MATERIAL_WBRICK1_5      1\n#define MATERIAL_WIZMET1_1      2\n#define MATERIAL_WIZ1_4         3\n#define MATERIAL_CITY4_7        4\n#define MATERIAL_BRICKA2_2      5\n#define MATERIAL_CITY4_6        6\n#define MATERIAL_WIZWOOD1_5     7\n#define MATERIAL_TELEPORT       8\n#define MATERIAL_WINDOW02_1     9\n#define MATERIAL_COP3_4         10\n#define MATERIAL_WATER1         11\n#define MATERIAL_LAVA1          12\n#define MATERIAL_WATER2         13\n#define MATERIAL_DEM4_1         14\n#define MATERIAL_QUAKE          15\n#define MATERIAL_SKY1           16\n#define MATERIAL_SKY1B          17\n#define MATERIAL_FLAME          18\n#define MATERIAL_ZOMBIE         19\n#define NUM_MATERIALS           20\n\nconst int\n\tATLAS_WIDTH                 = 512,\n\tATLAS_HEIGHT                = 256;\n\/\/ atlas usage: 100%\n\nWRAP(Tiles,tiles,int,10)(1703961,1835035,393221,851975,67633173,917533,1441807,16777246,38470217,2031639));\n\nvec4 get_tile(int index)\n{\n    int data = (tiles.data[index >> 1] >> ((index & 1) << 4)) & 4095;\n    return vec4(ivec4(data & 7, (data >> 3) & 7, ((data >> 6) & 7) + 1, ((data >> 9) & 7) + 1) << 6);\n}\n\n\/\/ Extra materials \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    BASE_SHOTGUN_MATERIAL\t\t= NUM_MATERIALS,\n    MATERIAL_SHOTGUN_PUMP\t\t= 0 + BASE_SHOTGUN_MATERIAL,\n    MATERIAL_SHOTGUN_BARREL\t\t= 1 + BASE_SHOTGUN_MATERIAL,\n    MATERIAL_SHOTGUN_FLASH\t\t= 2 + BASE_SHOTGUN_MATERIAL,\n    NUM_SHOTGUN_MATERIALS\t\t= 3,\n\n    BASE_TARGET_MATERIAL\t\t= BASE_SHOTGUN_MATERIAL + NUM_SHOTGUN_MATERIALS,\n    NUM_TARGETS\t\t\t\t\t= 8;\n\n\/\/ Material helpers \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    MATERIAL_MASK_SKY\t\t\t= (1<<MATERIAL_SKY1) | (1<<MATERIAL_SKY1B),\n    MATERIAL_MASK_LIQUID\t\t= (1<<MATERIAL_WATER1) | (1<<MATERIAL_WATER2) | (1<<MATERIAL_LAVA1) | (1<<MATERIAL_TELEPORT);\n\nbool is_material_viewmodel(const int material)\n{\n    return uint(material-BASE_SHOTGUN_MATERIAL) < uint(NUM_SHOTGUN_MATERIALS);\n}\n\nbool is_material_balloon(const int material)\n{\n    return uint(material-BASE_TARGET_MATERIAL) < uint(NUM_TARGETS);\n}\n\nbool is_material_any_of(const int material, const int mask)\n{\n    return uint(material) < 32u && (mask & (1<<material)) != 0;\n}\n\nbool is_material_sky(const int material)\n{\n    return is_material_any_of(material, MATERIAL_MASK_SKY);\n}\n\nbool is_material_liquid(const int material)\n{\n    return is_material_any_of(material, MATERIAL_MASK_LIQUID);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec3 LAVA_BOUNDS[]=vec3[2](vec3(704,768,-176),vec3(1008,1232,-112));\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec2\tATLAS_OFFSET\t\t= vec2(0, 24);\nconst vec2\tATLAS_SIZE\t\t\t= vec2(ATLAS_WIDTH, ATLAS_HEIGHT);\nconst float\tATLAS_CHAIN_WIDTH\t= float(ATLAS_WIDTH) * 1.5;\nconst vec2\tATLAS_CHAIN_SIZE\t= vec2(ATLAS_CHAIN_WIDTH, ATLAS_HEIGHT);\nconst int\tMAX_MIP_LEVEL\t\t= 6;\n\nfloat exp2i(lowp int exponent)\n{\n    return intBitsToFloat(floatBitsToInt(1.) + (exponent << 23));\n}\n\nvec2 mip_offset(lowp int level)\n{\n    return level < 2 ?\n        vec2(level, 0) :\n    \tvec2(1.5 - exp2i(1 - level), .5);\n}\n\nvec4 atlas_chain_bounds(float scale)\n{\n    return vec4(ATLAS_OFFSET, ATLAS_CHAIN_SIZE*scale);\n}\n\nvec4 atlas_mip0_bounds(float scale)\n{\n    return vec4(ATLAS_OFFSET, ATLAS_SIZE*scale);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float\n\tPI\t\t\t= 3.1415926536,\n\tHALF_PI \t= PI * 0.5,\n    TAU\t\t\t= PI * 2.0,\n    PHI\t\t\t= 1.6180340888,\n\tSQRT2\t\t= 1.4142135624,\n\tINV_SQRT2\t= SQRT2 * 0.5;\n\n\/\/ Rotations \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmat3 rotation(vec3 angles)\n{\n    angles = radians(angles);\n\tfloat sy = sin(angles.x), sp = sin(angles.y), sr = sin(angles.z);\n\tfloat cy = cos(angles.x), cp = cos(angles.y), cr = cos(angles.z);\n    \n    return mat3\n\t(\n        cr*cy+sy*sp*sr,\t\tcr*sy-cy*sp*sr,\t\tcp*sr,\n        -sy*cp,\t\t\t\tcy*cp,\t\t\t\tsp,\n        cr*sy*sp-cy*sr,\t\t-cr*cy*sp-sy*sr,\tcr*cp\n\t);\n}\n\nmat3 rotation(vec2 angles)\n{\n    angles = radians(angles);\n\tfloat\tsy = sin(angles.x), sp = sin(angles.y);\n\tfloat\tcy = cos(angles.x), cp = cos(angles.y);\n   \n    return mat3\n\t(\n        cy,\t\tsy,\t\t0.,\n        -sy*cp,\tcy*cp,\tsp,\n        sy*sp,\t-cy*sp,\tcp\n\t);\n}\n\nmat2 rotation(float angle)\n{\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n    return rotation(angle)*p;\n}\n\nvec3 rotate(vec3 p, float yaw)\n{\n    p.xy = rotate(p.xy, yaw);\n    return p;\n}\n\nvec3 rotate(vec3 p, vec2 angles)\n{\n    p.yz = rotate(p.yz, angles.y);\n    p.xy = rotate(p.xy, angles.x);\n    return p;\n}\n\nvec3 rotate(vec3 p, vec3 angles)\n{\n    return rotation(angles)*p;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ TODO: make sure these values are used explicitly where needed\n\nconst float FOV = 90.;\nconst float FOV_FACTOR = tan(radians(FOV*.5));\nconst int FOV_AXIS = 0;\n\nfloat scale_fov(float fov, float scale)\n{\n    return 2. * degrees(atan(scale * tan(radians(fov * .5))));\n}\n\nvec2 get_resolution_fov_scale(vec2 resolution)\n{\n    return resolution \/ resolution[FOV_AXIS];\n}\n\nvec2 compute_fov(vec2 resolution)\n{\n    vec2 scale = get_resolution_fov_scale(resolution);\n    return vec2(scale_fov(FOV, scale.x), scale_fov(FOV, scale.y));\n}\n\nvec3 unproject(vec2 ndc)\n{\n    return vec3(ndc.x, 1., ndc.y);\n}\n\nvec3 project(vec3 direction)\n{\n    return vec3(direction.xz\/direction.y, direction.y);\n}\n\nvec2 taa_jitter(int frame)\n{\n#if 0\n    const float SCALE = 1.\/8.;\n    const float BIAS = .5 * SCALE - .5;\n    frame &= 7;\n    int ri = ((frame & 1) << 2) | (frame & 2) | ((frame & 4) >> 2);\n    return vec2(frame,ri)*SCALE + BIAS;\n#else\n    return vec2(0);\n#endif\n}\n\n\/\/ xy=scale, zw=bias\nvec4 get_viewport_transform(int frame, vec2 resolution, float downscale)\n{\n    vec2 ndc_scale = vec2(downscale);\n    vec2 ndc_bias = vec2(0);\/\/ndc_scale * taa_jitter(frame) \/ resolution.xy;\n    ndc_scale *= 2.;\n    ndc_bias  *= 2.;\n    ndc_bias  -= 1.;\n    ndc_scale.y *= resolution.y \/ resolution.x;\n    ndc_bias.y  *= resolution.y \/ resolution.x;\n    return vec4(ndc_scale, ndc_bias);\n}\n\nvec2 hammersley(int i, int total)\n{\n    uint r = uint(i);\n\tr = ((r & 0x55u) << 1u) | ((r & 0xAAu) >> 1u);\n\tr = ((r & 0x33u) << 2u) | ((r & 0xCCu) >> 2u);\n\tr = ((r & 0x0Fu) << 4u) | ((r & 0xF0u) >> 4u);\n    return vec2(float(i)\/float(total), float(r)*(1.\/256.)) + .5\/float(total);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nbool test_flag(int var, int flag)\n{\n    return (var & flag) != 0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat max3(float a, float b, float c)\n{\n    return max(a, max(b, c));\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat min_component(vec2 v)\t\t{ return min(v.x, v.y); }\nfloat min_component(vec3 v)\t\t{ return min(v.x, min(v.y, v.z)); }\nfloat min_component(vec4 v)\t\t{ return min(min(v.x, v.y), min(v.z, v.w)); }\nfloat max_component(vec2 v)\t\t{ return max(v.x, v.y); }\nfloat max_component(vec3 v)\t\t{ return max(v.x, max(v.y, v.z)); }\nfloat max_component(vec4 v)\t\t{ return max(max(v.x, v.y), max(v.z, v.w)); }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nint dominant_axis(vec3 nor)\n{\n    nor = abs(nor);\n    float max_comp = max(nor.x, max(nor.y, nor.z));\n    return\n        (max_comp==nor.x) ? 0 : (max_comp==nor.y) ? 1 : 2;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat smoothen(float x)\t\t\t{ return x * x * (3. - 2. * x); }\nvec2  smoothen(vec2 x)  \t\t{ return x * x * (3. - 2. * x); }\nvec3  smoothen(vec3 x)\t\t\t{ return x * x * (3. - 2. * x); }\n\nfloat quintic(float t)\t\t\t{ return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfloat sqr(float x)\t\t\t\t{ return x * x; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat length_squared(vec2 v) \t{ return dot(v, v); }\nfloat length_squared(vec3 v) \t{ return dot(v, v); }\nfloat length_squared(vec4 v) \t{ return dot(v, v); }\n\nvec2 safe_normalize(vec2 v)\t\t{ return all(equal(v, vec2(0))) ? vec2(0) : normalize(v); }\nvec3 safe_normalize(vec3 v)\t\t{ return all(equal(v, vec3(0))) ? vec3(0) : normalize(v); }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat around(float center, float max_dist, float var)\n{\n    return 1. - clamp(abs(var - center)*(1.\/max_dist), 0., 1.);\n}\n\nfloat linear_step(float low, float high, float value)\n{\n    return clamp((value-low)*(1.\/(high-low)), 0., 1.);\n}\n\nfloat triangle_wave(float period, float t)\n{\n    return abs(fract(t*(1.\/period))-.5)*2.;\n}\n\n\/\/ UV distortions \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 skew(vec2 uv, float factor)\n{\n    return vec2(uv.x + uv.y*factor, uv.y);\n}\n\n\/\/ Gamma <-> linear \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat linear_to_gamma(float f)\n{\n#if USE_GAMMA_CORRECTION == 2\n    return sqrt(f);\n#elif USE_GAMMA_CORRECTION == 1\n    return f <= 0.0031308 ? f * 12.92 : (1.055 * pow(f, (1.\/2.4)) - 0.055);\n#else\n    return f;\n#endif\n}\n\nvec3 linear_to_gamma(vec3 c)\n{\n    return vec3(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b));\n}\n\nvec4 linear_to_gamma(vec4 c)\n{\n    return vec4(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b), c.a);\n}\n\nfloat gamma_to_linear(float f)\n{\n#if USE_GAMMA_CORRECTION == 2\n    return f * f;\n#elif USE_GAMMA_CORRECTION == 1\n    return f <= 0.04045 ? f * (1.\/12.92) : pow((f + 0.055) * (1.\/1.055), 2.4);\n#else\n    return f;\n#endif\n}\n\nvec3 gamma_to_linear(vec3 c)\n{\n    return vec3(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b));\n}\n\nvec4 gamma_to_linear(vec4 c)\n{\n    return vec4(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b), c.a);\n}\n\n\/\/ Noise functions \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Dave Hoskins\/Hash without Sine\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\nconst vec4 HASHSCALE = vec4(.1031, .1030, .0973, .1099);\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE.x);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash3(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec3 hash3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 hash3(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE.xyz);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec4 hash4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 hash4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4dS3Wd\n\/\/ By Morgan McGuire @morgan3d, http:\/\/graphicscodex.com\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p)  { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\/\/ 2D Weyl hash #1, by MBR\n\/\/ https:\/\/www.shadertoy.com\/view\/Xdy3Rc\n\/\/ http:\/\/marc-b-reynolds.github.io\/math\/2016\/03\/29\/weyl_hash.html\nfloat weyl_hash(vec2 c)\n{\n    c *= fract(c * vec2(.5545497, .308517));\n    return fract(c.x * c.y);\n}\n\n\/\/ by iq\nvec2 hash2(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define SMOOTH_NOISE_FUNC(p, hash_name)\t\t\t\t\t\t\t\\\n\tvec2 i = floor(p);\t\t\t\t\t\t\t\t\t\t\t\\\n    p -= i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    p *= p * (3. - 2.*p);\t\t\t\t\t\t\t\t\t\t\\\n    float\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    \ts00 = hash_name(i),\t\t\t\t\t\t\t\t\t\t\\\n        s01 = hash_name(i + vec2(1, 0)),\t\t\t\t\t\t\\\n        s10 = hash_name(i + vec2(0, 1)),\t\t\t\t\t\t\\\n        s11 = hash_name(i + vec2(1, 1));\t\t\t\t\t\t\\\n\treturn mix(mix(s00, s01, p.x), mix(s10, s11, p.x), p.y)\t\t\\\n\nfloat smooth_noise(vec2 p)\n{\n    SMOOTH_NOISE_FUNC(p, random);\n}\n\nfloat smooth_weyl_noise(vec2 p)\n{\n    SMOOTH_NOISE_FUNC(p, weyl_hash);\n}\n\nfloat smooth_noise(float f)\n{\n    float i = floor(f);\n    f -= i;\n    f *= f * (3. - 2.*f);\n    return mix(hash(i), hash(i + 1.), f);\n}\n\n#define FBM_FUNC(uv, gain, lacunarity, noise)\t\t\\\n\tfloat accum = noise(uv);\t\t\t\t\t\t\\\n    float octave_weight = gain;\t\t\t\t\t\t\\\n    float total_weight = 1.;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity;\t\t\t\t\t\t\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity; octave_weight *= gain;\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity; octave_weight *= gain;\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return accum \/ total_weight\t\t\t\t\t\t\\\n\nfloat turb(vec2 uv, float gain, float lacunarity)\n{\n    FBM_FUNC(uv, gain, lacunarity, smooth_noise);\n}\n\nfloat weyl_turb(vec2 uv, float gain, float lacunarity)\n{\n    FBM_FUNC(uv, gain, lacunarity, smooth_weyl_noise);\n}\n\nvec4 blue_noise(vec2 fragCoord, sampler2D channel, int frame)\n{\n    ivec2 uv = ivec2(fragCoord) + frame * ivec2(19, 23);\n    return texelFetch(channel, uv & (textureSize(channel, 0) - 1), 0);\n}\n\n#define BLUE_NOISE(fragCoord) blue_noise(fragCoord, NOISE_CHANNEL, iFrame)\n\n\/\/ SDF operations \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_exclude(float from, float what)\n{\n    return max(from, -what);\n}\n\nfloat sdf_union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdf_intersection(float a, float b)\n{\n    return max(a, b);\n}\n\n\/\/ polynomial smooth min\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat sdf_smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/ SDF effects \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_mask(float sdf, float px)\n{\n    return clamp(1. - sdf\/px, 0., 1.);\n}\n\nfloat sdf_mask(float sdf)\n{\n    float px = max(abs(dFdx(sdf)), abs(dFdy(sdf)));\n    return sdf_mask(sdf, px);\n}\n\nvec2 sdf_normal(float sdf)\n{\n    vec2 n = vec2(dFdx(sdf), dFdy(sdf));\n\tfloat sqlen = dot(n, n);\n    return n * ((sqlen > 0.) ? inversesqrt(sqlen) : 1.);\n}\n\nvec2 sdf_emboss(float sdf, float bevel, vec2 light_dir)\n{\n    float mask = sdf_mask(sdf);\n    bevel = clamp(1. + sdf\/bevel, 0., 1.);\n    return vec2(mask * (.5 + sqrt(bevel) * dot(sdf_normal(sdf), light_dir)), mask);\n}\n\n\/\/ SDF generators \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_disk(vec2 uv, vec2 center, float radius)\n{\n    return length(uv - center) - radius;\n}\n\nfloat sdf_ellipse(vec2 uv, vec2 center, vec2 r)\n{\n    return (length((uv-center)\/r) - 1.) \/ min(r.x, r.y);\n}\n\nfloat sdf_centered_box(vec2 uv, vec2 center, vec2 size)\n{\n    return max(abs(uv.x-center.x) - size.x, abs(uv.y-center.y) - size.y);\n}\n\nfloat sdf_box(vec2 uv, vec2 mins, vec2 maxs)\n{\n    return sdf_centered_box(uv, (mins+maxs)*.5, (maxs-mins)*.5);\n}\n\nfloat sdf_line(vec2 uv, vec2 a, vec2 b, float thickness)\n{\n    vec2 ab = b-a;\n    vec2 ap = uv-a;\n    float t = clamp(dot(ap, ab)\/dot(ab, ab), 0., 1.);\n    return length(uv - (ab*t + a)) - thickness*.5;\n}\n\nfloat sdf_seriffed_box(vec2 uv, vec2 origin, vec2 size, vec2 top_serif, vec2 bottom_serif)\n{\n    float h = clamp((uv.y - origin.y) \/ size.y, 0., 1.);\n    float xmul = h < bottom_serif.y ? mix(1.+bottom_serif.x, 1., sqrt(1.-sqr(1.-(h\/bottom_serif.y)))) :\n    \t\th > (1.-top_serif.y) ? 1.+top_serif.x*sqr(1.-(1.-h)\/(top_serif.y)) :\n            1.;\n    return sdf_centered_box(uv, vec2(origin.x, origin.y+size.y*.5), vec2(size.x*xmul*.5, size.y*.5));\n}\n\nfloat sdf_nail(vec2 uv, vec2 top, vec2 size)\n{\n    const float head_flat_frac = .02;\n    const float head_round_frac = .08;\n    const float body_thickness = .5;\n\n    float h = clamp((top.y - uv.y) \/ size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)\/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) \/ (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_Q(vec2 uv)\n{\n    float dist = sdf_disk(uv, vec2(.5, .67), .32);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .735), .27));\n    dist = sdf_union(dist, sdf_nail(uv, vec2(.5, .59), vec2(.09, .52)));\n    return dist;\n}\n\nfloat sdf_id(vec2 uv)\n{\n    float d = .06*sdf_ellipse(uv, vec2(.52, .38), vec2(.26, .28));\n    d = sdf_exclude(d, .02*sdf_ellipse(uv, vec2(.57, .39), vec2(.12, .18)));\n    d = sdf_union(d, sdf_centered_box(uv, vec2(.75, .51), vec2(.09, .30)));\n    d = sdf_union(d, sdf_centered_box(uv, vec2(.80, .80), vec2(.04, .10)));\n    d = sdf_smin(d, sdf_centered_box(uv, vec2(.78, .15), vec2(.12, .05)), .05);\n    d = sdf_smin(d, sdf_centered_box(uv, vec2(.66, .81), vec2(.10, .05)), .05);\n    float i = sdf_centered_box(uv, vec2(.25, .40), vec2(.09, .23));\n    i = sdf_union(i, sdf_disk(uv, vec2(.24, .79), .09));\n    i = sdf_smin(i, sdf_centered_box(uv, vec2(.25, .15), vec2(.15, .05)), .05);\n    i = sdf_smin(i, sdf_centered_box(uv, vec2(.20, .60), vec2(.10, .03)), .05);\n    return sdf_exclude(sdf_union(i, d), sdf_intersection(i, d));\n}\n\nvec2 add_knob(vec2 uv, float px, vec2 center, float radius, vec2 light_dir)\n{\n    float light = dot(normalize(uv-center), light_dir)*.5 + .5;\n    float mask = sdf_mask(sdf_disk(uv, center, radius), px);\n    return vec2(light, mask);\n}\n\nvec3 closest_point_on_segment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap, ab)\/dot(ab, ab), 0., 1.);\n    return ab*t + a;\n}\n\n\/\/ QUAKE text \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_nail_v2(vec2 uv, vec2 top, vec2 size)\n{\n    const float\n        head_flat_frac = .1,\n    \thead_round_frac = .1,\n    \tbody_thickness = .5;\n\n    float h = clamp((top.y - uv.y) \/ size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)\/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) \/ (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_Q_top(vec2 uv)\n{\n    uv.y -= .01;\n    float dist = sdf_disk(uv, vec2(.5, .64), .36);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .74), .29));\n    dist = sdf_union(dist, sdf_nail_v2(uv, vec2(.5, .61), vec2(.125, .57)));\n    dist = sdf_exclude(dist, .95 - uv.y);\n    return dist;\n}\n\nfloat sdf_U(vec2 uv)\n{\n    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.58, .6), vec2(.25, .35), vec2(-.7,.3));\n    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .34), vec2(.3, .58), vec2(-.5, .35), vec2(-.75, .2)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .3), vec2(.04, .15)));\n    return sdf;\n}\n\nfloat sdf_A(vec2 uv)\n{\n    float h = linear_step(.3, .9, uv.y);\n\tfloat sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(mix(.7, .01, h), .6), vec2(0.,.3), vec2(.2,.3));\n    h = linear_step(.1, .65, uv.y);\n\tsdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.45, .1), vec2(mix(.7, .01, h), .55), vec2(0.,.3), vec2(0.,.3)));\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.45, .47), vec2(.18, .02)));\n    return sdf;\n}\n\nfloat sdf_K(vec2 uv)\n{\n\tfloat sdf = sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2));\n\tsdf = sdf_disk(uv, vec2(.17, .17), .5);\n\tsdf = sdf_exclude(sdf, sdf_disk(uv, vec2(.1, -.05), .6));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(-.32, .3), vec2(.4, .8)));\n    sdf = sdf_union(sdf, sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2)));\n\tsdf = sdf_union(sdf, sdf_seriffed_box(skew(uv+vec2(.25,-.3),-1.3), vec2(.1, .3), vec2(mix(.25, .01, linear_step(.5, 1., uv.y)), .3), vec2(0.,.3), vec2(.5,.3)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .1), vec2(.4, .2)));\n    return sdf;\n}\n\nfloat sdf_E(vec2 uv)\n{\n    float sdf_r = sdf_centered_box(uv, vec2(.66, .6), vec2(.1, .3));\n    sdf_r = sdf_exclude(sdf_r, sdf_disk(uv, vec2(.58, .6), .25));\n    sdf_r = sdf_exclude(sdf_r, sdf_centered_box(uv, vec2(.33, .6), vec2(.25, .35)));\n    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.55, .6), vec2(.2, .15), vec2(-.5,.3));\n    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .33), vec2(.3, .57), vec2(-.5, .15), vec2(-.75, .2)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.65, .6), vec2(.2, .35)));\n    sdf = sdf_union(sdf, sdf_r);\n    float t = linear_step(.4, .5, uv.x);\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.4, .6), vec2(.1, mix(.03, .01, t))));\n    return sdf;\n}\n\n\/\/ Time \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float\n    CONSOLE_XFADE_DURATION\t= 1.,\n\tCONSOLE_SLIDE_DURATION\t= .5,\n\tCONSOLE_TYPE_DURATION\t= 2.,\n    WORLD_RENDER_TIME\t\t= CONSOLE_XFADE_DURATION,\n\tINPUT_ACTIVE_TIME\t\t= (CONSOLE_XFADE_DURATION + CONSOLE_SLIDE_DURATION + CONSOLE_TYPE_DURATION),\n    \n    \/\/ TODO: s\/TIME\/DURATION\/\n    LEVEL_COUNTDOWN_TIME\t= 3.,\n    BALLOON_SCALEIN_TIME\t= .5,\n    LEVEL_WARMUP_TIME\t\t= LEVEL_COUNTDOWN_TIME + BALLOON_SCALEIN_TIME,\n    HUD_TARGET_ANIM_TIME\t= .25,\n    \n    THUMBNAIL_MIN_TIME\t\t= 5.\n;\n\nfloat g_time = 0.;\n\nvoid update_time(float bake_time, float uniform_time)\n{\n    if (bake_time > 0.)\n    \tg_time = uniform_time - bake_time;\n    else\n        g_time = -uniform_time;\n}\n\n#define UPDATE_TIME(lighting)\t\tupdate_time(lighting.bake_time, iTime)\n\n\/\/ GBuffer \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int GBUFFER_NORMAL_BITS = 8;\nconst float\n    GBUFFER_NORMAL_SCALE = float(1 << GBUFFER_NORMAL_BITS),\n    GBUFFER_NORMAL_MAX_VALUE = GBUFFER_NORMAL_SCALE - 1.;\n\n\/\/ http:\/\/jcgt.org\/published\/0003\/02\/01\/paper.pdf\nvec2 signNotZero(vec2 v)\n{\n\treturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\n\n\/\/ Assume normalized input. Output is on [-1, 1] for each component.\nvec2 vec3_to_oct(vec3 v)\n{\n\t\/\/ Project the sphere onto the octahedron, and then onto the xy plane\n\tvec2 p = v.xy * (1.0 \/ (abs(v.x) + abs(v.y) + abs(v.z)));\n\t\/\/ Reflect the folds of the lower hemisphere over the diagonals\n\treturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n\nvec3 oct_to_vec3(vec2 e)\n{\n    vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n    if (v.z < 0.0)\n        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n    return normalize(v);\n}\n\nfloat compress(vec2 v, vec2 noise)\n{\n    v = floor(clamp(v, 0., 1.) * GBUFFER_NORMAL_MAX_VALUE + noise);\n    return v.y * GBUFFER_NORMAL_SCALE + v.x;\n}\n\nvec2 uncompress(float f)\n{\n    vec2 v = vec2(mod(f, GBUFFER_NORMAL_SCALE), f \/ GBUFFER_NORMAL_SCALE);\n    return clamp(floor(v) \/ GBUFFER_NORMAL_MAX_VALUE, 0., 1.);\n}\n\nstruct GBuffer\n{\n    vec3\tnormal;\n    float\tz;\n    float\tlight;\n    int\t\tmaterial;\n    int\t\tuv_axis;\n    bool\tedge;\n};\n\nvec4 gbuffer_pack(GBuffer g, vec2 noise)\n{\n    int props =\n        (g.material \t<< 3) |\n        (g.uv_axis \t\t<< 1) |\n        int(g.edge);\n    return vec4(compress(vec3_to_oct(g.normal) * .5 + .5, noise), g.light, g.z, float(props));\n}\n\nGBuffer gbuffer_unpack(vec4 v)\n{\n    int props = int(round(v.w));\n    \n    GBuffer g;\n    g.normal\t= oct_to_vec3(uncompress(v.x) * 2. - 1.);\n    g.light\t\t= v.y;\n    g.z\t\t\t= v.z;\n    g.material\t= props >> 3;\n    g.uv_axis\t= (props >> 1) & 3;\n    g.edge\t\t= (props & 1) != 0;\n    \n    return g;\n}\n\n\/\/ Lightmap encoding \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float LIGHTMAP_OVERBRIGHT = 2.;\n\nstruct LightmapSample\n{\n    vec4 weights;\n    vec4 values;\n};\n\nLightmapSample empty_lightmap_sample()\n{\n    return LightmapSample(vec4(0), vec4(0));\n}\n\nLightmapSample decode_lightmap_sample(vec4 encoded)\n{\n    return LightmapSample(floor(encoded), fract(encoded) * LIGHTMAP_OVERBRIGHT);\n}\n\nvec4 encode(LightmapSample s)\n{\n    return floor(s.weights) + clamp(s.values * (1.\/LIGHTMAP_OVERBRIGHT), 0., 1.-1.\/1024.);\n}\n\n\/\/ Fireball \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec3 FIREBALL_ORIGIN = vec3(864, 992, -168);\n\nstruct Fireball\n{\n    float launch_time;\n    vec3 velocity;\n};\n    \nvoid get_fireball_props(float time, out Fireball props)\n{\n    const float INTERVAL\t= 5.;\n    const float MAX_DELAY\t= 2.;\n    const float BASE_SPEED\t= 600.;\n\n    float interval_start = floor(time*(1.\/INTERVAL)) * INTERVAL;\n    float delay = hash(interval_start) * MAX_DELAY;\n    \n    props.launch_time = interval_start + delay;\n    props.velocity.x = hash(interval_start + .23) * 100. - 50.;\n    props.velocity.y = hash(interval_start + .37) * 100. - 50.;\n    props.velocity.z = hash(interval_start + .71) * 200. + BASE_SPEED;\n}\n\nvec3 get_fireball_offset(float time, Fireball props)\n{\n    float elapsed = max(0., time - props.launch_time);\n\n    vec3 offset = elapsed * props.velocity;\n    offset.z -= GRAVITY * .5 * elapsed * elapsed;\n    offset.z = max(offset.z, 0.);\n    \n    return offset;\n}\n\nvec3 get_fireball_offset(float time)\n{\n    Fireball props;\n    get_fireball_props(time, props);\n    return get_fireball_offset(time, props);\n}\n\nfloat get_landing_time(Fireball props)\n{\n    return props.launch_time + props.velocity.z * (2.\/GRAVITY);\n}\n\n\/\/ Classic (dot) halftoning \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 halftone_point(vec2 fragCoord, float grid_size)\n{\n    const mat2 rot = INV_SQRT2 * mat2(1,1,-1,1);\n    fragCoord = rot * fragCoord;\n    vec2 fc2 = fragCoord * (1.\/grid_size);\n    vec2 nearest = (floor(fc2) + .5) * grid_size;\n    nearest.x += grid_size*.5 * step(.5, fract(fc2.y * .5)) * sign(round(fc2.x)*grid_size - fragCoord.x);\n    return nearest * rot;\n}\n\nfloat halftone(vec2 fragCoord, vec2 center, float grid_size, float fraction)\n{\n    fraction *= grid_size * INV_SQRT2;\n    return step(length_squared(fragCoord - center), sqr(fraction));\n}\n\nfloat halftone_classic(vec2 fragCoord, float grid_size, float fraction)\n{\n    vec2 point = halftone_point(fragCoord, grid_size);\n    return halftone(fragCoord, point, grid_size, fraction);\n}\n\n\/\/ Demo mode \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n\tDEMO_STAGE_NONE\t\t\t= 0,\n\tDEMO_STAGE_DEPTH\t\t= 2,\n\tDEMO_STAGE_NORMALS\t\t= 3,\n\tDEMO_STAGE_UV\t\t\t= -1,\t\/\/ disabled for now\n\tDEMO_STAGE_TEXTURES\t\t= 4,\n\tDEMO_STAGE_LIGHTING\t\t= 5,\n\tDEMO_STAGE_COMPOSITE\t= 6,\n\tDEMO_STAGE_FPS\t\t\t= 7,\n\tDEMO_NUM_STAGES\t\t\t= 9;\n\nint g_demo_stage = DEMO_STAGE_NONE;\nint g_demo_scene = 0;\n\nbool is_demo_mode_enabled(bool thumbnail)\n{\n#if !DEMO_MODE\n    if (!thumbnail)\n        return false;\n#endif \/\/ !DEMO_MODE\n    return true;\n}\n\nbool is_demo_stage_composite(int stage)\n{\n    return uint(stage - DEMO_STAGE_DEPTH) >= uint(DEMO_STAGE_COMPOSITE - DEMO_STAGE_DEPTH);\n}\n\nbool is_demo_stage_composite()\n{\n    return is_demo_stage_composite(g_demo_stage);\n}\n\nvoid update_demo_stage(vec2 fragCoord, vec2 resolution, float downscale, sampler2D noise, int frame, bool thumbnail)\n{\n    float time = g_time;\n\n    if (!is_demo_mode_enabled(thumbnail))\n    {\n\t\tg_demo_stage = DEMO_STAGE_NONE;\n        return;\n    }\n    \n    resolution *= 1.\/downscale;\n    vec2 uv = clamp(fragCoord\/resolution, 0., 1.);\n        \n    const float TRANSITION_WIDTH = .125;\n    const vec2 ADVANCE = vec2(.5, -.125);\n\n    time = max(0., time - INPUT_ACTIVE_TIME);\n    time *= 1.\/DEMO_STAGE_DURATION;\n    time += dot(uv, ADVANCE) - ADVANCE.y;\n\n#if !DEMO_MODE_HALFTONE\n    time += TRANSITION_WIDTH * sqrt(blue_noise(fragCoord, noise, frame).x);\n#else\n    const float HALFTONE_GRID = 8.;\n    float fraction = clamp(1. - (round(time) - time) * (1.\/TRANSITION_WIDTH), 0., 1.);\n    time += TRANSITION_WIDTH * halftone_classic(fragCoord, HALFTONE_GRID, fraction);\n#endif \/\/ !DEMO_MODE_HALFTONE\n\n    g_demo_stage = int(mod(time, float(DEMO_NUM_STAGES)));\n    g_demo_scene = int(time * (1.\/float(DEMO_NUM_STAGES)));\n}\n\t\n#define UPDATE_DEMO_STAGE_EX(fragCoord, downscale, thumbnail)\t\\\n\tupdate_demo_stage(fragCoord, iResolution.xy, downscale, NOISE_CHANNEL, iFrame, thumbnail)\n\n#define UPDATE_DEMO_STAGE(fragCoord, downscale, thumbnail)\t\\\n\tUPDATE_DEMO_STAGE_EX(fragCoord, downscale, thumbnail)\n\nconst struct DemoScene\n{\n    vec3 pos;\n    vec2 angles;\n}\ng_demo_scenes[] = DemoScene[4]\n(\n    DemoScene(vec3(544,272,49),\t\tvec2(0,5)),\n    DemoScene(vec3(992,1406,196),\tvec2(138,-26)),\n    DemoScene(vec3(323,890,-15),\tvec2(35.5,4)),\n    \/\/DemoScene(vec3(1012,453,73),\tvec2(38.25,-8))\n    DemoScene(vec3(1001,514,37),\tvec2(42.3,.2))\n);\n\nDemoScene get_demo_scene()\n{\n    return g_demo_scenes[g_demo_scene % g_demo_scenes.length()];\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat get_viewmodel_offset(vec3 velocity, float bob_cycle, float attack)\n{\n    const float BOB_FRACTION = .003;\n    float speed = length(velocity.xy);\n    float bob = speed * BOB_FRACTION * (.3 + .7 * sin(TAU * bob_cycle));\n    bob = clamp(bob, -.5, 1.);\n    attack = attack * attack * -4.;\n    return bob + attack;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Persistent state \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XsdGDX\n\nfloat is_inside(vec2 fragCoord, vec2 address)\n{\n    vec2 d = abs(fragCoord - (0.5 + address)) - 0.5;\n    return -max(d.x, d.y);\n}\n\n\/\/ changed from original: range is half-open\nfloat is_inside(vec2 fragCoord, vec4 address_range)\n{\n    vec2 d = abs(fragCoord - (address_range.xy + address_range.zw*0.5)) + -0.5*address_range.zw;\n    return -max(d.x, d.y);\n}\n\nvec4 load(vec2 address, sampler2D channel)\n{\n    return texelFetch(channel, ivec2(address), 0);\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, vec2 address, vec4 value)\n{\n    if (is_inside(fragCoord, address) > 0.0) fragColor = value;\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, vec4 address_range, vec4 value)\n{\n    if (is_inside(fragCoord, address_range) > 0.0) fragColor = value;\n}\n\nvoid assign(out float dst,\tfloat src)\t\t{ dst = src; }\nvoid assign(out float dst,\tint src)\t\t{ dst = float(src); }\nvoid assign(out int dst,\tint src)\t\t{ dst = src; }\nvoid assign(out int dst,\tfloat src)\t\t{ dst = int(src); }\nvoid assign(out vec2 dst,\tvec2 src)\t\t{ dst = src; }\nvoid assign(out vec3 dst,\tvec3 src)\t\t{ dst = src; }\n\n\/\/ Serialization codegen macros \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FN_DEFINE_FIELD(pack, field_type, field_name, init)\t\tfield_type field_name;\n#define FN_CLEAR_FIELD(pack, field_type, field_name, init)\t\tassign(data.field_name, init);\n#define FN_LOAD_FIELD(pack, field_type, field_name, init)\t\tassign(data.field_name, v.pack);\n#define FN_STORE_FIELD(pack, field_type, field_name, init)\t\tassign(v.pack, data.field_name);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define DEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\\\n\tstruct type_name\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_DEFINE_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid from_vec4(out type_name data, const vec4 v)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_LOAD_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid to_vec4(out vec4 v, const type_name data)\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        v = vec4(0);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_STORE_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid clear(out type_name data)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_CLEAR_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define DEFINE_STRUCT(type_name, address, field_list)\t\t\t\t\t\t\t\\\n\tDEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\t\\\n    void load(out type_name data, sampler2D channel)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        from_vec4(data, load(address, channel));\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    void store(inout vec4 fragColor, vec2 fragCoord, const type_name data)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        if (is_inside(fragCoord, address) > 0.)\t\t\t\t\t\t\t\t\t\\\n        \tto_vec4(fragColor, data);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define DEFINE_STRUCT_RANGE(type_name, address_range, field_list)\t\t\t\t\\\n\tDEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\t\\\n    void load(vec2 offset, out type_name data, sampler2D channel)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        from_vec4(data, load(address_range.xy + offset, channel));\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    void store(inout vec4 fragColor, vec2 fragCoord, const type_name data)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        if (is_inside(fragCoord, address_range) > 0.)\t\t\t\t\t\t\t\\\n        \tto_vec4(fragColor, data);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define LOAD(what) \t\t\t\tload(what, SETTINGS_CHANNEL)\n#define LOADR(ofs, what)   \t\tload(ofs, what, SETTINGS_CHANNEL)\n#define LOAD_PREV(what)\t\t\tif (iFrame==0) clear(what); else LOAD(what)\n#define LOAD_PREVR(ofs, what)\tif (iFrame==0) clear(what); else LOADR(ofs, what)\n\n\/\/ Persistent state addresses \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \nconst uvec2 LIGHTMAP_SIZE \t\t\t= uvec2(180,256);\n\nconst int\n\tNUM_MAP_AXIAL_BRUSHES           = 88,\n\tNUM_MAP_AXIAL_PLANES            = NUM_MAP_AXIAL_BRUSHES * 6,\n\tNUM_MAP_NONAXIAL_PLANES         = 502,\n\tNUM_MAP_NONAXIAL_BRUSHES        = 89,\n\tNUM_MAP_PLANES                  = NUM_MAP_AXIAL_PLANES + NUM_MAP_NONAXIAL_PLANES,\n\tNUM_MAP_PACKED_BRUSH_OFFSETS    = (NUM_MAP_NONAXIAL_BRUSHES + 3) \/ 4,\n\tNUM_LIGHTS                      = 61,\n\tNUM_LIGHTMAP_SAMPLES            = clamp(LIGHTMAP_AA_SAMPLES, 1, 128),\n\tNUM_LIGHTMAP_POSTPROCESS_STEPS  = 4,\n\tNUM_LIGHTMAP_REGIONS            = 4 \/*RGBA*\/,\n\tNUM_LIGHTMAP_FRAMES             = NUM_LIGHTMAP_SAMPLES * NUM_LIGHTMAP_REGIONS,\n\tNUM_WAIT_FRAMES                 = NUM_LIGHTMAP_FRAMES + NUM_LIGHTMAP_POSTPROCESS_STEPS;\n\nconst int\n    NUM_MAP_COLLISION_BRUSHES\t\t= 28,\n    NUM_MAP_COLLISION_PLANES\t\t= 167;\n\nconst vec2\n\tADDR_POSITION\t\t\t\t\t= vec2(0,0),\n\tADDR_VELOCITY\t\t\t\t\t= vec2(0,1),\t\/\/ W=jump key state\n\tADDR_GROUND_PLANE\t\t\t\t= vec2(0,2),\n\tADDR_CAM_POS\t\t\t\t\t= vec2(1,0),\n\tADDR_TRANSITIONS\t\t\t\t= vec2(1,1),\t\/\/ X=stair step offset; Y=bob phase; Z=attack phase; W=# of shots fired\n\tADDR_CAM_ANGLES\t\t\t\t\t= vec2(1,2),\n    ADDR_ANGLES\t\t\t\t\t\t= vec2(2,0),\t\/\/ X=yaw; Y=pitch; Z=ideal pitch; W=autopitch delay\n\n    ADDR_PREV_MOUSE\t\t\t\t\t= vec2(3,1),\n\tADDR_PREV_CAM_POS\t\t\t\t= vec2(4,0),\n\tADDR_PREV_CAM_ANGLES\t\t\t= vec2(4,1),\n\tADDR_RESOLUTION\t\t\t\t\t= vec2(5,0),\t\/\/ XY=resolution; Z=flags\n\tADDR_ATLAS_INFO\t\t\t\t\t= vec2(5,1),\t\/\/ X=max mip; Y=lod\n\tADDR_PERF_STATS\t\t\t\t\t= vec2(6,0),\t\/\/ X=filtered frame time; W=UI state\n\tADDR_GAME_STATE\t\t\t\t\t= vec2(6,1),\t\/\/ X=level; Y=time left; Z=score; W=last shot #\n\tADDR_LIGHTING\t\t\t\t\t= vec2(6,2),\n\tADDR_TIMING\t\t\t\t\t\t= vec2(7,0),\n    ADDR_MENU\t\t\t\t\t\t= vec2(7,1),\n    ADDR_OPTIONS\t\t\t\t\t= vec2(7,2);\n\nconst vec4\n\tADDR_RANGE_PHYSICS\t\t\t\t= vec4(0,0, 3,3),\n\tADDR_RANGE_PERF_HISTORY\t\t\t= vec4(8,0, 192,1),\n\tADDR_RANGE_SHOTGUN_PELLETS\t\t= vec4(8,1, 24,1),\n    ADDR_RANGE_TARGETS\t\t\t\t= vec4(8,2, NUM_TARGETS+1,1),\t\/\/ X=level; Y=last shot #; Z=hits\n    ADDR_RANGE_LIGHTS\t\t\t\t= vec4(0,3, NUM_LIGHTS,1),\n    ADDR_RANGE_COLLISION_PLANES\t\t= vec4(0,4, NUM_MAP_COLLISION_PLANES,1),\n\tADDR_RANGE_NONAXIAL_PLANES\t\t= vec4(0,8, 128,(NUM_MAP_NONAXIAL_PLANES+127)\/128),\n    ADDR_RANGE_LMAP_TILES\t\t\t= vec4(0,ADDR_RANGE_NONAXIAL_PLANES.y + ADDR_RANGE_NONAXIAL_PLANES.w,\n                                           128, (NUM_MAP_PLANES+127)\/128),\n    ADDR_RANGE_ATLAS_MIP0\t\t\t= vec4(ATLAS_OFFSET, ATLAS_SIZE),\n    ADDR_RANGE_ATLAS_CHAIN\t\t\t= vec4(ATLAS_OFFSET, ATLAS_CHAIN_SIZE),\n\tADDR_RANGE_PARAM_BOUNDS\t\t\t= vec4(0,0, ATLAS_CHAIN_SIZE + ATLAS_OFFSET);\n\n\/\/ Secondary buffer (Buffer C) addresses\nconst vec4\n    ADDR2_RANGE_LIGHTMAP\t\t\t= vec4(0,0,\t\tLIGHTMAP_SIZE.x, LIGHTMAP_SIZE.y \/ 4u),\n    ADDR2_RANGE_TEX_OPTIONS\t\t\t= vec4(0,ADDR2_RANGE_LIGHTMAP.w, 144,24),\n    ADDR2_RANGE_TEX_QUAKE\t\t\t= vec4(0,ADDR2_RANGE_TEX_OPTIONS.y+ADDR2_RANGE_TEX_OPTIONS.w, 144,32),\n    ADDR2_RANGE_FONT\t\t\t\t= vec4(ADDR2_RANGE_TEX_OPTIONS.zy, 64,56),\n    ADDR2_RANGE_PARAM_BOUNDS\t\t= vec4(0,0, \tmax(ADDR2_RANGE_LIGHTMAP.xy + ADDR2_RANGE_LIGHTMAP.zw,\n                                                        max(ADDR2_RANGE_TEX_QUAKE.xy + ADDR2_RANGE_TEX_QUAKE.zw,\n                                                           \tADDR2_RANGE_FONT.xy + ADDR2_RANGE_FONT.zw)));\nconst vec2\n    SKY_TARGET_OFFSET\t\t\t\t= vec2(NUM_TARGETS, 0);\n\nconst int\n    RESOLUTION_FLAG_CHANGED\t\t\t= 1 << 0,\n    RESOLUTION_FLAG_THUMBNAIL\t\t= 1 << 1;\n\n\/\/ Persistent state structs (x-macros) \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define PERF_STATS_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tsmooth_frametime,\t0.)\t\t\\\n\t_(w, float,\tui_state,\t\t\t0.)\nDEFINE_STRUCT(PerfStats, ADDR_PERF_STATS, PERF_STATS_FIELD_LIST)\n\n#define TRANSITIONS_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tstair_step,\t\t0.)\t\t\t\\\n\t_(y, float,\tbob_phase,\t\t0.)\t\t\t\\\n\t_(z, float,\tattack,\t\t\t0.)\t\t\t\\\n\t_(w, float,\tshot_no,\t\t0.)\nDEFINE_STRUCT(Transitions, ADDR_TRANSITIONS, TRANSITIONS_FIELD_LIST)\n\n#define TARGET_FIELD_LIST(_)\t\t\t\t\\\n    _(x, float,\tlevel,\t\t\t0.)\t\t\t\\\n\t_(y, float,\tshot_no,\t\t0.)\t\t\t\\\n\t_(z, float,\thits,\t\t\t0.)\nDEFINE_STRUCT_RANGE(Target, ADDR_RANGE_TARGETS, TARGET_FIELD_LIST)\n        \n#define LIGHTING_FIELD_LIST(_)\t\t\t\t\t\\\n\t_(x, int,\tnum_lights,\t\tNUM_LIGHTS)\t\t\\\n\t_(y, int,\tnum_tiles,\t\tNUM_MAP_PLANES)\t\\\n\t_(z, float, bake_time,\t\t0.)\t\t\t\t\\\n\t_(w, float, progress,\t\t0.)\nDEFINE_STRUCT(Lighting, ADDR_LIGHTING, LIGHTING_FIELD_LIST)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define GAME_STATE_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tlevel,\t\t\t0.)\t\t\t\\\n\t_(y, float,\ttime_left,\t\t0.)\t\t\t\\\n\t_(z, float,\ttargets_left,\t0.)\nDEFINE_STRUCT(GameState, ADDR_GAME_STATE, GAME_STATE_FIELD_LIST)\n\nbool in_progress(GameState game_state) { return game_state.level > 0.; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    OPTION_TYPE_SLIDER\t\t\t\t\t\t= 0,\n    OPTION_TYPE_TOGGLE\t\t\t\t\t\t= 1,\n\n\tOPTION_FLAG_INVERT_MOUSE\t\t\t\t= 1 << 0,\n\tOPTION_FLAG_SHOW_FPS\t\t\t\t\t= 1 << 1,\n\tOPTION_FLAG_SHOW_FPS_GRAPH\t\t\t\t= 1 << 2,\n\tOPTION_FLAG_SHOW_LIGHTMAP\t\t\t\t= 1 << 3,\n\tOPTION_FLAG_SHOW_WEAPON\t\t\t\t\t= 1 << 4,\n\tOPTION_FLAG_NOCLIP\t\t\t\t\t\t= 1 << 5,\n\tOPTION_FLAG_MOTION_BLUR\t\t\t\t\t= 1 << 6,\n\tOPTION_FLAG_TEXTURE_FILTER\t\t\t\t= 1 << 7,\n\tOPTION_FLAG_LIGHT_SHAFTS\t\t\t\t= 1 << 8,\n\tOPTION_FLAG_CRT_EFFECT\t\t\t\t\t= 1 << 9,\n    \n    DEFAULT_OPTION_FLAGS\t\t\t\t\t= OPTION_FLAG_SHOW_WEAPON | OPTION_FLAG_MOTION_BLUR;\n\n#define MENU_STATE_FIELD_LIST(_)\t\t\t\\\n\t_(x, int,\tselected,\t\t0)\t\t\t\\\n\t_(y, int,\topen,\t\t\t0)\nDEFINE_STRUCT(MenuState, ADDR_MENU, MENU_STATE_FIELD_LIST)\n\n#define OPTIONS_FIELD_LIST(_)\t\t\t\t\\\n\t_(x, float, brightness,\t\t5.)\t\t\t\\\n\t_(y, float, screen_size,\t10.)\t\t\\\n\t_(z, float, sensitivity,\t5.)\t\t\t\\\n\t_(w, int,\tflags,\t\t\tDEFAULT_OPTION_FLAGS)\nDEFINE_STRUCT(Options, ADDR_OPTIONS, OPTIONS_FIELD_LIST)\n\nstruct MenuOption { int data; };\nint get_option_type(MenuOption option)\t\t{ return option.data & 1; }\nint get_option_field(MenuOption option)\t\t{ return (option.data >> 1) & 3; }\nint get_option_range(MenuOption option)\t\t{ return option.data >> 3; }\n\n#define MENU_OPTION_SLIDER(index)\t\t\tMenuOption(OPTION_TYPE_SLIDER | ((index) << 1))\n#define MENU_OPTION_TOGGLE(index, bit)\t\tMenuOption(OPTION_TYPE_TOGGLE | ((index) << 1) | ((bit) << 3))\n\nconst MenuOption\n    \/\/ must match Options struct defined above\n\tOPTION_DEF_BRIGHTNESS\t\t\t\t\t= MENU_OPTION_SLIDER(0),\n    OPTION_DEF_SCREEN_SIZE\t\t\t\t\t= MENU_OPTION_SLIDER(1),\n\tOPTION_DEF_SENSITIVITY\t\t\t\t\t= MENU_OPTION_SLIDER(2),\n    OPTION_DEF_INVERT_MOUSE\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_INVERT_MOUSE),\n    OPTION_DEF_SHOW_FPS\t\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_FPS),\n    OPTION_DEF_SHOW_FPS_GRAPH\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_FPS_GRAPH),\n    OPTION_DEF_MOTION_BLUR\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_MOTION_BLUR),\n    OPTION_DEF_TEXTURE_FILTER\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_TEXTURE_FILTER),\n    OPTION_DEF_SHOW_LIGHTMAP\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_LIGHTMAP),\n    OPTION_DEF_SHOW_WEAPON\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_WEAPON),\n    OPTION_DEF_NOCLIP\t\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_NOCLIP),\n    OPTION_DEF_LIGHT_SHAFTS\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_LIGHT_SHAFTS),\n    OPTION_DEF_CRT_EFFECT\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_CRT_EFFECT),\n\n    \/\/ must match string table used in draw_menu (Image tab)\n\tOPTION_DEFS[] = MenuOption[]\n\t(\n        OPTION_DEF_SENSITIVITY,\n        OPTION_DEF_INVERT_MOUSE,\n        OPTION_DEF_BRIGHTNESS,\n        OPTION_DEF_SCREEN_SIZE,\n        OPTION_DEF_SHOW_FPS,\n        OPTION_DEF_SHOW_FPS_GRAPH,\n        OPTION_DEF_TEXTURE_FILTER,\n        OPTION_DEF_MOTION_BLUR,\n        OPTION_DEF_LIGHT_SHAFTS,\n        OPTION_DEF_CRT_EFFECT,\n        OPTION_DEF_SHOW_LIGHTMAP,\n        OPTION_DEF_SHOW_WEAPON,\n        OPTION_DEF_NOCLIP\n\t)\n;\n\nconst int NUM_OPTIONS\t\t\t\t\t\t= OPTION_DEFS.length();\nMenuOption get_option(int index)\t\t\t{ return OPTION_DEFS[index]; }\n\nfloat get_downscale(Options options)\t\t{ return max(6. - options.screen_size * .5, 1.); }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    TIMING_FLAG_PAUSED\t\t\t\t\t\t= 1 << 0;\n\n#define TIMING_FIELD_LIST(_)\t\t\t\t\\\n    _(x, float,\tanim,\t\t\t0.)\t\t\t\\\n\t_(y, float,\tprev,\t\t\t0.)\t\t\t\\\n\t_(z, int,\tflags,\t\t\t0)\nDEFINE_STRUCT(Timing, ADDR_TIMING, TIMING_FIELD_LIST)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 load_camera_pos(sampler2D settings, bool thumbnail)\n{\n    if (!is_demo_mode_enabled(thumbnail))\n        return load(ADDR_CAM_POS, settings);\n    return vec4(get_demo_scene().pos, 0);\n}\n\nvec4 load_camera_angles(sampler2D settings, bool thumbnail)\n{\n    if (!is_demo_mode_enabled(thumbnail))\n        return load(ADDR_CAM_ANGLES, settings);\n    return vec4(get_demo_scene().angles, 0, 0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Buffer A: persistent state handling\n\/\/ - procedural texture generation\n\/\/ - mipmap generation\n\/\/ - player input\/physics\n\/\/ - partial map data serialization\n\/\/ - perf stats\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ config.cfg \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define INVERT_MOUSE\t\t\t0\n#define NOCLIP\t\t\t\t\t0\n\n#define MOVE_FORWARD_KEY1\t\tKEY_W\n#define MOVE_FORWARD_KEY2\t\tKEY_UP\n#define MOVE_FORWARD_KEY3\t\tKEY_Z\t\t\t\/\/ azerty\n#define MOVE_LEFT_KEY1\t\t\tKEY_A\n#define MOVE_LEFT_KEY2\t\t\tKEY_Q\t\t\t\/\/ azerty\n#define MOVE_BACKWARD_KEY1\t\tKEY_S\n#define MOVE_BACKWARD_KEY2\t\tKEY_DOWN\n#define MOVE_RIGHT_KEY1\t\t\tKEY_D\n#define MOVE_RIGHT_KEY2\t\t\tunassigned\n#define MOVE_UP_KEY1\t\t\tKEY_SPACE\n#define MOVE_UP_KEY2\t\t\tunassigned\n#define MOVE_DOWN_KEY1\t\t\tKEY_C\n#define MOVE_DOWN_KEY2\t\t\tunassigned\n#define RUN_KEY1\t\t\t\tKEY_SHIFT\n#define RUN_KEY2\t\t\t\tunassigned\n#define LOOK_LEFT_KEY1\t\t\tKEY_LEFT\n#define LOOK_LEFT_KEY2\t\t\tunassigned\n#define LOOK_RIGHT_KEY1\t\t\tKEY_RIGHT\n#define LOOK_RIGHT_KEY2\t\t\tunassigned\n#define LOOK_UP_KEY1\t\t\tKEY_PGDN\n#define LOOK_UP_KEY2\t\t\tunassigned\n#define LOOK_DOWN_KEY1\t\t\tKEY_DELETE\n#define LOOK_DOWN_KEY2\t\t\tunassigned\n#define CENTER_VIEW_KEY1\t\tKEY_END\n#define CENTER_VIEW_KEY2\t\tunassigned\n#define STRAFE_KEY1\t\t\t\tKEY_ALT\n#define STRAFE_KEY2\t\t\t\tunassigned\n#define RESPAWN_KEY1\t\t\tKEY_BKSP\n#define RESPAWN_KEY2\t\t\tKEY_HOME\n#define ATTACK_KEY1\t\t\t\tKEY_E\n#define ATTACK_KEY2\t\t\t\tKEY_F\n\n#define MENU_KEY1\t\t\t\tKEY_ESC\n#define MENU_KEY2\t\t\t\tKEY_TAB\n\n#define SHOW_PERF_STATS_KEY\t\tKEY_P\n#define TOGGLE_TEX_FILTER_KEY\tKEY_T\n#define TOGGLE_LIGHT_SHAFTS_KEY\tKEY_L\n#define TOGGLE_CRT_EFFECT_KEY\tKEY_V\n\nconst float\n\tSENSITIVITY\t\t\t\t\t= 1.0,\n\tMOUSE_FILTER\t\t\t\t= 0.0,\t\t\/\/ mostly for video recording\n\tTURN_SPEED\t\t\t\t\t= 180.0,\t\/\/ keyboard turning rate, in degrees per second\n\tWALK_SPEED\t\t\t\t\t= 400.0,\n\tJUMP_SPEED\t\t\t\t\t= 270.0,\n    STAIR_CLIMB_SPEED\t\t\t= 128.0,\n    STOP_SPEED\t\t\t\t\t= 100.0,\n    \n    GROUND_ACCELERATION\t\t\t= 10.0,\n    AIR_ACCELERATION\t\t\t= 1.0,\n\n    GROUND_FRICTION\t\t\t\t= 4.0,\n\tNOCLIP_START_FRICTION\t\t= 18.0,\n\tNOCLIP_STOP_FRICTION\t\t= 12.0,\n\n    ROLL_ANGLE\t\t\t\t\t= 2.0,\t\t\/\/ maximum roll angle when moving sideways\n\tROLL_SPEED\t\t\t\t\t= 200.0,\t\/\/ sideways speed at which the roll angle reaches its maximum\n\tBOB_CYCLE\t\t\t\t\t= 0.6,\t\t\/\/ seconds\n\tBOB_SCALE\t\t\t\t\t= 0.02,\n\n    AUTOPITCH_DELAY\t\t\t\t= 2.0,\t\t\/\/ seconds between last mouse look and automatic pitch adjustment\n    STAIRS_PITCH\t\t\t\t= 10.0,\n\n    RECOIL_ANGLE\t\t\t\t= 2.0,\n    WEAPON_SPREAD\t\t\t\t= 0.05,\t\t\/\/ slightly higher than in Quake, for dramatic effect\n    RATE_OF_FIRE\t\t\t\t= 2.0;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/#define GENERATE_TEXTURES\t\t(1<<MATERIAL_WIZMET1_1) | (1<<MATERIAL_WBRICK1_5)\n#define GENERATE_TEXTURES\t\t-1\n#define ALWAYS_REFRESH\t\t\t0\n#define WRITE_MAP_DATA\t\t\t1\n#define ENABLE_MENU\t\t\t\t1\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n\n    \/\/ firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n    KEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\t\n\tunassigned\t\t= 0;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat is_key_down(int code)\t\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 0), 0).r : 0.; }\nfloat is_key_pressed(int code)\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 1), 0).r : 0.; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat cmd(int code1, int code2)\t\t\t{ return max(is_key_down(code1), is_key_down(code2)); }\nfloat cmd(int c1, int c2, int c3)\t\t{ return max(is_key_down(c1), max(is_key_down(c2), is_key_down(c3))); }\nfloat cmd_press(int code1, int code2)\t{ return max(is_key_pressed(code1), is_key_pressed(code2)); }\n\nfloat cmd_move_forward()\t\t\t\t{ return cmd(MOVE_FORWARD_KEY1,\t\tMOVE_FORWARD_KEY2,\t\tMOVE_FORWARD_KEY3); }\nfloat cmd_move_backward()\t\t\t\t{ return cmd(MOVE_BACKWARD_KEY1,\tMOVE_BACKWARD_KEY2); }\nfloat cmd_move_left()\t\t\t\t\t{ return cmd(MOVE_LEFT_KEY1,\t\tMOVE_LEFT_KEY2); }\nfloat cmd_move_right()\t\t\t\t\t{ return cmd(MOVE_RIGHT_KEY1,\t\tMOVE_RIGHT_KEY2); }\nfloat cmd_move_up()\t\t\t\t\t\t{ return cmd(MOVE_UP_KEY1,\t\t\tMOVE_UP_KEY2); }\nfloat cmd_move_down()\t\t\t\t\t{ return cmd(MOVE_DOWN_KEY1,\t\tMOVE_DOWN_KEY2); }\nfloat cmd_run()\t\t\t\t\t\t\t{ return cmd(RUN_KEY1,\t\t\t\tRUN_KEY2); }\nfloat cmd_look_left()\t\t\t\t\t{ return cmd(LOOK_LEFT_KEY1,\t\tLOOK_LEFT_KEY2); }\nfloat cmd_look_right()\t\t\t\t\t{ return cmd(LOOK_RIGHT_KEY1,\t\tLOOK_RIGHT_KEY2); }\nfloat cmd_look_up()\t\t\t\t\t\t{ return cmd(LOOK_UP_KEY1,\t\t\tLOOK_UP_KEY2); }\nfloat cmd_look_down()\t\t\t\t\t{ return cmd(LOOK_DOWN_KEY1,\t\tLOOK_DOWN_KEY2); }\nfloat cmd_center_view()\t\t\t\t\t{ return cmd(CENTER_VIEW_KEY1,\t\tCENTER_VIEW_KEY2); }\nfloat cmd_strafe()\t\t\t\t\t\t{ return cmd(STRAFE_KEY1,\t\t\tSTRAFE_KEY2); }\nfloat cmd_respawn()\t\t\t\t\t\t{ return cmd_press(RESPAWN_KEY1,\tRESPAWN_KEY2); }\nfloat cmd_attack()\t\t\t\t\t\t{ return cmd(ATTACK_KEY1,\t\t\tATTACK_KEY2); }\nfloat cmd_menu()\t\t\t\t\t\t{ return cmd_press(MENU_KEY1,\t\tMENU_KEY2); }\n\nfloat is_input_enabled()\t\t\t\t{ return step(INPUT_ACTIVE_TIME, g_time); }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SETTINGS_CHANNEL iChannel1\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ World data\n\/\/\n\/\/ Generated from a trimmed\/tweaked version of\n\/\/ the original map by John Romero\n\/\/ https:\/\/rome.ro\/news\/2016\/2\/14\/quake-map-sources-released\n\/\/\n\/\/ Split between Buffer A and B to even out compilation time\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float H0=0.707107,H1=0.992278,H2=0.124035,H3=0.83205,H4=0.5547,H5=0.948683,H6=0.316228,H7=0.894427,\nH8=0.447214,H9=0.863779,H10=0.503871,H11=0.913812,H12=0.406138,H13=0.970143,H14=0.242536;\n\n#define V(x,y,z,w) vec4(x,y,z,w),\n#define D(w) V( 1,0,0,float(w)*16.+-1040.)\n#define G(w) V(-1,0,0,float(w)*16.+48.)\n#define E(w) V(0, 1,0,float(w)*16.+-1424.)\n#define H(w) V(0,-1,0,float(w)*16.+176.)\n#define F(w) V(0,0, 1,float(w)*16.+-336.)\n#define I(w) V(0,0,-1,float(w)*16.+-192.)\n#define X(v0,v1) D(v0)G(v1)\n#define Y(v0,v1) E(v0)H(v1)\n#define Z(v0,v1) F(v0)I(v1)\n\nWRAP(Planes,planes,vec4,NUM_MAP_NONAXIAL_PLANES+1)(X(6.5,53.5)Y(55,21)V(.6,0,-.8,-574.4)V(-.6,0,.8,561.6)X(1.5,58.5)Y(55,21)V(.6\n,0,.8,-590.4)V(-.6,0,-.8,577.6)Z(20,10)V(H0,H0,0,-1052.17)V(H0,-H0,0,-305.47)V(H3,0,H4,-781.018)V(-H3,0,-H4,767.705)Z(20,10)V(H3\n,0,-H4,-829.832)V(-H0,H0,0,305.47)V(-H0,-H0,0,1052.17)V(-H3,0,H4,816.519)Z(20,10)V(H0,-H0,0,-305.47)V(-H0,-H0,0,1052.17)V(0,H3,\n-H4,-470.386)V(0,-H3,H4,457.073)Z(20,10)V(H0,H0,0,-1052.17)V(-H0,H0,0,305.47)V(0,H3,H4,-421.572)V(0,-H3,-H4,408.259)X(56,4)Y(\n57.5,18.5)V(0,.6,-.8,-315.2)V(0,-.6,.8,302.4)X(56,4)Y(52.5,23.5)V(0,.6,.8,-331.2)V(0,-.6,-.8,318.4)X(58.5,1.5)Y(55,21)V(.6,0,-.8\n,-75.2)V(-.6,0,.8,62.4)X(53.5,6.5)Y(55,21)V(.6,0,.8,-91.2)V(-.6,0,-.8,78.4)Z(20,10)V(H0,H0,0,-463.862)V(H0,-H0,0,282.843)V(H3,0,\nH4,-88.752)V(-H3,0,-H4,75.4392)Z(20,10)V(H0,-H0,0,282.843)V(-H0,-H0,0,463.862)V(0,H3,-H4,-470.386)V(0,-H3,H4,457.073)Z(20,10)V(\nH3,0,-H4,-137.566)V(-H0,H0,0,-282.843)V(-H0,-H0,0,463.862)V(-H3,0,H4,124.253)X(4,56)Y(57.5,18.5)V(0,.6,-.8,-315.2)V(0,-.6,.8,\n302.4)Z(20,10)V(H0,H0,0,-463.862)V(-H0,H0,0,-282.843)V(0,H3,H4,-421.572)V(0,-H3,-H4,408.259)X(4,56)Y(52.5,23.5)V(0,.6,.8,-331.2)\nV(0,-.6,-.8,318.4)Y(59,12)Z(22,10)V(H0,H0,0,-837.214)V(-H0,H0,0,-67.8823)Y(55,12)Z(24,8)V(H0,H0,0,-927.724)V(-H0,H0,0,-158.392)Y\n(63,12)Z(21,11)V(H0,H0,0,-791.96)V(-H0,H0,0,-22.6274)Y(57,12)Z(23,9)V(H0,H0,0,-882.469)V(-H0,H0,0,-113.137)X(1,49)Y(63,13)F(2)V(\n-H10,0,-H9,667.989)X(49,1)Y(63,13)F(2)V(H10,0,-H9,119.777)X(30,30)Y(65,1)F(2)V(0,H10,-H9,55.2819)X(46,14)Y(65,1)F(2)V(0,H10,-H9,\n55.2819)X(14,46)Y(65,1)F(2)V(0,H10,-H9,55.2819)X(14.5,14.5)Y(75.5,1)V(0,H6,H5,-189.737)V(0,H6,-H5,22.7684)X(1,59.5)Z(7.5,8)V(-H6\n,H5,0,-78.4245)V(-H6,-H5,0,680.522)Y(75.5,1)Z(7.5,12)V(H5,H6,0,-333.936)V(-H5,H6,0,166.968)X(59.5,1)Z(7.5,8)V(H6,H5,0,-422.48)V(\nH6,-H5,0,336.466)Y(75.5,1)Z(7.5,12)V(H5,H6,0,-865.199)V(-H5,H6,0,698.231)D(14)H(14)Z(1,30)V(-H0,H0,0,271.529)G(14)H(14)Z(1,30)V(\nH0,H0,0,-497.803)G(1)H(1)Z(5,8)V(H0,H0,0,-316.784)D(1)H(1)Z(5,8)V(-H0,H0,0,452.548)X(7,7)H(1)F(2)V(0,H10,-H9,69.1023)X(49,1)Y(47\n,29)F(2)V(H10,0,-H9,119.777)X(59.5,1)Y(49,15)V(H6,0,H5,-149.259)V(H6,0,-H5,63.2456)X(59.5,1)Z(7.5,8)V(H6,H5,0,-665.343)V(H6,-H5,\n0,579.329)G(1)Y(41,7)F(2)V(H10,0,-H9,133.598)X(1,49)Y(47,29)F(2)V(-H10,0,-H9,667.989)X(1,59.5)Y(49,15)V(-H6,0,H5,194.796)V(-H6,0\n,-H5,407.301)X(1,59.5)Z(7.5,8)V(-H6,H5,0,-321.287)V(-H6,-H5,0,923.385)D(1)Y(41,7)F(2)V(-H10,0,-H9,681.809)Y(33,41)Z(24.5,7.5)V(\nH7,H8,0,-1230.73)V(-H7,H8,0,314.838)X(46,15)H(37)Z(25,7)V(H7,H8,0,-658.298)X(42,19)H(37)Z(25,7)V(H8,H7,0,-887.272)H(37)Z(26,1)V(\nH0,H0,0,-848.528)V(-H0,H0,0,-294.156)H(37)Z(26,1)V(H0,H0,0,-1063.49)V(-H0,H0,0,-79.196)G(7)H(37)Z(26,1)V(H0,H0,0,-678.823)D(2)H(\n37)Z(26,1)V(-H0,H0,0,147.078)X(3,42)Y(37,37)Z(25,7)V(-H8,H7,0,-400.703)X(23,36)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118\n)X(36,23)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118)X(27,27)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118)E(21)Z(24,8\n)V(H7,-H8,0,-343.46)V(-H4,-H3,0,1402.28)H(45)Z(24.5,7.5)V(.8,.6,0,-1280)V(-H4,H3,0,-257.381)H(45)Z(24.5,7.5)V(H7,H8,0,-1187.8)V(\n-H0,H0,0,-45.2549)E(21)Z(24,8)V(H0,-H0,0,135.764)V(-H7,-H8,0,1245.04)H(45)Z(24.5,7.5)V(H4,H3,0,-1207.03)V(-H7,H8,0,314.838)E(21)\nZ(24,8)V(H4,-H3,0,434.885)V(-.8,-.6,0,1292.8)Y(17,57)Z(24,8)V(H7,-H8,0,-343.46)V(-H7,-H8,0,1202.11)D(22)E(12)Z(24,1)V(-H0,-H0,0,\n1335.02)X(2,2)Y(1,65)Z(23,9)V(-.524097,-.851658,0,1186.56)G(41)E(12)Z(25,1)V(H0,-H0,0,350.725)D(2)E(12)Z(25,1)V(-H0,-H0,0,\n1561.29)Y(37,37)Z(5,24)V(.8,0,-.6,-217.6)V(-.8,0,-.6,409.6)X(51,2)Y(25,51)F(2)V(H12,0,-H11,172.203)X(22,31)Y(25,51)F(2)V(-H12,0,\n-H11,484.117)Y(8,66)Z(5,24)V(.8,0,-.6,-217.6)V(-.8,0,-.6,409.6)Y(12,41)Z(2,27)V(H12,0,-H11,56.8594)V(-H12,0,-H11,368.774)X(31,11\n)Y(25,51)Z(2,26)V(H12,0,-H11,42.2384)V(-H12,0,-H11,354.153)G(3)Y(37,37)F(5)V(.501036,0,-.865426,106.812)G(3)Y(8,66)F(5)V(.501036\n,0,-.865426,106.812)X(22,2)E(1)F(2.5)V(0,-.393919,-.919145,782.586)D(22)Y(12,41)F(2)V(-H12,0,-H11,498.738)G(2)Y(12,41)F(2)V(H12,\n0,-H11,186.824)Y(37,37)Z(5,24)V(.8,0,-.6,-460.8)V(-.8,0,-.6,652.8)D(2)V(-H2,H1,0,-1002.2)V(-H2,-H1,0,1220.5)V(-H2,0,H1,-128.996)\nV(-H2,0,-H1,347.297)G(41)V(H2,H1,0,-992.278)V(H2,-H1,0,785.884)V(H2,0,H1,-254.023)V(H2,0,-H1,47.6293)D(2)V(-H2,H1,0,-811.683)V(\n-H2,-H1,0,1029.98)V(-H2,0,H1,-41.6757)V(-H2,0,-H1,259.977)D(2)V(-H2,H1,0,-875.189)V(-H2,-H1,0,1093.49)V(-H2,0,H1,-128.996)V(-H2,\n0,-H1,347.297)G(41)V(H2,H1,0,-1151.04)V(H2,-H1,0,944.649)V(H2,0,H1,-341.344)V(H2,0,-H1,134.95)D(3)Y(37,37)F(5)V(-.501036,0,\n-.865426,651.939)Y(8,66)Z(5,24)V(.8,0,-.6,-460.8)V(-.8,0,-.6,652.8)G(41)V(H2,H1,0,-1278.05)V(H2,-H1,0,1071.66)V(H2,0,H1,-341.344\n)V(H2,0,-H1,134.95)E(1)V(H1,-H2,0,-591.398)V(-H1,-H2,0,916.865)V(0,-H2,H1,-75.4131)V(0,-H2,-H1,400.88)E(1)V(H1,-H2,0,-797.791)V(\n-H1,-H2,0,1123.26)V(0,-H2,H1,-75.4131)V(0,-H2,-H1,400.88)E(1)V(H1,-H2,0,-694.594)V(-H1,-H2,0,1020.06)V(0,-H2,H1,-51.5984)V(0,-H2\n,-H1,377.066)D(3)Y(8,66)F(5)V(-.501036,0,-.865426,651.939)vec4(0)));\n\n#define L(x,y,z) vec4(x,y,z,300),\n#define LR(x,y,z,r) vec4(x,y,z,r),\n\nWRAP(Lights,lights,vec4,NUM_LIGHTS+1)(LR(224,880,248,200)LR(224,1008,248,200)LR(224,1136,248,200)L(88,1024,64)L(362,1034,20)L(\n200,712,120)LR(128,624,-32,220)LR(128,528,-48,220)L(126,526,12)LR(128,432,-32,220)LR(224,528,-32,220)L(224,352,120)L(864,352,120\n)L(544,312,104)LR(544,496,40,250)LR(544,584,424,500)LR(960,432,-32,220)LR(864,528,-32,220)LR(960,624,-32,220)L(958,526,12)L(394,\n762,84)LR(544,864,-8,200)L(698,762,84)LR(960,528,-48,220)LR(408,928,96,120)LR(680,1056,96,120)L(544,1016,72)LR(544,1136,248,200)\nLR(544,880,248,200)L(336,1152,-144)L(336,1024,-144)L(336,896,-144)LR(448,1152,-56,120)LR(480,1032,-152,200)LR(488,840,-152,200)\nLR(600,840,-152,200)LR(608,1032,-152,200)LR(608,1120,-152,200)LR(544,1192,-152,200)L(728,1080,-144)L(984,1080,-144)L(984,904,-\n144)L(728,904,-144)LR(864,888,-32,120)LR(720,992,64,120)LR(864,1112,-24,150)LR(992,928,64,120)LR(992,1056,128,120)L(976,928,312)\nL(976,1056,312)LR(976,1184,312,200)L(736,992,312)L(736,1120,312)LR(736,864,312,200)LR(720,1120,128,120)L(912,1360,296)L(808,1360\n,296)L(888,712,120)L(864,1336,48)L(544,1336,48)LR(232,1336,48,350)vec4(0)));\n\n\/\/ Lightmap layout \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define O2 0,0\n#define O4 O2,O2\n\nWRAP(LightmapTiles,LIGHTMAP_TILES,int,NUM_MAP_PLANES)(O2,0x8f4187a,0,1725<<18,0,68020022,32849,16467,85,51243860,0,114779,0,\n28927,68013914,53467,O2,119,201,827,51242336,0,68024118,49153,81923,65541,64795,0,114699,0,12351,68020528,51246926,O2,16391,\n98313,114699,57403,O2,68010330,113,147,51246920,0,201,0,877,99231,57403,0,57006602,28673,0,50935528,420042758,913857,122891,\n118797,0,487963,159755,107069,O2,59542636,474001,42751174,3665,291297534,O4,O2,381,O4,O2,0xd84711e,O2,0,34466650,45217,39113892,\n0,55904432,O2,0,99887226,0,0xcf4007a,O2,0,34972748,0,85321998,O2,54855936,51493674,134753,286368892,200817,553,0,190651,186557,\n200891,77837,0x70dd504,147585,0x7159d04,O4,54855970,52793124,433,287679594,77825,0x81da4ee,98305,0,0x815b4ee,O4,0,38851790,\n0x6510f26,3969,0x774d80a,O4,O4,0,517494784,0,0xe141956,749457,O2,84778338,0,0x70dc704,O2,0x729d8ae,O4,0,0x96d520a,O2,51753790,O2\n,0,84474618,0,0xa0d515c,376049,0xa1de6ae,373553,O2,376587,401181,373707,21725,O4,0x72570dc,O4,0,38089418,0,88420998,369,41455390\n,8193,O2,504403290,65,186539,O2,0,507024694,353,O2,0,0x955ec0a,O2,0xe1558a4,204801,O2,84515926,O4,O4,O4,O4,O4,0,38589724,3921,0,\n88942328,404082688,246305,403757192,321,O4,38589762,978113,88942290,O2,555013120,554505728,159745,84724578,O2,0,0x6510e86,321,\n89201366,321,O2,40971,973,3979,973,404059212,450577,403757208,65,O2,437611574,0,437351492,435169,85046040,O2,0,0x64d2686,337,O2,\n454400512,778609,453809506,O2,0,338548804,0,336163926,O2,0,0x615ab0e,110849,O2,0,84686178,111211,O4,84522180,0x915b4dc,45057,O4,\n540316746,369,537433258,0,0xd09aaaa,0,0xb1592b4,827217,O2,84489060,934497,0xd1590a4,O4,0,0x9157edc,487425,O4,457776138,0xfd001,0\n,453830200,O2,408737882,O2,403284032,O2,0,546608128,O4,539530386,1889,0,537433254,O2,0xf155490,594577,0xf11549a,401505,O2,300891\n,189,78059,401645,O2,336910684,0,336147546,33,O2,0,320167002,319380610,300833,O4,99366124,20481,0,251749,371263578,952497,O4,\n37092458,O2,37277978,0xd39cc86,0,388028716,129,O4,O2,0,34995438,401,277923,O2,0,278219,278109,0,0x909e8e6,437265,0,0x90db2e6,\n34449250,O2,382269,0,465963,391915,O4,35519150,265585,O4,265707,0,262671,0x7094806,O2,0x70dd8c2,O2,0,0x909deaa,0,0x90dd6e6,O2,0,\n0x7098a06,0,0x70de4f6,O4,0,34656594,622673,O4,536651,0,549087,0x90992c4,O2,0x90dc4e6,O4,O4,O4,O4,O4,O2,0,329275598,44060278,O4,\n391174312,O2,0,51242330,68274464,49217,51501628,28673,O2,81995,32845,27515,27581,0x80c3f62,50985632,68286752,16385,68791088,\n69242034,0xfdcab,68017474,0,68528968,171873,109,52787528,51753810,217,85051160,86339822,69047626,520411,51500866,68528988,106683\n,68791076,3965,68272416,O2,51242324,68015932,49889,85056280,0,217,0,50075,50093,O2,68286232,45505,51497294,233633,51243842,0,\n127371,110989,233579,234413,0x70d9d0e,28685,68282656,98305,68530996,0,35519578,34725208,114699,249,69334106,68785496,0x811c4ee,\n68012336,197943,68530976,85311758,85564758,0,68284184,0,51247804,68010318,913,52532492,34989178,85058840,106497,85815642,0xfd001\n,0,180233,51231586,0,68010288,114881,39375992,0,0x990591e,0,35718476,36043976,41717966,0,0xcd400f4,0,36810926,57345,O2,74277898,\n0,34700078,873377,40162374,0,0xbac766c,0,36295880,36459858,O2,0xa353cc8,817,53839534,20481,O2,0x93550ae,225057,950075,282381,O4,\n0xd0daaa4,225281,0xa35e86a,30561,O2,237579,974381,435275,435389,O2,0xd0d92ae,810609,O2,59526924,0,3667,60373,0,319914586,O2,\n319671904,299185,0xf11728e,O2,0,0xf0dae98,201,319894626,O2,0,319642724,299505,0xf11908e,O2,0,0xf0dae9e,193,O2,68024624,115329,\n51493682,O2,51242312,41041,102739,O4,355807850,O4,356059242,O2,0,0xec418f4,0xfc4586c,O2,0x93574ae,45057,53812046,28673,54343370,\nO2,0,0xf0d729e,450657,319924314,O2,0,319642748,457,O2,0,523539686,3889,O2,0xa353d30,305,53813582,450113,0,71119656,O2,0xf0dae8c,\n127121,0,319914594,O2,319642736,209,O2,0,523801774,801,52793160,54342470,0x63d3c86,237569,51753800,52006746,O2,0,0xa09e6a0,69713\n,34726224,O2,0,67724352,304977,34145530,O2,0,0x711b904,192449,O2,0,36873,229323,O4,0x711acfc,O4,192521,O2,37566790,0,88680222,\n737,34973526,0,86339876,O2,0x911c6dc,147921,153,O2,0,90123,61453,O4,0x925d8c8,102401,0,51493706,193,34197568,34726216,0,234473,\n234411,51246914,233583,0,68747612,348705,51497302,65,0,51755808,17377,34700096,340097,0,34471234,57617,51245384,50883428,0,\n51750590,0xfa011,34725216,95,0,35950860,87896842,3889,34995470,175569,O4,0x911a0e6,O2,0,45631724,0xdec3400,945,37278006,O4,\n0x8119cfc,O4,0x80dd4f6,0x6295148,993,O2,0x6159d4c,85309198,O2,0x62db4ae,237569,0,53334702,O2,0x62964c8,161,53042504,306177,455,\n3689,O2,0x6159d24,85314318,O2,442067978,0,439146564,926545,O2,0x654fafe,369,55904390,0,53235538,794593,0,0x6296518,417,0,\n86614216,0,713,619,0,61449,O4,0x99c7ece,O2,0,438897732,155649,O2,0,439197730,439459850,0x62970c8,24577,O2,0x6159d1a,85319438,0,\n69819620,69566254,53042484,52793142,0,295,3769,3659,29501,0,69566272,507905,739,86339858,0,508793,508651,52793088,508511,0,\n69568248,69819640,53071560,3963,0,0x62988c8,57345,0,86616776,442727,442761,O2,0x6159d38,85316878,0,69819660,69568230,355,511395,\n0,52532508,0,0x811d4ee,0x711bafc,O2,395,98313,233481,0,69072110,200337,0x70de304,36865,0,0x629510c,353,0,86619336));\n\n\/\/ Collision map \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#undef D\n#undef E\n#undef F\n#undef G\n#undef H\n#undef I\n\n#define D(w) V( 1,0,0,float(w)*16.+-1040.)\n#define G(w) V(-1,0,0,float(w)*16.+48.)\n#define E(w) V(0, 1,0,float(w)*16.+-1440.)\n#define H(w) V(0,-1,0,float(w)*16.+176.)\n#define F(w) V(0,0, 1,float(w)*16.+-320.)\n#define I(w) V(0,0,-1,float(w)*16.+-192.)\n#define B(x0,y0,z0,x1,y1,z1) D(x0)G(x1)E(y0)H(y1)F(z0)I(z1)\n\nWRAP(CMPlanes,cm_planes,vec4,NUM_MAP_COLLISION_PLANES+1)(B(1,53.5,19,53.5,18.5,8)B(0,2,0,59,0,0)B(59,2,0,0,0,8)B(1,38,24,41,0,0)\nB(28,2,13,28,75,10)B(47.5,2,13,8.5,75,10)B(8,2,13,48,75,10)B(20,2,0,39,37,0)B(3,76.5,0,3,0,8)B(0,0,0,0,77,0)B(3,13,31,42,37,0)B(\n3,67,20,3,2.5,8)B(39,2,0,20,37,0)B(42,2,23,3,65,8)B(21,62,20,21,15,8)B(21,2,24,0,0,0)B(53.5,53.5,19,1,18.5,8)B(2,2,23,41,61,0)D(\n23)G(22)E(14)F(21.5)I(8)V(0,-.242536,.970142,256.118)E(64)H(12)F(20)I(8)V(H0,H0,0,-791.96)V(-H0,H0,0,-22.6274)E(60)H(12)F(21)I(8\n)V(H0,H0,0,-837.214)V(-H0,H0,0,-67.8823)E(58)H(12)F(22)I(8)V(H0,H0,0,-882.469)V(-H0,H0,0,-113.137)E(56)H(12)F(23)I(8)V(H0,H0,0,\n-927.724)V(-H0,H0,0,-158.392)E(32.5)H(41)F(23.5)I(1)V(.910366,.413803,0,-1218.24)V(-.910366,.413803,0,354.877)E(18)H(55.5)F(23)I\n(1)V(.910366,-.413803,0,-397.251)V(-.910366,-.413803,0,1175.86)G(3)H(2.5)F(0)I(12)V(H0,H0,0,-328.098)D(3)H(2.5)F(0)I(12)V(-H0,H0\n,0,441.235)D(3)G(2)E(0)H(65)F(22)I(8)V(-.524097,-.851658,0,1186.56)vec4(0)));\n\n#define S(d,b) b,b+d,b+d*2,b+d*3,\n#define S4(d,b) S(d,b)S(d,b+d*4)S(d,b+d*8)S(d,b+d*12)\n\nWRAP(CMBrushes,cm_brushes,int,NUM_MAP_COLLISION_BRUSHES+1)(S4(6,0)S(6,96)S(6,120)144,150,155,160,167));\n\n\/\/ Map data serialization \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nbool is_inside(vec2 fragCoord, vec4 box, out ivec2 offset)\n{\n    offset = ivec2(floor(fragCoord - box.xy));\n    return all(lessThan(uvec2(offset), uvec2(box.zw)));\n}\n\nvoid write_map_data(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_LIGHTING) > 0.)\n    {\n        Lighting lighting;\n        if (iFrame == 0)\n            clear(lighting);\n        else\n            from_vec4(lighting, fragColor);\n\n        lighting.progress = clamp(min(float(iFrame)\/float(NUM_WAIT_FRAMES), iTime\/LOADING_TIME), 0., 1.);\n        if (lighting.progress >= 1. && lighting.bake_time <= 0.)\n            lighting.bake_time = iTime;\n        \n        to_vec4(fragColor, lighting);\n        return;\n    }\n    \n#if WRITE_MAP_DATA\n    if (iFrame > 0)\n#endif\n        return;\n    \n    ivec2 offset;\n\n    if (is_inside(fragCoord, ADDR_RANGE_NONAXIAL_PLANES, offset))\n    {\n        int index = offset.y * int(ADDR_RANGE_NONAXIAL_PLANES.z) + offset.x;\n        if (uint(index) < uint(NUM_MAP_NONAXIAL_PLANES + 1))\n            fragColor = planes.data[index];\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_LIGHTS, offset))\n    {\n        if (uint(offset.x) < uint(NUM_LIGHTS + 1))\n        \tfragColor = lights.data[offset.x];\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_LMAP_TILES, offset))\n    {\n        int index = offset.y * int(ADDR_RANGE_LMAP_TILES.z) + offset.x;\n        if (uint(index) < uint(NUM_MAP_PLANES))\n        {\n            int tile = LIGHTMAP_TILES.data[index];\n            bool delta_encoded = (tile & 1) != 0;\n            if (delta_encoded)\n            {\n                int offset = (tile >> 1) & 7;\n                tile = (tile >> 3) ^ LIGHTMAP_TILES.data[index - offset - 1];\n            }\n            tile >>= 1;\n            \n            int x = tile & 255,\n                y = (tile >> 8) & 511,\n                w = (tile >> 17) & 63,\n                h = (tile >> 23) & 63;\n            \n            fragColor = vec4(x, y, w, h);\n        }\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_COLLISION_PLANES, offset))\n    {\n        if (uint(offset.x) < uint(NUM_MAP_COLLISION_PLANES + 1))\n        \tfragColor = cm_planes.data[offset.x];\n    }\n}\n\n\n\/\/ Collision detection \/ response \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 get_collision_plane(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_COLLISION_PLANES.xy);\n    addr.x += index;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nfloat get_player_radius(vec3 direction)\n{\n    const float HORIZONTAL_RADIUS = 16., VERTICAL_RADIUS = 48.;\n\n    direction = abs(direction);\n    return direction.z > max(direction.x, direction.y) ? VERTICAL_RADIUS : HORIZONTAL_RADIUS;\n}\n\nfloat get_player_distance(vec3 position, vec4 plane)\n{\n    return dot(position, plane.xyz) + plane.w - get_player_radius(plane.xyz);\n}\n\nbool is_touching_ground(vec3 position, vec4 ground)\n{\n    return ground.z > 0. && abs(get_player_distance(position, ground)) < 1.;\n}\n\nbool is_valid_ground(vec3 position, vec4 ground)\n{\n    return ground.z > 0. && get_player_distance(position, ground) > -1.;\n}\n\nvoid find_collision(inout vec3 start, inout vec3 delta, out int hit_plane, out float step_height)\n{\n    const float STEP_SIZE = 18.;\n\n    \/\/ We iterate through all the collision brushes, tracking the closest plane the ray hits and the top plane\n    \/\/ of the colliding brush.\n    \/\/ If, at the end of the loop, the closest hit plane is vertical and the corresponding top plane\n    \/\/ is within stepping distance, we move the start position up by the height difference, update the stepping\n    \/\/ offset for smooth camera interpolation and defer all forward movement to the next step (handle_collision).\n    \/\/ If we're not stepping up then we move forward as much as possible, discard the remaining forward movement\n    \/\/ blocked by the colliding plane and pass along what's left (wall sliding) to the next phase.\n    \n    step_height = 0.;\n    hit_plane = -1;\n    float travel_dist = 1.;\n    int ground_plane = -1;\n    float ground_dist = 0.;\n    float eps = 1.\/(length(delta) + 1e-6);\n    vec3 dir = normalize(delta);\n\n    int num_brushes = NO_UNROLL(NUM_MAP_COLLISION_BRUSHES);\n    for (int i=0; i<num_brushes; ++i)\n    {\n        int first_plane = cm_brushes.data[i];\n        int last_plane = cm_brushes.data[i + 1];\n        int plane_enter = -1;\n        int brush_ground_plane = -1;\n        float brush_ground_dist = 1e+6;\n        float t_enter = -1e+6;\n        float t_leave = 1e+6;\n        for (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_collision_plane(j);\n            float dist = get_player_distance(start, plane);\n            \n            \/\/ Note: top plane detection only takes into account fully horizontal planes.\n            \/\/ This means that stair stepping won't work with brushes that have an angled top surface, \n            \/\/ such as the ramp in the 'Normal' hallway. If you stop on the ramp and let gravity slide\n            \/\/ you down you'll notice the sliding continues for a bit after the ramp ends - the collision\n            \/\/ map doesn't fully match the rendered geometry (and now you know why).\n            \n            if (abs(dir.z) < .7 && plane.z > .99 && brush_ground_dist > dist)\n            {\n                brush_ground_dist = dist;\n                brush_ground_plane = j;\n            }\n            float align = dot(plane.xyz, delta);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                {\n                    t_enter = 2.;\n                    break;\n                }\n                continue;\n            }\n            align = -1.\/align;\n            dist *= align;\n            if (align > 0.)\n            {\n                if (t_enter < dist)\n                {\n                    plane_enter = j;\n                    t_enter = dist;\n                }\n            }\n            else\n            {\n                t_leave = min(t_leave, dist);\n            }\n\n            if (t_leave <= t_enter)\n                break;\n        }\n\n        if (t_leave > max(t_enter, 0.) && t_enter > -eps)\n        {\n            if (t_enter <= travel_dist)\n            {\n                if (brush_ground_plane != -1 && -brush_ground_dist > ground_dist)\n                {\n                    ground_plane = brush_ground_plane;\n                    ground_dist = -brush_ground_dist;\n                }\n                hit_plane = plane_enter;\n                travel_dist = t_enter;\n            }\n        }\n    }\n\n    vec4 plane;\n    bool blocked = hit_plane != -1;\n    if (blocked)\n    {\n        plane = get_collision_plane(hit_plane);\n        if (abs(plane.z) < .7 && ground_plane != -1 && ground_dist > 0. && ground_dist <= STEP_SIZE)\n        {\n            ground_dist += .05;\t\/\/ fixes occasional stair stepping stutter at low FPS\n            step_height = ground_dist;\n            start.z += ground_dist;\n            return; \/\/ defer forward movement to next step\n        }\n    }\n\n    start += delta * clamp(travel_dist, 0., 1.);\n    delta *= 1. - clamp(travel_dist, 0., 1.);\n\n    if (blocked)\n    {\n        start += 1e-2 * plane.xyz;\n        delta -= dot(plane.xyz, delta) * plane.xyz;\n    }\n}\n\n\nvoid handle_collision(inout vec3 start, vec3 delta, int slide_plane, out int hit_plane, out int ground_plane)\n{\n    \/\/ We iterate again through all the collision brushes, this time performing two ray intersections:\n    \/\/ one determines how far we can actually move, while the other does a ground check from the starting\n    \/\/ point, giving us an approximate ground plane.\n    \/\/ Note that the ground plane isn't computed from the final position - that would require another pass\n    \/\/ through all the brushes!\n    \n    const float LARGE_NUMBER = 1e+6;\n\n    hit_plane = -1;\n    ground_plane = -1;\n    float travel_dist = 1.;\n    float ground_dist = LARGE_NUMBER;\n    float eps = 1.\/(length(delta) + 1e-6);\n\n    int num_brushes = NO_UNROLL(NUM_MAP_COLLISION_BRUSHES);\n    for (int i=0; i<num_brushes; ++i)\n    {\n        int first_plane = cm_brushes.data[i];\n        int last_plane = cm_brushes.data[i + 1];\n        int plane_enter = -1;\n        int plane_enter_ground = -1;\n        float t_enter = -LARGE_NUMBER;\n        float t_leave = LARGE_NUMBER;\n        float t_enter_ground = t_enter;\n        float t_leave_ground = t_leave;\n        for (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_collision_plane(j);\n            float dist = get_player_distance(start, plane);\n\n            \/\/ handle ground ray\n            if (plane.z == 0.)\n            {\n                if (dist > 0.)\n                    t_enter_ground = LARGE_NUMBER;\n            }\n            else\n            {\n                float height = dist \/ plane.z;\n                if (plane.z > 0.)\n                {\n                    if (t_enter_ground < height)\n                    {\n                        plane_enter_ground = j;\n                        t_enter_ground = height;\n                    }\n                }\n                else\n                {\n                    t_leave_ground = min(t_leave_ground, height);\n                }\n            }\n\n            \/\/ handle movement ray\n            float align = dot(plane.xyz, delta);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                    t_enter = LARGE_NUMBER;\n                continue;\n            }\n            align = -1.\/align;\n            dist *= align;\n            if (align > 0.)\n            {\n                if (t_enter < dist)\n                {\n                    plane_enter = j;\n                    t_enter = dist;\n                }\n            }\n            else\n            {\n                t_leave = min(t_leave, dist);\n            }\n        }\n\n        if (t_leave_ground > t_enter_ground && t_enter_ground > -8.)\n        {\n            if (t_enter_ground < ground_dist)\n            {\n                ground_plane = plane_enter_ground;\n                ground_dist = t_enter_ground;\n            }\n        }\n\n        if (t_leave > max(t_enter, 0.) && t_enter > -eps)\n        {\n            if (t_enter < travel_dist)\n            {\n                hit_plane = plane_enter;\n                travel_dist = t_enter;\n            }\n        }\n    }\n\n    start += delta * clamp(travel_dist, 0., 1.);\n    delta *= 1. - clamp(travel_dist, 0., 1.);\n\n    if (hit_plane != -1)\n    {\n        vec4 plane = get_collision_plane(hit_plane);\n        start += 1e-2 * plane.xyz;\n        delta -= dot(plane.xyz, delta) * plane.xyz;\n    }\n}\n\nvoid clip_velocity(inout vec3 velocity, int first_hit_plane, int second_hit_plane, float step_size)\n{\n    if (step_size > 0.)\n    {\n        first_hit_plane = second_hit_plane;\n    \tsecond_hit_plane = -1;\n    }\n\n    if (first_hit_plane != -1)\n    {\n        vec4 first = get_collision_plane(first_hit_plane);\n        if (second_hit_plane != -1)\n        {\n            vec4 second = get_collision_plane(second_hit_plane);\n            vec3 crease = normalize(cross(first.xyz, second.xyz));\n            velocity = dot(velocity, crease) * crease;\n        }\n        else\n        {\n            float align = dot(first.xyz, normalize(velocity));\n            velocity -= 1.001 * dot(velocity, first.xyz) * first.xyz;\n            velocity *= mix(1., .5, abs(align)); \/\/ extra friction\n        }\n    }\n}\n\nvoid slide_move(inout vec3 position, inout vec3 velocity, inout vec4 ground, inout float step_transition)\n{\n    vec3 dir = velocity * iTimeDelta;\n\n    int first_hit_plane = -1,\n    \tsecond_hit_plane = -1,\n    \tground_plane = -1;\n    float step_size = 0.;\n\n    find_collision(position, dir, first_hit_plane, step_size);\n    handle_collision(position, dir, first_hit_plane, second_hit_plane, ground_plane);\n    clip_velocity(velocity, first_hit_plane, second_hit_plane, step_size);\n    \n    ground = vec4(0);\n    if (ground_plane != -1)\n    {\n        vec4 plane = get_collision_plane(ground_plane);\n        if (is_valid_ground(position, plane))\n            ground = plane;\n    }\n\n    step_transition += step_size;\n}\n\n\/\/ UV distortions \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 running_bond(vec2 uv, float rows)\n{\n    uv.x += floor(uv.y * rows) * .5;\n    return uv;\n}\n\nvec2 running_bond(vec2 uv, float cols, float rows)\n{\n    uv.x += floor(uv.y * rows) * (.5 \/ cols);\n    return uv;\n}\n\nvec3 herringbone(vec2 uv)\n{\n    uv *= 4.;\n    float horizontal = step(1., mod(uv.x + floor(uv.y) + 3., 4.) - 1.);\n    uv = mix(-uv.yx + vec2(3. - floor(uv.x), 0.), uv.xy + vec2(3. - floor(uv.y), 0.), horizontal);\n    return vec3(uv * .25, horizontal);\n}\n\n\/\/ 3D effects \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ centered on 0; >0 for lightness, <0 for darkness\nfloat add_bevel(vec2 uv, float cols, float rows, float thickness, float light, float dark)\n{\n    uv = fract(uv * vec2(cols, rows));\n    vec4 d = clamp(vec4(uv.xy, 1.-uv.xy)\/vec2(thickness*cols, thickness*rows).xyxy, 0., 1.);\n    return light*(2. - d.x - d.w) - dark*(2. - d.y - d.z);\n}\n\n\/\/ QUAKE text \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_QUAKE(vec2 uv)\n{\n    uv.x *= .9375;\n    float sdf\t\t\t\t\t\t   = sdf_Q_top(uv);\n    uv.x -= .875;\tsdf = sdf_union(sdf, sdf_U(uv));\n    uv.x -= .8125;\tsdf = sdf_union(sdf, sdf_A(uv));\n    uv.x -= 1.0625;\tsdf = sdf_union(sdf, sdf_K(uv));\n    uv.x -= .625;\tsdf = sdf_union(sdf, sdf_E(uv));\n    return sdf;\n}\n\nvec2 engraved_QUAKE(vec2 uv, float size, vec2 light_dir)\n{\n    const float EPS = .1\/64.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_QUAKE(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1.\/64.);\n    float bevel = clamp(1. + sdf.z\/size, 0., 1.);\n    float intensity = .5 + sqr(bevel) * dot(gradient, light_dir);\n    intensity = mix(1.125, intensity, mask);\n    mask = sdf_mask(sdf.z - 1.\/64., 1.\/64.);\n    return vec2(intensity, mask);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ waves.x = amplitude; .y = frequency; .z = phase offset\nfloat sdf_flame_segment(vec2 uv, vec2 size, vec3 waves)\n{\n    float h = linear_step(0., size.y, uv.y);\n    float width = mix(.5, .005, sqr(h)) * size.x;\n    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));\n}\n\nfloat sdf_flame_segment2(vec2 uv, vec2 size, vec3 waves)\n{\n    float width = mix(size.x*.005, size.x*.5, smoothen(around(size.y*.5, size.y*.5, uv.y)));\n    float h = linear_step(0., size.y, uv.y);\n    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));\n}\n\nfloat sdf_window_flame(vec2 uv)\n{\n    bool left = uv.x < .5;\n    float sdf = uv.y - 1.;\n    uv.y -= .95;\n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, -.02), vec2(.4, 1.9), vec3(.11, 1., .0)));\n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .21)-vec2(-.13, 0.), vec2(.3, 1.2), vec3(.08, 1.2, .95)));\n\tsdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .0)-vec2(.31, 0.), vec2(.3, 1.4), vec3(.1, 1.2, .55)));\n    \n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, left ? .3 : -.3) - (left ? vec2(-.28, 0.) : vec2(.37, -.1)),\n                                           vec2(.2, left ? .31 : .35), vec3(left ? -.03 : .03, 1., .5)));\n    \n    sdf = sdf_union(sdf, sdf_flame_segment2(uv - (left ? vec2(-.35, 1.25) : vec2(.17, 1.5)), vec2(.11, left ? .4 : .35),\n                                            vec3(-.02, 1., .5)));\n    sdf = sdf_union(sdf, sdf_flame_segment2(skew(uv-vec2(.35, 1.35), -.0), vec2(.11, .24), vec3(.02, 1., .5)));\n    return sdf;\n}\n\nfloat sdf_window_emblem(vec2 uv)\n{\n    vec2 uv2 = vec2(min(uv.x, 1.-uv.x), uv.y);\n\t\n    float sdf = sdf_centered_box(uv, vec2(.5, .25), vec2(.375, .1));\n    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.36, .1), .15));\n    \n    float h = linear_step(.35, .8, uv.y);\n    float w = mix(.27, .35, sqr(triangle_wave(.5, h))) + sqrt(h) * .15;\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.5, .6), vec2(w, .26)));\n    \n    h = linear_step(.95, .6, uv.y);\n    w = .6 - around(.9, .8, h) * .5;\n    sdf = sdf_exclude(sdf, .75*sdf_centered_box(uv, vec2(.5, .75), vec2(w, .21)));\n    \n    \/\/ eyes\n    sdf = sdf_exclude(sdf, sdf_line(uv2, vec2(.45, .4), vec2(.4, .45), .04));\n\n    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.15, .2), .15));\n\tsdf = sdf_union(sdf, sdf_line(uv, vec2(.5, .125), vec2(.5, .875), .0625));\n    return sdf;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat line_sqdist(vec2 uv, vec2 a, vec2 b)\n{\n    vec2 ab = b-a, ap = uv-a;\n    float t = clamp(dot(ap, ab)\/dot(ab, ab), 0., 1.);\n    return length_squared(uv - (ab*t + a));\n}\n\nfloat sdf_chickenscratch(vec2 uv, vec2 mins, vec2 maxs, float thickness)\n{\n    uv -= mins;\n    maxs -= mins;\n    \n    vec2 p0, p1, p2, p3;\n    if (uv.x < maxs.x*.375)\n    {\n        p0 = vec2(0.);\n        p1 = vec2(.3, 1.);\n        p2 = vec2(.3, 0.);\n        p3 = vec2(.09, .28);\n    }\n    else\n    {\n        p0 = vec2(.45, 0.);\n        p1 = vec2(.45, 1.);\n        p2 = vec2(.75, 0.);\n        p3 = p0;\n    }\n    p0 *= maxs;\n    p1 *= maxs;\n    p2 *= maxs;\n    p3 *= maxs;\n\n    float dist = line_sqdist(uv, p0, p1);\n    dist = min(dist, line_sqdist(uv, p1, p2));\n    dist = min(dist, line_sqdist(uv, p2, p3));\n\n    #define LINE(a, b) line_sqdist(uv, maxs*a, maxs*b)\n    \n    dist = min(dist, LINE(vec2(.65, 1.), vec2(.95, 0.)));\n    dist = min(dist, LINE(vec2(.85, 1.), vec2(.65, .65)));\n\n\t#undef LINE\n    \n    return sqrt(dist) + thickness * -.5;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Cellular noise code by Brian Sharpe\n\/\/  https:\/\/briansharpe.wordpress.com\/\n\/\/  https:\/\/github.com\/BrianSharpe\/GPU-Noise-Lib\n\/\/\n\/\/  Modified to add tiling\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\n\/\/\tFAST32_hash\n\/\/\tA very fast hashing function.  Requires 32bit support.\n\/\/\thttp:\/\/briansharpe.wordpress.com\/2011\/11\/15\/a-fast-and-simple-32bit-floating-point-hash-function\/\n\/\/\n\/\/\tThe 2D hash formula takes the form....\n\/\/\thash = mod( coord.x * coord.x * coord.y * coord.y, SOMELARGEFLOAT ) \/ SOMELARGEFLOAT\n\/\/\tWe truncate and offset the domain to the most interesting part of the noise.\n\/\/\tSOMELARGEFLOAT should be in the range of 400.0->1000.0 and needs to be hand picked.  Only some give good results.\n\/\/\tA 3D hash is achieved by offsetting the SOMELARGEFLOAT value by the Z coordinate\n\/\/\n\nconst vec2 OFFSET = vec2( 26.0, 161.0 );\nconst vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n\nvoid FAST32_hash_2D_tile( vec2 gridcell, vec2 gridsize, out vec4 hash_0, out vec4 hash_1 )\n{\n    \/\/    gridcell is assumed to be an integer coordinate\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n    P = P - floor(P * ( 1.0 \/ gridsize.xyxy )) * gridsize.xyxy;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 \/ SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 \/ SOMELARGEFLOATS.y ) );\n}\n\nvec4 FAST32_hash_2D_tile( vec2 gridcell, vec2 gridsize )\n{\n    \/\/    gridcell is assumed to be an integer coordinate\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n    P = P - floor(P * ( 1.0 \/ gridsize.xyxy )) * gridsize.xyxy;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    return fract( P * ( 1.0 \/ SOMELARGEFLOATS.x ) );\n}\n\nfloat FAST32_smooth_noise(vec2 P, vec2 gridsize)\n{\n    P *= gridsize;\n    vec2 Pi = floor(P), Pf = smoothen(P - Pi);\n    vec4 hash = FAST32_hash_2D_tile(Pi, gridsize);\n    return mix(mix(hash.x, hash.y, Pf.x), mix(hash.z, hash.w, Pf.x), Pf.y);\n}\n\n\/\/\tconvert a 0.0->1.0 sample to a -1.0->1.0 sample weighted towards the extremes\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    \/\/return (1.0 - samples * samples) * sign(samples);\t\/\/ square\n    return (samples * samples * samples) - sign(samples);\t\/\/ cubic (even more variance)\n}\n\n\/\/\n\/\/\tCellular Noise 2D\n\/\/\tBased off Stefan Gustavson's work at http:\/\/www.itn.liu.se\/~stegu\/GLSL-cellular\n\/\/\thttp:\/\/briansharpe.files.wordpress.com\/2011\/12\/cellularsample.jpg\n\/\/\n\/\/\tSpeed up by using 2x2 search window instead of 3x3\n\/\/\tproduces a range of 0.0->1.0\n\/\/\nfloat Cellular2D(vec2 P, vec2 gridsize)\n{\n    P *= gridsize;\t\/\/ adx: multiply here instead of requiring callers to do it\n    \/\/\testablish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec2 Pf = P - Pi;\n\n    \/\/\tcalculate the hash.\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D_tile( Pi, gridsize, hash_x, hash_y );\n\n    \/\/\tgenerate the 4 random points\n#if 0\n    \/\/\trestrict the random point offset to eliminate artifacts\n    \/\/\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.25;\t\/\/ 0.25 will guarentee no artifacts.  0.25 is the intersection on x of graphs f(x)=( (0.5+(0.5-x))^2 + (0.5-x)^2 ) and f(x)=( (0.5+x)^2 + x^2 )\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n#else\n    \/\/\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    \/\/\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x = hash_x * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y = hash_y * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    \/\/\treturn the closest squared distance\n    vec4 dx = Pf.xxxx - hash_x;\n    vec4 dy = Pf.yyyy - hash_y;\n    vec4 d = dx * dx + dy * dy;\n    d.xy = min(d.xy, d.zw);\n    return min(d.x, d.y) * ( 1.0 \/ 1.125 );\t\/\/\tscale return value from 0.0->1.125 to 0.0->1.0  ( 0.75^2 * 2.0  == 1.125 )\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ The MIT License\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ XY=offset, Z=dist\nvec3 voronoi(vec2 x, vec2 grid)\n{\n    x *= grid; \/\/ adx: multiply here instead of requiring callers to do it\n    vec2 n = floor(x);\n    vec2 f = x - n;\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for (int j=-1; j<=1; j++)\n    for (int i=-1; i<=1; i++)\n    {\n        vec2 g = vec2(i, j);\n\t\tvec2 o = hash2(mod(n + g, grid));\t\/\/ adx: added domain wrapping\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md)\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 8.0;\n    for (int j=-2; j<=2; j++)\n    for (int i=-2; i<=2; i++)\n    {\n        vec2 g = mg + vec2(i, j);\n\t\tvec2 o = hash2(mod(n + g, grid));\t\/\/ adx: added domain wrapping\n        vec2 r = g + o - f;\n        float d = length_squared(mr - r);\n\n        if (d > 0.00001)\n        \tmd = min(md, -inversesqrt(d)*dot(mr+r, mr-r));\n    }\n\n    return vec3(mr, 0.5*md); \/\/ adx: changed order\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat tileable_smooth_noise(vec2 p, vec2 scale)\n{\n#if 0\n    p *= scale;\n    vec2 pi = floor(p);\n    p = smoothen(p - pi);\n    vec4 seed = fract(vec4(pi, pi + 1.) * (1.\/scale).xyxy);\n    float s00 = random(seed.xy);\n    float s01 = random(seed.zy);\n    float s10 = random(seed.xw);\n    float s11 = random(seed.zw);\n    return mix(mix(s00, s01, p.x), mix(s10, s11, p.x), p.y);\n#else\n    return FAST32_smooth_noise(p, scale);\n#endif\n}\n\nfloat tileable_turb(vec2 uv, vec2 scale, float gain, float lacunarity)\n{\n\tfloat accum = tileable_smooth_noise(uv, scale);\n    float octave_weight = gain;\n    float total_weight = 1.;\n\n    scale *= lacunarity;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    scale *= lacunarity; octave_weight *= gain;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    scale *= lacunarity; octave_weight *= gain;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    return accum \/ total_weight;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 generate_texture(const int material, vec2 uv)\n{\n    vec2 tile_size = get_tile(material).zw;\n\n\tvec3 clr;\n    float shaded = 1.;\t\/\/ 0 = fullbright; 0.5 = lit; 1.0 = lit+AO\n    \n    float grain = random(uv*128.);\n    \n    \/\/ gathering FBM parameters first and calling the function once\n    \/\/ instead of per material reduces the compilation time for this buffer\n    \/\/ by about 4 seconds (~9.4 seconds vs ~13.4) on my machine...\n    \n    \/\/ array-based version compiles about 0.7 seconds faster\n    \/\/ than the equivalent switch (~14.1 seconds vs ~14.8)...\n\n    const vec4 MATERIAL_SETTINGS[]=vec4[7](vec4(3,5,1,3),vec4(3,5,1,4),vec4(6,6,.5,3),vec4(10,10,.5,2),vec4(3,5,1,2),vec4(7,3,.5\n    ,2),vec4(7,5,.5,2));\n    const int MATERIAL_INDICES[]=int[NUM_MATERIALS+1](1,1,1,0,1,0,1,0,0,0,1,6,6,6,1,1,2,3,4,5,0);\n\n    vec4 settings = MATERIAL_SETTINGS[MATERIAL_INDICES[min(uint(material), uint(NUM_MATERIALS))]];\n    vec2 base_grid = settings.xy;\n    float base_gain = settings.z;\n    float base_lacunarity = settings.w;\n\n    if (is_material_sky(material))\n        uv += sin(uv.yx * (3.*PI)) * (4.\/128.);\n\n    vec2 aspect = tile_size \/ min(tile_size.x, tile_size.y);\n    float base = tileable_turb(uv * aspect, base_grid, base_gain, base_lacunarity);\n    \n    \/\/ this switch compiles ~2.2 seconds faster on my machine\n    \/\/ than an equivalent if\/else if chain (~11.5s vs ~13.7s)\n    \n\t#define GENERATE(mat) ((GENERATE_TEXTURES) & (1<<(mat)))\n\n    switch (material)\n    {\n#if GENERATE(MATERIAL_WIZMET1_2) || GENERATE(MATERIAL_QUAKE)\n        case MATERIAL_WIZMET1_2:\n        case MATERIAL_QUAKE:\n        {\n            uv.x *= tile_size.x\/tile_size.y;\n            uv += vec2(.125, .0625);\n            base = mix(base, grain, .2);\n            clr = mix(vec3(.16, .13, .06), vec3(.30, .23, .12), sqr(base));\n            clr = mix(clr, vec3(.30, .23, .13), sqr(linear_step(.5, .9, base)));\n            clr = mix(clr, vec3(.10, .10, .15), smoothen(linear_step(.7, .1, base)));\n            if (material == MATERIAL_WIZMET1_2 || (material == MATERIAL_QUAKE && uv.y < .375))\n            {\n                vec2 knob_pos = floor(uv*4.+.5)*.25;\n                vec2 knob = add_knob(uv, 1.\/64., knob_pos, 3.\/64., vec2(-.4, .4));\n                clr = mix(clr, vec3(.22, .22, .28)*mix(1., knob.x, .8), knob.y);\n                knob = add_knob(uv, 1.\/64., knob_pos, 1.5\/64., vec2(.4, -.4));\n                clr = mix(clr, .7*vec3(.22, .22, .28)*mix(1., knob.x, .7), knob.y);\n            }\n            if (material == MATERIAL_QUAKE)\n            {\n                uv -= vec2(1.375, .15625);\n                uv.x = mod(uv.x, 5.);\n                uv.y = fract(uv.y);\n                vec2 engraved = engraved_QUAKE(uv, 5.\/64., vec2(0, -1));\n                clr *= mix(1., mix(1., engraved.x*1.25, .875), engraved.y);\n            }\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZMET1_1)\n        case MATERIAL_WIZMET1_1:\n        {\n            base = mix(base, grain, .4);\n            float scratches = linear_step(.15, .9, smooth_noise(vec2(32,8)*rotate(uv, 22.5).x) * base);\n            clr = vec3(.17, .17, .16) * mix(.5, 1.5, base);\n            clr = mix(clr, vec3(.23, .19, .15), scratches);\n            scratches *= linear_step(.6, .25, smooth_noise(vec2(16,4)*rotate(uv, -45.).x) * base);\n            clr = mix(clr, vec3(.21, .21, .28) * 1.5, scratches);\n            float bevel = .6 *mix(3.5\/64., 11.\/64., base);\n            float d = min(1., min(uv.x, 1.-uv.y) \/ bevel);\n            float d2 = min(d, 3. * min(uv.y, 1.-uv.x) \/ bevel);\n            clr *= 1. - (1. - d2) * mix(.3, .8, base);\n            clr = mix(clr, vec3(.39, .39, .57) * base, around(.6, .4, d));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZ1_4)\n        case MATERIAL_WIZ1_4:\n        {\n            base = mix(smoothen(base), grain, .3);\n            clr = mix(vec3(.37, .28, .21), vec3(.52, .41, .33), smoothen(base));\n            clr = mix(clr, vec3(.46, .33, .15), around(.45, .05, base));\n            clr = mix(clr, vec3(.59, .48, .39), around(.75, .09, base)*.75);\n            float bevel = mix(4.\/64., 12.\/64., FAST32_smooth_noise(uv, vec2(21)));\n            vec2 mins = vec2(bevel, bevel * 2.);\n            vec2 maxs = 1. - vec2(bevel, bevel * 2.);\n            uv = running_bond(uv, 1., 2.) * vec2(1, 2);\n            vec2 duv = (fract(uv) - clamp(fract(uv), mins, maxs)) * (1.\/bevel) * vec2(2, 1);\n            float d = mix(length(duv), max_component(abs(duv)), .75);\n            clr *= clamp(2.1 - d*mix(.75, 1., sqr(base)), 0., 1.);\n            clr *= 1. + mix(.25, .5, base) * max(0., dot(duv, INV_SQRT2*vec2(-1,1)) * step(d, 1.2));\n        }\n\t\tbreak;\n#endif\n\n#if GENERATE(MATERIAL_WBRICK1_5)\n        case MATERIAL_WBRICK1_5:\n        {\n            vec2 uv2 = uv + sin(uv.yx * (3.*PI)) * (4.\/64.);\n            uv = running_bond(uv + vec2(.5, 0), 1., 2.) * vec2(1, 2);\n            base = mix(smoothen(base), grain, .3);\n            float detail = tileable_smooth_noise(uv2, vec2(11));\n            detail = sqr(around(.625, .25, detail)) * linear_step(.5, .17, base);\n            clr = mix(vec3(.21, .17, .06)*.75, vec3(.30, .26, .15), base);\n            clr *= mix(.95, 2., sqr(sqr(base)));\n            clr = mix(clr, vec3(.41, .32, .14), detail);\n            float bevel = mix(4.\/64., 8.\/64., base);\n            vec2 mins = vec2(bevel, bevel * 1.75);\n            vec2 maxs = 1. - vec2(bevel, bevel * 2.);\n            vec2 duv = (fract(uv) - clamp(fract(uv), mins, maxs)) * (1.\/bevel) * vec2(2, 1);\n            float d = length(duv);\n            if (uv.y > 1. || uv.y < .5)\n                d = mix(d, max_component(abs(duv)), .5);\n            \/\/clr *= mix(1., mix(.25, .625, base), linear_step(1., 2., d)*step(1.5, d));\n            clr *= clamp(2.1 - d*mix(.75, 1., sqr(base)), 0., 1.);\n            clr *= 1. + mix(.25, .5, base) * max(0., dot(duv, INV_SQRT2*vec2(-1,1)) * step(d, 1.2));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_CITY4_7)\n        case MATERIAL_CITY4_7:\n        {\n            base = mix(base, grain, .4);\n            vec3 brick = herringbone(uv);\n            uv = brick.xy;\n            clr = mix(vec3(.23, .14, .07), vec3(.29, .16, .08), brick.z) * mix(.3, 1.7, base);\n            clr = mix(clr, vec3(.24, .18, .10), linear_step(.6, .9, base));\n            clr = mix(clr, vec3(.47, .23, .12), linear_step(.9, 1., sqr(grain))*.6);\n            clr *= (1. + add_bevel(uv, 2., 4., mix(1.5\/64., 2.5\/64., base), -mix(.05, .15, grain), 0.6));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_CITY4_6)\n\t\tcase MATERIAL_CITY4_6:\n        {\n            base = mix(base, grain, .5);\n            vec3 brick = herringbone(uv);\n            uv = brick.xy;\n            clr = mix(vec3(.09, .08, .01)*1.25, 2.*vec3(.21, .15, .08), sqr(base));\n            clr *= mix(.85, 1., brick.z);\n            clr = mix(clr, mix(.25, 1.5, sqr(base))*vec3(.11, .11, .22), around(.8, mix(.24, .17, brick.z), (grain)));\n            clr = mix(clr, mix(.75, 1.5, base)*vec3(.26, .20, .10), .75*sqr(around(.8, .2, (base))));\n            clr *= (1. + add_bevel(uv, 2., 4., 2.1\/64., .0, .25));\n            clr *= (1. + add_bevel(uv, 2., 4., mix(1.5\/64., 2.5\/64., base), mix(.25, .05, grain), .35));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_DEM4_1)\n        case MATERIAL_DEM4_1:\n        {\n            base = mix(base, grain, .2);\n            clr = mix(vec3(.18, .19, .21), vec3(.19, .15, .06), linear_step(.4, .7, base));\n            shaded = .75; \/\/ lit, half-strength AO\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_COP3_4)\n        case MATERIAL_COP3_4:\n        {\n            float sdf = sdf_chickenscratch(uv, vec2(.25, .125), vec2(.75, .375), 1.5\/64.);\n            base = mix(base, grain, .2);\n            base *= mix(1., .625, sdf_mask(sdf, 1.\/64.));\n            clr = mix(vec3(.14, .15, .13), vec3(.41, .21, .12), base);\n            clr = mix(clr, vec3(.30, .32, .34), linear_step(.6, 1., base));\n            float bevel = mix(2.\/64., 6.\/64., sqr(FAST32_smooth_noise(uv, vec2(13))));\n            clr *= (1. + add_bevel(uv, 1., 1., bevel, .5, .5));\n            clr *= 1.5;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_BRICKA2_2) || GENERATE(MATERIAL_WINDOW02_1)\n        case MATERIAL_BRICKA2_2:\n        case MATERIAL_WINDOW02_1:\n        {\n            vec2 grid = (material == MATERIAL_BRICKA2_2) ? vec2(6., 5.) : vec2(8., 24.);\n            uv = (material == MATERIAL_WINDOW02_1) ? fract(uv + vec2(.5, .5\/3.)) : uv;\n            vec3 c = voronoi(uv, grid);\n            if (material == MATERIAL_BRICKA2_2)\n            {\n                float dark_edge = linear_step(.0, mix(.05, .45, base), c.z);\n                float lit_edge = linear_step(.35, .25, c.z);\n                float lighting = -normalize(c.xy).y * .5;\n                clr = vec3(.25, .18, .10) * mix(.8, 1.2, grain);\n                clr *= (1. + lit_edge * lighting) * mix(.35, 1., dark_edge);\n                uv = fract(running_bond(uv, 1., 2.) * vec2(1, 2));\n                clr *=\n                    mix(1., min(1., 4.*min(uv.y, 1.-uv.y)), .5) *\n                \tmix(1., min(1., 8.*min(uv.x, 1.-uv.x)), .3125);\n                clr *= 1.25;\n            }\n            else\n            {\n                \/\/ Note: using x*48 instead of x\/fwidth(x) reduces compilation time\n                \/\/ for this buffer by ~23% (~10.3 seconds vs ~13.4) on my system\n                float intensity = mix(1.25, .75, hash1(uv*grid + c.xy)) * (1. - .5*length(c.xy));\n                uv.y *= 3.;\n                float flame = sdf_window_flame(uv) * 48.;\n                float emblem = sdf_window_emblem(uv) * 48.;\n                float edge = linear_step(.0, .15, c.z);\n                clr = mix(vec3(1., .94, .22) * 1.125, vec3(.63, .30, .19), clamp(flame, 0., 1.));\n                clr = mix(clr, vec3(.55, .0, .0), clamp(1.-emblem, 0., 1.));\n                clr = mix(vec3(dot(clr, vec3(1.\/3.))), clr, intensity);\n                edge *= clamp(abs(flame), 0., 1.) * clamp(abs(emblem), 0., 1.);\n                edge *= step(max(abs(uv.x - .5) - .5, abs(uv.y - 1.5) - 1.5), -2.\/64.);\n                clr *= intensity * edge;\n                shaded = .75; \/\/ lit, half-strength AO\n            }\n    \t}\n        break;\n#endif\n\n#if GENERATE(MATERIAL_LAVA1) || GENERATE(MATERIAL_WATER2) || GENERATE(MATERIAL_WATER1)\n        case MATERIAL_LAVA1:\n        case MATERIAL_WATER2:\n        case MATERIAL_WATER1:\n        {\n            vec2 grid = (material == MATERIAL_WATER1) ? vec2(5., 7.) : vec2(5., 5.);\n            uv += base * (1.\/31.) * sin(PI * 7. * uv.yx);\n            float cellular = Cellular2D(uv, grid);\n            float grain_amount = (material == MATERIAL_LAVA1) ? .125 : .25;\n            float high_point = (material == MATERIAL_WATER2) ? .8 : .9;\n            base = mix(base, grain, grain_amount);\n            cellular = sqrt(cellular) + mix(-.3, .3, base);\n            base = linear_step(.1, high_point, cellular);\n            if (material == MATERIAL_LAVA1)\n            {\n                clr = mix(vec3(.24,.0,.0), vec3(1.,.40,.14), base);\n                clr = mix(clr, vec3(1.,.55,.23), linear_step(.5, 1., base));\n            }\n            else if (material == MATERIAL_WATER2)\n            {\n                clr = mix(vec3(.10,.10,.14)*.8, vec3(.17,.17,.24)*.8, base);\n                clr = mix(clr, vec3(.16,.13,.06)*mix(.8, 2.5, sqr(sqr(base))), around(.5, .1, grain));\n                clr = mix(clr, vec3(.20,.20,.29)*.8, linear_step(.5, 1., base));\n            }\n            else \/\/ if (material == MATERIAL_WATER1)\n            {\n                clr = mix(vec3(.08,.06,.04), vec3(.30,.23,.13), base);\n                clr = mix(clr, vec3(.36,.28,.21), linear_step(.5, 1., base));\n            }\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZWOOD1_5)\n\t\tcase MATERIAL_WIZWOOD1_5:\n        {\n            const vec2 GRID = vec2(1, 4);\n            uv = running_bond(fract(uv.yx), GRID.x, GRID.y);\n            vec2 waviness = vec2(sin(3. * TAU * uv.y), 0) * .0;\n            waviness.x += smooth_noise(uv.y * 16.) * (14.\/64.);\n            base = tileable_turb(uv + waviness, vec2(2, 32), .5, 3.);\n            clr = mix(vec3(.19, .10, .04)*1.25, vec3(.64, .26, .17), around(.5, .4, smoothen(base)));\n            clr = mix(clr, vec3(.32, .17, .08), around(.7, .3, base)*.7);\n            \n            float across = fract(uv.y * GRID.y);\n            clr *= 1. + .35 * linear_step(1.-4.\/16., 1.-2.\/16., across) * step(across, 1.-2.\/16.);\n            across = min(across, 1. - across);\n            clr *= mix(1., linear_step(0., 2.\/16., across), mix(.25, .75, base));\n\t\t\tfloat along = fract(uv.x * GRID.x);\n            clr *= 1. + .25 * linear_step(2.\/64., 0., along);\n            clr *= mix(1., linear_step(1., 1.-2.5\/64., along), mix(.5, .75, base));\n            \n            const vec2 LIGHT_DIR = INV_SQRT2 * vec2(-1, 1);\n            uv = fract(uv * GRID);\n            vec2 side = sign(.5 - uv); \/\/ keep track of side before folding to 'unmirror' light direction\n            uv = min(uv, 1. - uv) * (1.\/GRID);\n            vec2 nail = add_knob(uv, 1.\/64., vec2(4.\/64.), 1.\/64., side * LIGHT_DIR);\n            clr = mix(clr, vec3(.64, .26, .17) * nail.x, nail.y * .75);\n\n            clr *= .9 + grain*.2;\n            clr *= .75;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_TELEPORT)\n        case MATERIAL_TELEPORT:\n        {\n            uv *= 64.\/3.;\n            vec2 cell = floor(uv);\n            vec4 n = hash4(cell);\n            uv -= cell;\n            float radius = mix(.15, .5, sqr(sqr(n.z)));\n            n.xy = mix(vec2(radius), vec2(1.-radius), smoothen(n.xy));\n            uv = clamp((n.xy - uv) * (1.\/radius), -1., 1.);\n            clr = (1.-length_squared(uv)) * (1.-sqr(sqr(n.w))) * vec3(.44, .36, .26);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_FLAME)\n        case MATERIAL_FLAME:\n        {\n            base = mix(base, grain, .1);\n            clr = mix(vec3(.34, .0, .0), vec3(1., 1., .66), smoothen(base));\n            clr = clamp(clr * 1.75, 0., 1.);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_ZOMBIE)\n        case MATERIAL_ZOMBIE:\n        {\n            base = mix(base, grain, .2);\n            clr = vec3(.57, .35, .24) * mix(.6, 1., sqr(base));\n            clr = mix(clr, vec3(.17, .08, .04), linear_step(.3, .7, base));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_SKY1)\n        case MATERIAL_SKY1:\n        {\n            clr = vec3(.18, .10, .12) * 1.5 * smoothen(base);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_SKY1B)\n        case MATERIAL_SKY1B:\n        {\n            clr = vec3(.36, .19, .23) * 1.125 * smoothen(base);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n        default:\n        {\n            clr = vec3(base * .75);\n        }\n        break;\n    }\n    \n\t#undef GENERATE\n    \n    clr = clamp(clr, 0., 1.);\n\n    return vec4(clr, shaded);\n}\n\nvoid generate_tiles(inout vec4 fragColor, vec2 fragCoord, float lod)\n{\n    float atlas_scale = exp2(-lod);\n    if (is_inside(fragCoord, atlas_mip0_bounds(atlas_scale)) < 0.)\n        return;\n    \n    int material = -1;\n    vec4 bound;\n    \n    int num_materials = NO_UNROLL(NUM_MATERIALS);\n    for (int i=0; i<num_materials; ++i)\n    {\n        bound = get_tile(i) * atlas_scale;\n        bound.xy += ATLAS_OFFSET;\n        if (is_inside(fragCoord, bound) > 0.)\n        {\n            material = i;\n            break;\n        }\n    }\n    \n    if (material == -1)\n        return;\n    \n    vec2 local_uv = (fragCoord - bound.xy) \/ bound.zw;\n    fragColor = generate_texture(material, local_uv);\n}\n\nvoid update_mips(inout vec4 fragColor, vec2 fragCoord, float atlas_lod, inout int available_mips)\n{\n    int mip_start = ALWAYS_REFRESH > 0 ? 1 : available_mips;\n    available_mips = min(available_mips + 1, MAX_MIP_LEVEL + 1 - int(atlas_lod));\n    \n    float atlas_scale = exp2(-atlas_lod);\n\n    if (is_inside(fragCoord, atlas_chain_bounds(atlas_scale)) < 0.)\n        return;\n    if (is_inside(fragCoord, atlas_mip0_bounds(atlas_scale)) > 0.)\n        return;\n\n    int mip_end = available_mips;\n    int mip;\n    vec2 atlas_size = ATLAS_SIZE * atlas_scale;\n    vec2 ofs;\n    for (mip=mip_start; mip<mip_end; ++mip)\n    {\n        float fraction = exp2(-float(mip));\n        ofs = mip_offset(mip) * atlas_size + ATLAS_OFFSET;\n        vec2 size = atlas_size * fraction;\n        if (is_inside(fragCoord, vec4(ofs, size)) > 0.)\n            break;\n    }\n    \n    if (mip == mip_end)\n        return;\n    \n    vec2 src_ofs = mip_offset(mip-1) * atlas_size + ATLAS_OFFSET;\n    vec2 uv = fragCoord - ofs - .5;\n\n    \/\/ A well-placed bilinear sample would be almost equivalent,\n    \/\/ except the filtering would be done in sRGB space instead\n    \/\/ of linear space. Of course, the textures could be created\n    \/\/ in linear space to begin with, since we're rendering to\n    \/\/ floating-point buffers anyway... but then we'd be a bit too\n    \/\/ gamma-correct for 1996 :)\n\n    ivec4 iuv = ivec2(uv * 2. + src_ofs).xyxy + ivec2(0, 1).xxyy;\n    vec4 t00 = gamma_to_linear(texelFetch(iChannel1, iuv.xy, 0));\n    vec4 t01 = gamma_to_linear(texelFetch(iChannel1, iuv.xw, 0));\n    vec4 t10 = gamma_to_linear(texelFetch(iChannel1, iuv.zy, 0));\n    vec4 t11 = gamma_to_linear(texelFetch(iChannel1, iuv.zw, 0));\n\n    fragColor = linear_to_gamma((t00 + t01 + t10 + t11) * .25);\n}\n\nvoid update_tiles(inout vec4 fragColor, vec2 fragCoord)\n{\n    const vec4 SENTINEL_COLOR = vec4(1, 0, 1, 0);\n    \n    vec4 resolution = vec4(iResolution.xy, 0, 0);\n    vec4 old_resolution = (iFrame==0) ? vec4(0) : load(ADDR_RESOLUTION);\n    int flags = int(old_resolution.z);\n    if (iFrame == 0 && iTime >= THUMBNAIL_MIN_TIME)\n        flags |= RESOLUTION_FLAG_THUMBNAIL;\n    vec4 atlas_info = (iFrame==0) ? vec4(0) : load(ADDR_ATLAS_INFO);\n    int available_mips = int(round(atlas_info.x));\n   \n    vec2 available_space = (resolution.xy - ATLAS_OFFSET) \/ ATLAS_CHAIN_SIZE;\n    float atlas_lod = max(0., -floor(log2(min(available_space.x, available_space.y))));\n    if (atlas_lod != atlas_info.y)\n        available_mips = 0;\n    if (max(abs(resolution.x-old_resolution.x), abs(resolution.y-old_resolution.y)) > .5)\n        flags |= RESOLUTION_FLAG_CHANGED;\n    \n    \/\/ Workaround for Shadertoy double-buffering bug on resize\n    \/\/ (this.mBuffers[i].mLastRenderDone = 0; in effect.js\/Effect.prototype.ResizeBuffer)\n    vec2 sentinel_address = ATLAS_OFFSET + ATLAS_CHAIN_SIZE * exp2(-atlas_lod) - 1.;\n    vec4 sentinel = (iFrame == 0) ? vec4(0) : load(sentinel_address);\n    if (any(notEqual(sentinel, SENTINEL_COLOR)))\n    {\n        available_mips = 0;\n        flags |= RESOLUTION_FLAG_CHANGED;\n    }\n    \n    resolution.z = float(flags);\n\n    if (available_mips > 0)\n    \tupdate_mips(fragColor, fragCoord, atlas_lod, available_mips);\n    \n    if (ALWAYS_REFRESH > 0 || available_mips == 0)\n    {\n        if (available_mips == 0)\n        \tstore(fragColor, fragCoord, ADDR_RANGE_ATLAS_CHAIN, vec4(0.));\n        generate_tiles(fragColor, fragCoord, atlas_lod);\n        available_mips = max(available_mips, 1);\n    }\n    atlas_info.x = float(available_mips);\n    atlas_info.y = atlas_lod;\n\n    store(fragColor, fragCoord, ADDR_RESOLUTION, resolution);\n    store(fragColor, fragCoord, ADDR_ATLAS_INFO, atlas_info);\n    store(fragColor, fragCoord, sentinel_address, SENTINEL_COLOR);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define T(x0,y0,z0,x1,y1,z1) vec3(x0,y0,z0),vec3(x1,y1,z1)\n\nWRAP(Teleporters,teleporters,vec3,6)(T(208,1368,-0,256,1384,96),T(520,1368,-0,568,1384,96),T(840,1368,-0,888,1384,96)));\n\nbool touch_tele(vec3 pos, float radius)\n{\n    radius *= radius;\n    bool touch = false;\n    for (int i=0; i<6; i+=2)\n    {\n        vec3 mins = teleporters.data[i];\n        vec3 maxs = teleporters.data[i+1];\n        vec3 delta = clamp(pos, mins, maxs) - pos;\n        if (dot(delta, delta) <= radius)\n            touch = true;\n    }\n    return touch;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ returns true if processing should stop\nbool fire_weapon(inout vec4 fragColor, vec2 fragCoord,\n                 vec3 old_pos, vec3 old_angles,\n                 inout float attack_cycle, inout float shots_fired)\n{\n\tconst float ATTACK_DURATION = .75;\n    const float ATTACK_WAIT = 1. - 1.\/(ATTACK_DURATION*RATE_OF_FIRE);\n\n    if (attack_cycle > 0.)\n        attack_cycle = max(0., attack_cycle - iTimeDelta * (1.\/ATTACK_DURATION));\n    \n    bool wants_to_fire = cmd_attack() > 0.;\n    bool resolution_changed = any(notEqual(load(ADDR_RESOLUTION).xy, iResolution.xy));\n    if (attack_cycle > ATTACK_WAIT || !wants_to_fire || iFrame <= 0 || resolution_changed)\n        return false;\n\n    attack_cycle = 1.;\n    shots_fired += 1.;\n    if (is_inside(fragCoord, ADDR_RANGE_SHOTGUN_PELLETS) < 0.)\n        return false;\n    \n    Options options;\n    LOAD_PREV(options);\n    \n    float prev_downscale = get_downscale(options);\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame-1, iResolution.xy, prev_downscale);\n    vec2 ndc = hash2(iTime + fragCoord) * (WEAPON_SPREAD*2.) + -WEAPON_SPREAD;\n    vec2 coord = iResolution.xy * (ndc - ndc_scale_bias.zw) \/ ndc_scale_bias.xy;\n    mat3 prev_view_matrix = rotation(old_angles);\n    vec3 fire_dir = prev_view_matrix * unproject(ndc);\n    GBuffer gbuffer = gbuffer_unpack(texelFetch(iChannel2, ivec2(coord), 0));\n    vec3 normal = gbuffer.normal;\n\n    fragColor.xyz = old_pos + fire_dir * (gbuffer.z * VIEW_DISTANCE);\n    int material = (gbuffer.z > 12.\/VIEW_DISTANCE) ? gbuffer.material : MATERIAL_SKY1B;\n    fragColor.w = float(material);\n    \n    \/\/ prevent particles from clipping the ground when falling\n    \/\/ not using 0 as threshold since reconstructed normal isn't 100% accurate\n    if (normal.z > .01)\t\n        fragColor.z += 8.;\n    \n    return true;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid update_ideal_pitch(vec3 pos, vec3 forward, vec3 velocity, inout float ideal_pitch)\n{\n    if (iMouse.z > 0. || length_squared(velocity.xy) < sqr(WALK_SPEED\/4.))\n        return;\n    \n    if (dot(forward, normalize(velocity)) < .7)\n    {\n        ideal_pitch = 0.;\n        return;\n    }\n    \n    \/\/ look up\/down near stairs\n    \/\/ totally ad-hoc, but it kind of works...\n\tconst vec3 STAIRS[] = vec3[](vec3(272, 496, 24), vec3(816, 496, 24));\n\n    vec3 to_stairs = closest_point_on_segment(pos, STAIRS[0], STAIRS[1]) - pos;\n    float sq_dist = length_squared(to_stairs);\n    if (sq_dist < sqr(48.))\n        return;\n    \n    float facing_stairs = dot(to_stairs, forward);\n    if (sq_dist > (facing_stairs > 0. ? sqr(144.) : sqr(64.)))\n    {\n        ideal_pitch = 0.;\n        return;\n    }\n    \n    if (facing_stairs * inversesqrt(sq_dist) < .7)\n        return;\n\n    ideal_pitch = to_stairs.z < 0. ? -STAIRS_PITCH : STAIRS_PITCH;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#if 0 \/\/ 4:3\nconst vec3 SPAWN_POS\t\t= vec3(544, 296, 49);\nconst vec4 DEFAULT_ANGLES\t= vec4(0);\n#else\nconst vec3 SPAWN_POS\t\t= vec3(544, 272, 49);\nconst vec4 DEFAULT_ANGLES\t= vec4(0, 5, 5, 0);\n#endif\nconst vec4 DEFAULT_POS\t\t= vec4(SPAWN_POS, 0);\n\nvoid update_input(inout vec4 fragColor, vec2 fragCoord)\n{\n    float allow_input\t= is_input_enabled();\n    vec4 pos\t\t\t= (iFrame==0) ? DEFAULT_POS : load(ADDR_POSITION);\n    vec4 angles\t\t\t= (iFrame==0) ? DEFAULT_ANGLES : load(ADDR_ANGLES);\n    vec4 old_pos\t\t= (iFrame==0) ? DEFAULT_POS : load(ADDR_CAM_POS);\n    vec4 old_angles\t\t= (iFrame==0) ? DEFAULT_ANGLES : load(ADDR_CAM_ANGLES);\n    vec4 velocity\t\t= (iFrame==0) ? vec4(0) : load(ADDR_VELOCITY);\n    vec4 ground_plane\t= (iFrame==0) ? vec4(0) : load(ADDR_GROUND_PLANE);\n    bool thumbnail\t\t= (iFrame==0) ? true : (int(load(ADDR_RESOLUTION).z) & RESOLUTION_FLAG_THUMBNAIL) != 0;\n    \n    Transitions transitions;\n    LOAD_PREV(transitions);\n    \n    MenuState menu;\n    LOAD_PREV(menu);\n    if (iFrame > 0 && menu.open > 0)\n        return;\n    \n    if (iFrame == 0 || is_demo_mode_enabled(thumbnail))\n        allow_input = 0.;\n\n    if (allow_input > 0. && fire_weapon(fragColor, fragCoord, old_pos.xyz, old_angles.xyz, transitions.attack, transitions.shot_no))\n        return;\n    \n    Options options;\n    LOAD_PREV(options);\n\n    angles.w = max(0., angles.w - iTimeDelta);\n    if (angles.w == 0.)\n    \tangles.y = mix(angles.z, angles.y, exp2(-8.*iTimeDelta));\n\n\tvec4 mouse_status\t= (iFrame==0) ? vec4(0) : load(ADDR_PREV_MOUSE);\n    if (allow_input > 0.)\n    {\n        float mouse_lerp = MOUSE_FILTER > 0. ?\n            min(1., iTimeDelta\/.0166 \/ (MOUSE_FILTER + 1.)) :\n        \t1.;\n        if (iMouse.z > 0.)\n        {\n            float mouse_y_scale = INVERT_MOUSE != 0 ? -1. : 1.;\n            if (test_flag(options.flags, OPTION_FLAG_INVERT_MOUSE))\n                mouse_y_scale = -mouse_y_scale;\n            float sensitivity = SENSITIVITY * exp2((options.sensitivity - 5.) * .5);\n            \n            if (iMouse.z > mouse_status.z)\n                mouse_status = iMouse;\n            vec2 mouse_delta = (iMouse.z > mouse_status.z) ?\n                vec2(0) : mouse_status.xy - iMouse.xy;\n            mouse_delta.y *= -mouse_y_scale;\n            angles.xy += 360. * sensitivity * mouse_lerp \/ max_component(iResolution.xy) * mouse_delta;\n            angles.z = angles.y;\n            angles.w = AUTOPITCH_DELAY;\n        }\n        mouse_status = vec4(mix(mouse_status.xy, iMouse.xy, mouse_lerp), iMouse.zw);\n    }\n    \n    float strafe = cmd_strafe();\n    float run = (cmd_run()*.5 + .5) * allow_input;\n    float look_side = cmd_look_left() - cmd_look_right();\n    angles.x += look_side * (1. - strafe) * run * TURN_SPEED * iTimeDelta;\n    float look_up = cmd_look_up() - cmd_look_down();\n    angles.yz += look_up * run * TURN_SPEED * iTimeDelta;\n    \/\/ delay auto-pitch for a bit after looking up\/down\n    if (abs(look_up) > 0.)\n        angles.w = .5;\n    if (cmd_center_view() * allow_input > 0.)\n        angles.zw = vec2(0);\n    angles.x = mod(angles.x, 360.);\n    angles.yz = clamp(angles.yz, -80., 80.);\n\n#if NOCLIP\n    const bool noclip = true;\n#else\n    bool noclip = test_flag(options.flags, OPTION_FLAG_NOCLIP);\n#endif\n\n    mat3 move_axis = rotation(vec3(angles.x, noclip ? angles.y : 0., 0));\n\n    vec3 input_dir\t\t= vec3(0);\n    input_dir\t\t\t+= (cmd_move_forward() - cmd_move_backward()) * move_axis[1];\n    float move_side\t\t= cmd_move_right() - cmd_move_left();\n    move_side\t\t\t= clamp(move_side - look_side * strafe, -1., 1.);\n    input_dir\t \t\t+= move_side * move_axis[0];\n    input_dir.z \t\t+= (cmd_move_up() - cmd_move_down());\n    float wants_to_move = step(0., dot(input_dir, input_dir));\n    float wish_speed\t= WALK_SPEED * allow_input * wants_to_move * (1. + -.5 * run);\n\n    float lava_dist\t\t= max_component(abs(pos.xyz - clamp(pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1])));\n\n\tif (noclip)\n    {\n        float friction = mix(NOCLIP_STOP_FRICTION, NOCLIP_START_FRICTION, wants_to_move);\n        float velocity_blend = exp2(-friction * iTimeDelta);\n        velocity.xyz = mix(input_dir * wish_speed, velocity.xyz, velocity_blend);\n        pos.xyz += velocity.xyz * iTimeDelta;\n        ground_plane = vec4(0);\n    }\n    else\n    {\n        \/\/ if not ascending, allow jumping when we touch the ground\n        if (input_dir.z <= 0.)\n            velocity.w = 0.;\n        \n        input_dir.xy = safe_normalize(input_dir.xy);\n        \n        bool on_ground = is_touching_ground(pos.xyz, ground_plane);\n        if (on_ground)\n        {\n            \/\/ apply friction\n            float speed = length(velocity.xy);\n            if (speed < 1.)\n            {\n                velocity.xy = vec2(0);\n            }\n            else\n            {\n                float drop = max(speed, STOP_SPEED) * GROUND_FRICTION * iTimeDelta;\n                velocity.xy *= max(0., speed - drop) \/ speed;\n            }\n        }\n        else\n        {\n            input_dir.z = 0.;\n        }\n\n        if (lava_dist <= 0.)\n            wish_speed *= .25;\n\n        \/\/ accelerate\n\t\tfloat current_speed = dot(velocity.xy, input_dir.xy);\n\t\tfloat add_speed = wish_speed - current_speed;\n\t\tif (add_speed > 0.)\n        {\n\t\t\tfloat accel = on_ground ? GROUND_ACCELERATION : AIR_ACCELERATION;\n\t\t\tfloat accel_speed = min(add_speed, accel * iTimeDelta * wish_speed);\n            velocity.xyz += input_dir * accel_speed;\n\t\t}\n\n        if (on_ground)\n        {\n            velocity.z -= (GRAVITY * .25) * iTimeDelta;\t\/\/ slowly slide down slopes\n            velocity.xyz -= dot(velocity.xyz, ground_plane.xyz) * ground_plane.xyz;\n\n            if (transitions.stair_step <= 0.)\n                transitions.bob_phase = fract(transitions.bob_phase + iTimeDelta * (1.\/BOB_CYCLE));\n\n            update_ideal_pitch(pos.xyz, move_axis[1], velocity.xyz, angles.z);\n\n            if (input_dir.z > 0. && velocity.w <= 0.)\n            {\n                velocity.z += JUMP_SPEED;\n                \/\/ wait for the jump key to be released\n                \/\/ before jumping again (no auto-hopping)\n                velocity.w = 1.;\n            }\n        }\n        else\n        {\n            velocity.z -= GRAVITY * iTimeDelta;\n        }\n\n        if (is_inside(fragCoord, ADDR_RANGE_PHYSICS) > 0.)\n            slide_move(pos.xyz, velocity.xyz, ground_plane, transitions.stair_step);\n    }\n\n    bool teleport = touch_tele(pos.xyz, 16.);\n    if (!noclip)\n    \tteleport = teleport || ((DEFAULT_POS.z - pos.z) > VIEW_DISTANCE); \/\/ falling too far below the map\n\n    if (cmd_respawn() * allow_input > 0. || teleport)\n    {\n        pos = vec4(DEFAULT_POS.xyz, iTime);\n        angles = teleport ? vec4(0) : DEFAULT_ANGLES;\n        velocity.xyz = vec3(0, teleport ? WALK_SPEED : 0., 0);\n        ground_plane = vec4(0);\n        transitions.stair_step = 0.;\n        transitions.bob_phase = 0.;\n    }\n    \n    \/\/ smooth stair stepping\n    transitions.stair_step = max(0., transitions.stair_step - iTimeDelta * STAIR_CLIMB_SPEED);\n\n    vec4 cam_pos = pos;\n    cam_pos.z -= transitions.stair_step;\n    \n    \/\/ bobbing\n    float speed = length(velocity.xy);\n    if (speed < 1e-2)\n        transitions.bob_phase = 0.;\n    cam_pos.z += clamp(speed * BOB_SCALE * (.3 + .7 * sin(TAU * transitions.bob_phase)), -7., 4.);\n    \n    vec4 cam_angles = vec4(angles.xy, 0, 0);\n    \n    \/\/ side movement roll\n    cam_angles.z += clamp(dot(velocity.xyz, move_axis[0]) * (1.\/ROLL_SPEED), -1., 1.) * ROLL_ANGLE;\n\n    \/\/ lava pain roll\n    if (lava_dist <= 32.)\n    \tcam_angles.z += 5. * clamp(fract(iTime*4.)*-2.+1., 0., 1.);\n    \n    \/\/ shotgun recoil\n    cam_angles.y += linear_step(.75, 1., transitions.attack) * RECOIL_ANGLE;\n\n    store(fragColor, fragCoord, ADDR_POSITION, pos);\n    store(fragColor, fragCoord, ADDR_ANGLES, angles);\n    store(fragColor, fragCoord, ADDR_CAM_POS, cam_pos);\n    store(fragColor, fragCoord, ADDR_CAM_ANGLES, cam_angles);\n    store(fragColor, fragCoord, transitions);\n    store(fragColor, fragCoord, ADDR_PREV_CAM_POS, old_pos);\n    store(fragColor, fragCoord, ADDR_PREV_CAM_ANGLES, old_angles);\n    store(fragColor, fragCoord, ADDR_PREV_MOUSE, mouse_status);\n    store(fragColor, fragCoord, ADDR_VELOCITY, velocity);\n    store(fragColor, fragCoord, ADDR_GROUND_PLANE, ground_plane);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid update_perf_stats(inout vec4 fragColor, vec2 fragCoord)\n{\n    vec4 perf = (iFrame==0) ? vec4(0) : load(ADDR_PERF_STATS);\n    perf.x = mix(perf.x, iTimeDelta*1000., 1.\/16.);\n    store(fragColor, fragCoord, ADDR_PERF_STATS, perf);\n    \n\t\/\/ shift old perf samples\n    const vec4 OLD_SAMPLES = ADDR_RANGE_PERF_HISTORY + vec4(1,0,-1,0);\n    if (is_inside(fragCoord, OLD_SAMPLES) > 0.)\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord)-ivec2(1,0), 0);\n\n    \/\/ add new sample\n    if (is_inside(fragCoord, ADDR_RANGE_PERF_HISTORY.xy) > 0.)\n    {\n        Options options;\n        LOAD_PREV(options);\n        fragColor = vec4(iTimeDelta*1000., get_downscale(options), 0., 0.);\n    }\n}\n\nvoid update_game_rules(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_RANGE_TARGETS) > 0.)\n    {\n        Target target;\n        Transitions transitions;\n        GameState game_state;\n        \n        from_vec4(target, fragColor);\n        LOAD_PREV(game_state);\n        LOAD_PREV(transitions);\n        float level = floor(game_state.level);\n        float index = floor(fragCoord.x - ADDR_RANGE_TARGETS.x);\n\n        if (target.level != level)\n        {\n            target.level = level;\n            target.shot_no = transitions.shot_no;\n            if (level > 0. || index == SKY_TARGET_OFFSET.x)\n            \ttarget.hits = 0.;\n            to_vec4(fragColor, target);\n            return;\n        }\n\n        \/\/ already processed this shot?\n        if (target.shot_no == transitions.shot_no)\n            return;\n        target.shot_no = transitions.shot_no;\n        \n        \/\/ disable popping during game over animation\n        if (game_state.level < 0. && game_state.level != floor(game_state.level))\n            return;\n\n        float target_material = index < float(NUM_TARGETS) ? index + float(BASE_TARGET_MATERIAL) : float(MATERIAL_SKY1);\n        int hits = 0;\n\n        \/\/ The smart thing to do here would be to split the sum over several frames\n        \/\/ in a binary fashion, but the shader is already pretty complicated,\n        \/\/ so to make my life easier I'll go with a naive for loop.\n        \/\/ To save face, let's say I'm doing this to avoid the extra latency\n        \/\/ of log2(#pellets) frames the smart method would incur...\n\n        for (float f=0.; f<ADDR_RANGE_SHOTGUN_PELLETS.z; ++f)\n        {\n            vec4 pellet = load(ADDR_RANGE_SHOTGUN_PELLETS.xy + vec2(f, 0.));\n            hits += int(pellet.w == target_material);\n        }\n        \n        \/\/ sky target is all or nothing\n        if (target_material == float(MATERIAL_SKY1))\n            hits = int(hits == int(ADDR_RANGE_SHOTGUN_PELLETS.z));\n        \n        target.hits += float(hits);\n        to_vec4(fragColor, target);\n\n        return;\n    }\n    \n    if (is_inside(fragCoord, ADDR_GAME_STATE) > 0.)\n    {\n        const float\n            ADVANCE_LEVEL\t\t\t= 1. + LEVEL_WARMUP_TIME * .1,\n        \tFIRST_ROUND_DURATION\t= 15.,\n        \tMIN_ROUND_DURATION\t\t= 6.,\n        \tROUND_TIME_DECAY\t\t= -1.\/8.;\n        \n        GameState game_state;\n        from_vec4(game_state, fragColor);\n        \n        MenuState menu;\n        LOAD(menu);\n        float time_delta = menu.open > 0 ? 0. : iTimeDelta;\n\n        if (game_state.level <= 0.)\n        {\n            float level = ceil(game_state.level);\n            if (level < 0. && game_state.level != level)\n            {\n                game_state.level = min(level, game_state.level + time_delta * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            Target target;\n            LOADR(SKY_TARGET_OFFSET, target);\n            if (target.hits > 0. && target.level == game_state.level)\n            {\n                game_state.level = ADVANCE_LEVEL;\n                game_state.time_left = FIRST_ROUND_DURATION;\n                game_state.targets_left = float(NUM_TARGETS);\n            }\n        }\n        else\n        {\n            float level = floor(game_state.level);\n            if (level != game_state.level)\n            {\n                game_state.level = max(level, game_state.level - time_delta * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            \n            game_state.time_left = max(0., game_state.time_left - time_delta);\n            if (game_state.time_left == 0.)\n            {\n                game_state.level = -(level + BALLOON_SCALEIN_TIME * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            \n            float targets_left = 0.;\n            Target target;\n            for (vec2 addr=vec2(0); addr.x<ADDR_RANGE_TARGETS.z-1.; ++addr.x)\n            {\n                LOADR(addr, target);\n                if (target.hits < ADDR_RANGE_SHOTGUN_PELLETS.z * .5 || target.level != level)\n                    ++targets_left;\n            }\n            \n            if (floor(game_state.targets_left) != targets_left)\n                game_state.targets_left = targets_left + HUD_TARGET_ANIM_TIME * .1;\n            else\n                game_state.targets_left = max(floor(game_state.targets_left), game_state.targets_left - time_delta * .1);\n\n            if (targets_left == 0.)\n            {\n                game_state.level = level + ADVANCE_LEVEL;\n                game_state.time_left *= .5;\n                game_state.time_left += mix(MIN_ROUND_DURATION, FIRST_ROUND_DURATION, exp2(level*ROUND_TIME_DECAY));\n                game_state.targets_left = float(NUM_TARGETS);\n            }\n        }\n\n        to_vec4(fragColor, game_state);\n        return;\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid update_menu(inout vec4 fragColor, vec2 fragCoord)\n{\n#if ENABLE_MENU\n    if (is_inside(fragCoord, ADDR_MENU) > 0.)\n    {\n        MenuState menu;\n        if (iFrame == 0)\n            clear(menu);\n        else\n            from_vec4(menu, fragColor);\n\n    \tif (is_input_enabled() > 0.)\n        {\n            if (cmd_menu() > 0.)\n            {\n                menu.open ^= 1;\n            }\n            else if (menu.open > 0)\n            {\n                menu.selected += int(is_key_pressed(KEY_DOWN) > 0.) - int(is_key_pressed(KEY_UP) > 0.) + NUM_OPTIONS;\n                menu.selected %= NUM_OPTIONS;\n            }\n        }\n       \n        to_vec4(fragColor, menu);\n        return;\n    }\n    \n    if (is_inside(fragCoord, ADDR_OPTIONS) > 0.)\n    {\n        if (iFrame == 0)\n        {\n            Options options;\n            clear(options);\n            to_vec4(fragColor, options);\n            return;\n        }\n        \n        MenuState menu;\n        LOAD(menu);\n\n        int screen_size_field = get_option_field(OPTION_DEF_SCREEN_SIZE);\n        float screen_size = fragColor[screen_size_field];\n        if (is_key_pressed(KEY_1) > 0.) \tscreen_size = 10.;\n        if (is_key_pressed(KEY_2) > 0.) \tscreen_size = 8.;\n        if (is_key_pressed(KEY_3) > 0.) \tscreen_size = 6.;\n        if (is_key_pressed(KEY_4) > 0.) \tscreen_size = 4.;\n        if (is_key_pressed(KEY_5) > 0.) \tscreen_size = 2.;\n        if (max(is_key_pressed(KEY_MINUS), is_key_pressed(KEY_MINUS_FF)) > 0.)\n            screen_size -= 2.;\n        if (max(is_key_pressed(KEY_PLUS), is_key_pressed(KEY_PLUS_FF)) > 0.)\n            screen_size += 2.;\n        fragColor[screen_size_field] = clamp(screen_size, 0., 10.);\n        \n        int flags_field = get_option_field(OPTION_DEF_SHOW_FPS);\n        int flags = int(fragColor[flags_field]);\n\n        if (is_key_pressed(TOGGLE_TEX_FILTER_KEY) > 0.)\n            flags ^= OPTION_FLAG_TEXTURE_FILTER;\n        if (is_key_pressed(TOGGLE_LIGHT_SHAFTS_KEY) > 0.)\n            flags ^= OPTION_FLAG_LIGHT_SHAFTS;\n        if (is_key_pressed(TOGGLE_CRT_EFFECT_KEY) > 0.)\n            flags ^= OPTION_FLAG_CRT_EFFECT;\n        \n        if (is_key_pressed(SHOW_PERF_STATS_KEY) > 0.)\n        {\n            const int MASK = OPTION_FLAG_SHOW_FPS | OPTION_FLAG_SHOW_FPS_GRAPH;\n            \/\/ https:\/\/fgiesen.wordpress.com\/2011\/01\/17\/texture-tiling-and-swizzling\/\n            \/\/ The line below combines Fabian Giesen's trick (offs_x = (offs_x - x_mask) & x_mask)\n            \/\/ with another one for efficient bitwise integer select (c = a ^ ((a ^ b) & mask)),\n            \/\/ which I think I also stole from his blog, but I can't find the link\n            flags ^= (flags ^ (flags - MASK)) & MASK;\n            \n            \/\/ don't show FPS graph on its own when using keyboard shortcut to cycle through options\n            if (test_flag(flags, OPTION_FLAG_SHOW_FPS_GRAPH))\n                flags |= OPTION_FLAG_SHOW_FPS;\n        }\n        \n        fragColor[flags_field] = float(flags);\n\n        if (menu.open <= 0)\n            return;\n        float adjust = is_key_pressed(KEY_RIGHT) - is_key_pressed(KEY_LEFT);\n\n        MenuOption option = get_option(menu.selected);\n        int option_type = get_option_type(option);\n        int option_field = get_option_field(option);\n        if (option_type == OPTION_TYPE_SLIDER)\n        {\n            fragColor[option_field] += adjust;\n            fragColor[option_field] = clamp(fragColor[option_field], 0., 10.);\n        }\n        else if (option_type == OPTION_TYPE_TOGGLE && (abs(adjust) > .5 || is_key_pressed(KEY_ENTER) > 0.))\n        {\n            int value = int(fragColor[option_field]);\n            value ^= get_option_range(option);\n            fragColor[option_field] = float(value);\n        }\n        \n        return;\n    }\n#endif \/\/ ENABLE_MENU\n}\n\nvoid advance_time(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_TIMING) > 0.)\n    {\n        MenuState menu;\n        LOAD_PREV(menu);\n        \n        Timing timing;\n        if (iFrame == 0)\n            clear(timing);\n        else\n        \tfrom_vec4(timing, fragColor);\n\n        bool paused = timing.prev == iTime;\n        if (paused)\n            timing.flags |= TIMING_FLAG_PAUSED;\n        else\n            timing.flags &= ~TIMING_FLAG_PAUSED;\n        \n        \/\/ Note: on 144 Hz monitors, in thumbnail mode, iTimeDelta\n        \/\/ seems to be incorrect (1\/60 seconds instead of 1\/144)\n        float time_delta = iTime - timing.prev;\n        if (!paused && menu.open == 0 && g_time > WORLD_RENDER_TIME)\n            timing.anim += time_delta;\n        timing.prev = iTime;\n        \n        to_vec4(fragColor, timing);\n        return;\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tif (iFrame > 0 && is_inside(fragCoord, ADDR_RANGE_PARAM_BOUNDS) < 0.)\n    \tDISCARD;\n\n    fragColor = (iFrame==0) ? vec4(0) : texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    Lighting lighting;\n    LOAD_PREV(lighting);\n    \n    UPDATE_TIME(lighting);\n\n    write_map_data\t\t(fragColor, fragCoord);\n    update_tiles\t\t(fragColor, fragCoord);\n    update_input\t\t(fragColor, fragCoord);\n    update_game_rules\t(fragColor, fragCoord);\n    update_perf_stats\t(fragColor, fragCoord);\n    update_menu\t\t\t(fragColor, fragCoord);\n    advance_time\t\t(fragColor, fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Buffer B: map\/lightmap rendering\n\/\/ - ray-tracing for the world brushes\n\/\/ - ray-marching for the entities\n\/\/ - GBuffer output\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define RENDER_WORLD\t\t\t\t3\t\t\/\/ 0=off; 1=axial brushes; 2=non-axial brushes; 3=all\n#define RENDER_ENTITIES\t\t\t\t1\n#define RENDER_WEAPON\t\t\t\t1\n\n#define USE_PARTITION\t\t\t\t3\t\t\/\/ 0=off; 1=axial brushes; 2=non-axial brushes; 3=all\n#define USE_ENTITY_AABB\t\t\t\t1\n\n#define DEBUG_ENTITY_AABB\t\t\t0\n\n#define ENTITY_RAYMARCH_STEPS\t\t96\n#define ENTITY_RAYMARCH_TOLERANCE\t1.0\n#define ENTITY_LIGHT_DIR\t\t\tnormalize(vec3(.5, 1, -.5))\n#define ENTITY_MIN_LIGHT\t\t\t0.3125\n#define DITHER_ENTITY_NORMALS\t\t1\n\n#define LIGHTMAP_FILTER\t\t\t\t1\t\t\/\/ 0=off; 1=linear, 1\/16 UV increments; 2=linear\n#define QUANTIZE_LIGHTMAP\t\t\t24\t\t\/\/ only when texture filtering is off; comment out to disable\n#define QUANTIZE_DYNAMIC_LIGHTS\t\t32\t\t\/\/ only when texture filtering is off; comment out to disable\n\n\/\/ Lightmap baking settings: changing these requires a restart\n#define LIGHTMAP_HEIGHT_OFFSET\t\t0.1\n#define LIGHTMAP_EXTRAPOLATE\t\t1.0\t\t\/\/ max distance from brush edge, in texels\n\n#define LIGHTMAP_SCALEDIST\t\t\t1.0\n#define LIGHTMAP_SCALECOS\t\t\t0.5\n#define LIGHTMAP_RANGESCALE\t\t\t0.7\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define BAKE_LIGHTMAP\t\t\t\t1\n#define COMPRESSED_BRUSH_OFFSETS\t1\n#define SETTINGS_CHANNEL\t\t\tiChannel0\n#define NOISE_CHANNEL\t\t\t\tiChannel2\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ World data\n\/\/\n\/\/ Generated from a trimmed\/tweaked version of\n\/\/ the original map by John Romero\n\/\/ https:\/\/rome.ro\/news\/2016\/2\/14\/quake-map-sources-released\n\/\/\n\/\/ Split between Buffer A and B to even out compilation time\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec3 AXIAL_MINS=vec3(48,176,-192), AXIAL_MAXS=vec3(1040,1424,336);\n\nWRAP(AxialBrushes,axial_brushes,int,NUM_MAP_AXIAL_BRUSHES*2)(1073156,8464628,8431646,0xa8b822,8431622,0xa8b80a,8431854,0xa8b8f2,\n8431830,0xa8b8da,8426512,0xa89c18,8426720,0xa89ce8,8439008,0xa8cce8,8438800,0xa8cc18,31483956,33630264,31484096,33630404,\n31483960,33583296,8419328,25241604,8419572,25241848,0xc0003c,25168060,0xb07854,0xc088a4,8390660,0xc060f4,0xc02874,0xc44884,\n0x998890,0xaa089c,0x99885c,0xaa0868,1134788,7430356,0x99886c,0xaa088c,1167556,8519892,8513700,9572592,1124376,7473180,75804,\n1183984,1140816,0xe18858,1181720,7477308,1183804,9574562,8493060,0xa1b808,1151088,0x99a088,1171568,0x99f088,1126508,7422092,\n7415900,8472732,7415872,8523852,7415816,8523836,1183906,9574640,1157280,0xe1c8a4,3745880,3805344,5318820,5378288,3221532,3280976\n,29435992,29968544,1124432,25249884,34154584,34687136,1124588,34687220,29435916,34687064,29436064,34687212,1124508,25249960,\n8464384,34686988,29960280,34162848,1132624,28403800,8472580,28416008,23160912,28411992,23173124,28424200,0xe1a8a2,23185572,\n1132704,33663140,23177376,33671332,0xa19800,23181316,0xe16850,23169110,1149008,28446808,8501252,32663560,1132784,33712372,\n1165472,33689764,0xa2109c,25309352,0xa21050,25309276,9572360,29503500,0xa210ec,29503728,29495304,33698032,0xa23054,32139352,\n8521736,9594940,0xa230a0,33712292,19028166,20078802,0xb258c6,0xc260d2,0xb258c0,20078790,0xb258d2,20078808,0xb25870,0xc26088,\n19028080,20078728,0xc25870,19030134,0xb25834,20078650,0xc25882,19030152,0xb25828,0xc26034,19028008,20078644,0xb25822,20078632,\n0xc25c28,19030068,0xc25c76,19030146,0xc25cc6,19030226,0xa26808,29520034,0xa268a4,33714416));\n\nWRAP(Brushes,brushes,int,NUM_MAP_PACKED_BRUSH_OFFSETS)(18822,805254,1591686,2378118,3164550,3950982,4737414,5522822,6241605,\n6931846,7685510,8439174,9160005,9913734,0xa23d45,0xac4966,0xb7c565,0xc35186,0xcfbd45,0xd9c166,0xe43d45,0xeebd45,0xf894a5));\n\n#define M(x)  x*0x111111,\n#define M2(x) M(x)M(x)\n#define M4(x) M2(x)M2(x)\n#define M8(x) M4(x)M4(x)\n\nconst int NUM_MATERIAL_ENTRIES = 162;\nWRAP(Materials,materials,int,NUM_MATERIAL_ENTRIES)(1315089,M8(2)M2(0)M(0)M2(1)M(1)M2(6)M(10)M4(0)M2(0)M4(1)M2(1)M2(3)M(3)M2(4)M(\n4)M(5)1118485,M(11)M(12)M(13)M8(0)61440,M4(1)5592549,1118485,1118485,M(9)1118494,M2(1)M(5)1118485,M4(0)M(0)M(1)M(4)1118485,M8(0)\nM4(0)M2(8)M(8)M(1)M(5)M8(2)M8(2)M4(6)M4(0)M(0)M4(3)M(3)M(0)17<<16,M(1)7829265,7,3355440,M(3)7829363,M(0)M2(3)489335,1<<22,M(4)\n1328196,M2(1)M(1)4473921,68,M8(0)1118464,4473921,5592388,M(5)M4(0)M(7)M2(0)M(0)M2(7)1911,0));\n\n\/\/ Geometry partitions \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    NUM_AXIAL_NODES = 10,\n    NUM_NONAXIAL_NODES = 10\n;\n\nstruct PackedNode\n{\n    int begin;\n    int end;\n};\n    \nconst struct BVL\n{\n    PackedNode axial[NUM_AXIAL_NODES];\n    PackedNode nonaxial[NUM_NONAXIAL_NODES];\n}\nbvl = BVL\n(\n\t#define N PackedNode\n\n\tN[10](N(687940864,857812285),N(855714048,991967529),N(301999361,688800572),N(17306113,0x90b1a3d),N(68609,17311037),N(\n\t989931777,0x3f204d3d),N(289<<19,304096574),N(0x3f084102,0x47204d3c),N(0x470b4b08,0x56134c36),N(0x560a4d02,0x58204e3c)),\n\n\tN[10](N(721429511,856174140),N(856041751,0x3c0a3937),N(0x4c132524,0x531b3c3d),N(461825,336403005),N(0x41162501,\n\t0x4c1e4d28),N(587663104,656286989),N(654772016,723395901),N(0x3c003902,0x41094d3c),N(336003073,589238333),N(0x53163d24,\n\t0x591b4d3b))\n\n    #undef N\n);\n\nconst vec3\n\tAXIAL_BVL_MINS      = vec3(48,176,-192),\n\tNONAXIAL_BVL_MINS   = vec3(48,176,-176);\n\nstruct Node\n{\n    vec3 mins;\n    int begin;\n    vec3 maxs;\n    int end;\n};\n    \nivec3 unpack888(int n)\n{\n    return (ivec3(n) >> ivec3(0,8,16)) & 255;\n}\n\nNode unpack(const PackedNode p, vec3 bias)\n{\n    Node n;\n    n.mins\t= vec3(unpack888(p.begin)) * 16. + bias;\n    n.begin\t= int(uint(p.begin) >> 24);\n    n.maxs\t= vec3(unpack888(p.end)) * 16. + bias;\n    n.end\t= int(uint(p.end >> 24));\n    return n;\n}\n\n\/\/ Lightmap UV-mapping \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float LIGHTMAP_SCALE = 16.;\nconst vec2 LIGHTMAP_OFFSET = vec2(-169.5,-260.5);\n#define _ -1\nWRAP(LightmapOffsets,LIGHTMAP_OFFSETS,int,NUM_MAP_PLANES)(_,_,121456,_,145069,_,6702,2603,4629,6677,24073,_,8747,_,6169,12800,\n22534,_,_,12831,12870,12873,25655,_,2606,4654,8774,10822,20096,_,12843,_,4120,6168,19465,_,_,8238,10316,12364,22592,_,_,16415,\n16442,16448,22592,_,16427,_,16405,4124,25609,_,21180,22716,_,63045,57526,86682,18108,19644,_,21639,74457,52412,_,_,106628,115243\n,123991,123956,75844,_,_,_,_,_,_,75867,_,_,_,_,_,_,104492,_,_,_,7190,2588,78447,_,78953,_,_,_,120944,_,139376,_,_,_,25763,_,\n16450,_,_,64101,18491,2141,56466,47767,64067,_,7333,8869,47758,65157,7772,22100,22107,_,_,_,_,64084,29749,29758,56466,65170,\n20087,24183,_,15974,_,_,_,_,_,76910,100930,100970,72404,_,_,_,_,_,_,_,_,_,135347,_,121398,32399,_,_,56335,_,11379,_,_,6747,_,_,_\n,_,_,41142,_,_,20040,_,_,_,100912,_,41528,3205,3185,41572,_,_,3218,24721,41565,1710,_,_,_,_,33369,_,_,_,_,_,52318,_,79488,79471,\n94282,95306,_,_,119823,119827,76500,_,_,_,119827,119841,_,_,_,1743,_,_,39575,46743,_,_,60585,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_\n,_,_,_,87092,87111,_,82502,8921,19127,72316,72304,_,_,_,_,89121,75861,82521,_,_,73433,56551,39655,106038,_,_,_,72300,72280,85572\n,85552,_,_,69265,72277,85569,85629,32435,19122,72327,72331,_,_,38078,_,35978,24720,46624,_,_,_,66175,66156,_,_,22749,68806,89615\n,_,_,_,10427,_,35970,_,_,_,29274,32842,_,_,_,148495,32838,_,_,_,_,53323,22651,27259,_,_,_,_,89784,89771,89727,_,50815,_,35471,\n138298,_,_,87586,101952,29845,_,_,_,_,_,36467,31859,_,_,_,_,55008,68832,_,68772,_,_,75966,_,_,24717,_,_,_,89821,_,_,_,_,89764,\n89774,_,89729,_,_,45230,102037,45190,29832,_,_,16057,45235,37501,29821,_,_,76360,_,52865,52863,_,_,_,43209,43174,14004,_,_,_,_,\n128056,125496,_,152750,64717,76884,_,_,_,_,1216,_,_,77857,54379,_,76900,76892,_,_,_,_,_,_,_,6246,47215,80432,_,_,_,35906,80459,_\n,7820,51789,_,21609,69163,_,_,46303,_,46639,105665,_,_,_,_,3185,80456,_,_,_,_,39487,_,80465,49404,_,_,12391,_,_,_,10410,_,12358,\n_,_,_,32508,_,9297,_,_,_,_,_,79373,54282,_,_,_,_,15881,_,55314,29853,_,_,16961,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,\n109639,158323,_,_,_,_,76929,_,_,_,7708,14929,12877,28355,29891,_,_,8786,10834,29245,29249,132145,20116,3130,5175,23087,96365,\n32876,27716,_,23078,3189,23082,54845,38970,23073,15934,37994,28733,48696,29251,23065,4160,23121,37473,16950,_,_,7686,27666,29696\n,10303,_,7689,_,32265,32268,_,_,3105,8733,32774,36352,6184,_,14878,16926,36369,36373,43047,25614,7226,11319,21038,_,21121,28163,\n13370,21045,4224,28674,32827,32793,28745,21050,17472,26653,_,5178,_,2182,33341,33350,45096,25714,8251,13371,37889,96769,_,17983,\n18483,_,35916,21584,77957,_,122411,_,65562,2140,94293,_,144951,_,20585,21609,_,_,53945,_,35881,79379,77468,_,114816,_,11868,\n110103,_,_,57465,57478,45702,44166,_,_,52822,57864,126985,76294,_,_,_,_,30328,23672,13440,13938,_,_,17000,110602,57412,57399,_,_\n,36483,133162,_,_,116276,_,119383,118399,_,32403,_,_,12983,42156,38513,_,_,_,23145,38505,52368,_,_,_,42107,12928,30868,_,_,_,\n23142,23154,_,_,16450,30762,29224,_,_,22038,18969,22033,_,_,_,_,52864,_,_,_,_,63615,_,_,_,133177,116349,_,_,43606,48214,81414,\n82950,56926,_,_,_,51806,36452,22692,_,_,_,42095,22651,_,_,_,104506,104493,_,_,57413,57426,79926,24218,_,57391,_,_,36513,44184,_,\n32415,_,_,42159,42162,_,_,_,104581,104567,28727,52277,78997,75925,19513,28720,_,_,_,33387,42086,7735,_,_,_,66719,30826,64066,_,_\n,_,14935,3675,_,_,_,18519,7259,_,_,_,_,18011,_,_,_,_,90,_,_,50742,_,82503,82485,22571,_,36427,_,_,43618,57949,36418,_,_,_,34389,\n38997,_,_,_,_,39011,34403,_,53819,53815,12492,8252,_,45125,45121,2112,13884,_,96302,52816,13878,13874,_,53838,55856,34378,9282,_\n,31802,38955,3639,103471,_,59004,146045,9260,1095,_,94293,89683,89698,1126,22675,_,_,_,_,21120,_,_,_,113221,158894,158835,78355,\n_,_,_,_,22133,_,_,_,_,7801,52761,52771,_,_,33331,27218,_,_,28758,25686,_,45654,_,_,49255,49245,75815,48231,47685,47675,_,_,33380\n,22127,_,_,66737,_,104607,87199,_,_,76344,76367,97396,_,144920,47200,_,47651,47641,_,51275,_,47631,47621,_,58443,_,_,_,_,141895,\n_,_,_,91305,77993,_,_,_,53405,53416,44652,41580,_,_,33356,16978,_,50798,42057,79430,66629,_,39504,39513,63074,66609,_,39488,\n37440,64594,67671,_,40009,40018,62560,64603,_,40025,50777,48241,64606,_,38522,35450,_,48762,52830,52820,_,_,33370,19567,_,50767,\n40034,80965,72236,_,36972,_,54880,62041,_,_,36964,50797,58470,_,11396,35933,51804,48220,_,52824,52814,_,61050));\n#undef _\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nuvec3 unpack(int data, const ivec3 bits)\n{\n    uvec3 mask = (uvec3(1) << bits) - 1u;\n\tuvec3 shift = uvec3(0, bits.x, bits.x + bits.y);\n    return (uvec3(data) >> shift) & mask;\n}\n\nvec3 get_axial_point(int index)\n{\n    return vec3(unpack(axial_brushes.data[index], ivec3(9))) * 4. + AXIAL_MINS;\n}\n\nint get_nonaxial_brush_start(int index)\n{\n#if COMPRESSED_BRUSH_OFFSETS\n    int data = brushes.data[index >> 2], base = data >> 15;\n    return base + (((data << 5) >> (uint(index & 3) * 5u)) & 31);\n#else\n    return brushes.data[index];\n#endif\n}\n\nvec4 get_nonaxial_plane(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_NONAXIAL_PLANES.xy) + ivec2(index&127,index>>7);\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nvec4 get_plane(int index)\n{\n    vec4 plane;\n    \n    if (index < NUM_MAP_AXIAL_PLANES)\n    {\n        uint\n            brush = uint(index) \/ 6u,\n        \tside = uint(index) % 6u,\n        \taxis = side >> 1,\n        \tfront = side & 1u;\n        vec3 p = get_axial_point(int(brush * 2u + (front ^ 1u)));\n        plane = vec4(0);\n        plane[axis] = front == 1u ? -1. : 1.;\n        plane.w = -p[axis] * plane[axis];\n    }\n    else\n    {\n        plane = get_nonaxial_plane(index - NUM_MAP_AXIAL_PLANES);\n    }\n    \n    return plane;\n}\n\nint get_plane_material(mediump int plane_index)\n{\n    \/\/ An encoding that only needs bit shifts\/masks to decode\n    \/\/ (like 4x8b, 4x4b or 8x4b) would be a much smarter choice.\n    \/\/ On the other hand, 6x4b leads to a shorter textual encoding\n    \/\/ for the array (and a slower decoding sequence).\n    \/\/ Let's pretend character count matters and go with 6x4b...\n    \n    \/\/ Side note: we can use just 4 bits for each plane material id\n    \/\/ because the material list is sorted by frequency of use\n    \/\/ before the id's are assigned, and it just so happens that the map\n    \/\/ currently uses only 16 materials. If we wanted to add just one more\n    \/\/ we'd have to bump up the number of bits per face to 5.\n    \n    \/\/ better division\/modulo codegen for unsigned ints:\n    \/\/ http:\/\/shader-playground.timjones.io\/a05d99ce3e6e1ae57ef111c8323e52d2\n    mediump uint index = uint(plane_index);\n    \n    mediump uint unit_index = index \/ 6u;\n    lowp uint bit_index = index % 6u;\n    bit_index <<= 2;\n    int code = uint(unit_index) < uint(NUM_MATERIAL_ENTRIES) ? materials.data[uint(unit_index)] : 0;\n\n    return 15 & (code >> bit_index);\n}\n\nint get_axial_brush_material(int brush, lowp int side)\n{\n    \/\/ Since we chose 6x4b and axial brushes happen to have 6 sides, the math gets easier\n    int code = uint(brush) < uint(NUM_MATERIAL_ENTRIES) ? materials.data[uint(brush)] : 0;\n    return 15 & (code >> (side << 2));\n}\n\n\/\/ Axial UV mapping \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 uv_map_axial(vec3 pos, int axis)\n{\n    return (axis==0) ? pos.yz : (axis==1) ? pos.xz : pos.xy;\n}\n\nvec3 uv_unmap(vec2 uv, vec4 plane, int axis)\n{\n    switch (axis)\n    {\n        case 0: return vec3(-(plane.w + dot(plane.yz, uv)) \/ plane.x, uv.x, uv.y);\n        case 1: return vec3(uv.x, -(plane.w + dot(plane.xz, uv)) \/ plane.y, uv.y);\n        case 2: return vec3(uv.x, uv.y, -(plane.w + dot(plane.xy, uv)) \/ plane.z);\n        default:\n        \treturn vec3(0);\n    }\n}\n\nvec3 uv_unmap(vec2 uv, vec4 plane)\n{\n    return uv_unmap(uv, plane, dominant_axis(plane.xyz));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 sdf_union(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat sdf_ellipsoid(vec3 p, vec3 r)\n{\n    return (length(p\/r) - 1.) \/ min3(r.x, r.y, r.z);\n}\n\nfloat sdf_sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdf_box(vec3 p, vec3 center, vec3 half_bound)\n{\n    p = abs(p - center) - half_bound;\n    return max3(p.x, p.y, p.z);\n}\n\n\/\/ iq\nfloat sdf_round_box(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p) - b, 0.)) - r;\n}\n\nfloat sdf_torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    \n    float b = (r1-r2)\/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\/\/ http:\/\/mercury.sexy\/hg_sdf\n\/\/ Cone with correct distances to tip and base circle. Z is up, 0 is in the middle of the base.\nfloat sdf_cone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xy), p.z);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t\/\/ distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t\/\/ distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound(float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) \/ dot(ab, ab), 0., 1.);\n    return sdf_sphere(p - mix(a, b, t), radius);\n}\n\n\/\/ this is not quite right\n\/\/ see https:\/\/www.shadertoy.com\/view\/4lcBWn for a correct solution\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float radius_a, float radius_b)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) \/ dot(ab, ab), 0., 1.);\n    return sdf_sphere(p - mix(a, b, t), mix(radius_a, radius_b, t));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Closest\n{\n    vec3 point;\n    float distance_squared;\n};\n\nClosest init_closest(vec3 p, vec3 first)\n{\n    return Closest(first, length_squared(p - first));\n}\n\nvoid update_closest(vec3 p, inout Closest closest, vec3 candidate)\n{\n    float distance_squared = length_squared(p - candidate);\n    if (distance_squared < closest.distance_squared)\n    {\n        closest.distance_squared = distance_squared;\n        closest.point = candidate;\n    }\n}\n\n#define FIND_CLOSEST(point, closest, vecs, len)\t\\\n\tclosest = init_closest(point, vecs[0]);\t\t\\\n    for (int i=1; i<len; ++i)\t\t\t\t\t\\\n        update_closest(p, closest, vecs[i])\t\t\\\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat overshoot(float x, float amount)\n{\n    amount *= .5;\n    return x + amount + amount*sin(x * TAU + -PI\/2.);\n}\n\nfloat fast_sqrt(float x2)\n{\n    return x2 * inversesqrt(x2);\n}\n\nvec2 bounding_sphere(const float distance_squared, const float radius, const int material)\n{\n    return vec2(fast_sqrt(distance_squared)+-radius, material);\n}\n\nbool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, float max_t, vec3 aabb_mins, vec3 aabb_maxs)\n{\n    vec3 t0 = (aabb_mins - ray_origin) * rcp_ray_delta;\n    vec3 t1 = (aabb_maxs - ray_origin) * rcp_ray_delta;\n    vec4 tmin = vec4(min(t0, t1), 0.);\n    vec4 tmax = vec4(max(t0, t1), max_t);\n    return max_component(tmin) <= min_component(tmax);\n}\n\nbool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, vec3 aabb_mins, vec3 aabb_maxs)\n{\n    return ray_vs_aabb(ray_origin, rcp_ray_delta, 1., aabb_mins, aabb_maxs);\n}\n\n\/\/ Minimalistic quaternion support \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Quaternion\n{\n    float s;\n    vec3 v;\n};\n\nQuaternion axis_angle(vec3 axis, float angle)\n{\n    angle = radians(angle * .5);\n    return Quaternion(cos(angle), sin(angle) * axis);\n}\n\nQuaternion mul(Quaternion lhs, Quaternion rhs)\n{\n    return Quaternion(lhs.s * rhs.s - dot(lhs.v, rhs.v), lhs.s * rhs.v + rhs.s * lhs.v + cross(lhs.v, rhs.v));\n}\n\nQuaternion conjugate(Quaternion q)\n{\n    return Quaternion(q.s, -q.v);\n}\n\nQuaternion euler_to_quat(vec3 angles)\n{\n    Quaternion\n        q0 = axis_angle(vec3(0, 0, 1), angles.x),\n        q1 = axis_angle(vec3(1, 0, 0), angles.y),\n        q2 = axis_angle(vec3(0, 1, 0),-angles.z);\n    return mul(q0, mul(q1, q2));\n}\n\nvec3 rotate(Quaternion q, vec3 v)\n{\n    \/\/ https:\/\/fgiesen.wordpress.com\/2019\/02\/09\/rotating-a-single-vector-using-a-quaternion\/\n    vec3 t = 2. * cross(q.v, v);\n    return v + q.s * t + cross(q.v, t);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    NUM_TORCHES\t\t\t\t\t= 3,\n    NUM_LARGE_FLAMES\t\t\t= 2,\n    NUM_ZOMBIES\t\t\t\t\t= 4,\n    NUM_BALLOONS\t\t\t\t= 14,\n    NUM_BALLOON_SETS\t\t\t= 3\n;\n\nconst struct EntityPositions\n{\n    vec3 torches[NUM_TORCHES];\n    vec3 large_flames[NUM_LARGE_FLAMES];\n    vec3 zombies[NUM_ZOMBIES];\n    vec3 balloons[NUM_BALLOONS];\n    uint balloon_sets[NUM_BALLOON_SETS];\n}\ng_ent_pos = EntityPositions\n(\n\tvec3[3](vec3(698,764,84),vec3(394,762,84),vec3(362,1034,20)),\n\tvec3[2](vec3(126,526,12),vec3(958,526,12)),\n\tvec3[4](vec3(1004,928,72),vec3(1004,1048,124),vec3(708,992,52),vec3(708,1116,120)),\n\tvec3[14](vec3(848,896,152),vec3(128,528,144),vec3(960,528,144),vec3(344,1064,168),vec3(440,1344,208),vec3(696,744,224),\n             vec3(664,1056,136),vec3(984,1336,176),vec3(392,744,200),vec3(120,1336,208),vec3(104,1000,96),vec3(656,1328,216),\n             vec3(472,1096,-112),vec3(416,936,112)),\n\tuint[3](0xa9865320u,0xdcba8510u,0x76543210u)\n);\n\nconst uint\n    ENTITY_BIT_TARGET\t\t\t= 0u,\n    ENTITY_BIT_VIEWMODEL\t\t= uint(NUM_TARGETS),\n    ENTITY_BIT_LARGE_FLAMES\t\t= ENTITY_BIT_VIEWMODEL + 1u,\n    ENTITY_BIT_TORCHES\t\t\t= ENTITY_BIT_LARGE_FLAMES + 1u,\n    ENTITY_BIT_FIREBALL\t\t\t= ENTITY_BIT_TORCHES + 1u,\n\n    ENTITY_MASK_TARGETS\t\t\t= (1u << NUM_TARGETS) - 1u,\n    ENTITY_MASK_LARGE_FLAMES\t= (1u << NUM_LARGE_FLAMES) - 1u,\n    ENTITY_MASK_TORCHES\t\t\t= (1u << NUM_TORCHES) - 1u\n;\n    \nstruct FlameState\n{\n    float loop;\n    vec2 sin_cos;\n};\n\nstruct FireballState\n{\n    vec3 offset;\n    Quaternion rotation;\n};\n\nstruct TargetState\n{\n    uint indices;\n    float scale;\n};\n    \nstruct ViewModelState\n{\n    vec3 offset;\n    float attack;\n    Quaternion rotation;\n};\n\nstruct EntityState\n{\n    FlameState\t\tflame;\n    FireballState\tfireball;\n    ViewModelState\tviewmodel;\n    TargetState\t\ttarget;\n    uint\t\t\tmask;\n};\n    \nEntityState g_entities;\n\nvoid update_entity_state(vec3 camera_pos, vec3 camera_angles, vec3 direction, float depth, bool is_thumbnail)\n{\n    g_entities.mask = 0u;\n    \n    g_entities.flame.loop\t\t\t= fract(floor(g_animTime * 10.) * .1);\n    g_entities.flame.sin_cos\t\t= vec2(sin(g_entities.flame.loop * TAU), cos(g_entities.flame.loop * TAU));\n    g_entities.fireball.offset\t\t= get_fireball_offset(g_animTime);\n    g_entities.fireball.rotation\t= axis_angle(normalize(vec3(1, 8, 4)), g_animTime * 360.);\n\n    float base_fov_y = scale_fov(FOV, 9.\/16.);\n    float fov_y = compute_fov(iResolution.xy).y;\n    float fov_y_delta = base_fov_y - fov_y;\n\n    vec3 velocity = load(ADDR_VELOCITY).xyz;\n    Transitions transitions;\n    LOAD(transitions);\n    float offset = get_viewmodel_offset(velocity, transitions.bob_phase, transitions.attack);\n    g_entities.viewmodel.offset\t\t= camera_pos;\n    g_entities.viewmodel.rotation\t= mul(euler_to_quat(camera_angles), axis_angle(vec3(1,0,0), fov_y_delta*.5));\n    g_entities.viewmodel.offset\t\t+= rotate(g_entities.viewmodel.rotation, vec3(0,1,0)) * offset;\n    g_entities.viewmodel.rotation\t= conjugate(g_entities.viewmodel.rotation);\n    g_entities.viewmodel.attack\t\t= linear_step(.875, 1., transitions.attack);\n    \n#if USE_ENTITY_AABB\n    #define TEST_AABB(pos, rcp_delta, mins, maxs) ray_vs_aabb(pos, rcp_delta, mins, maxs)\n#else\n    #define TEST_AABB(pos, rcp_delta, mins, maxs) true\n#endif\n    \n    Options options;\n    LOAD(options);\n    \n    const vec3 VIEWMODEL_MINS = vec3(-1.25,       0, -8);\n    const vec3 VIEWMODEL_MAXS = vec3( 1.25,      18, -4);\n    vec3 viewmodel_ray_origin = vec3(    0, -offset,  0);\n    vec3 viewmodel_ray_delta  = rotate(g_entities.viewmodel.rotation, direction);\n    bool draw_viewmodel = is_demo_mode_enabled(is_thumbnail) ? (g_demo_scene & 1) == 0 : true;\n    draw_viewmodel = draw_viewmodel && test_flag(options.flags, OPTION_FLAG_SHOW_WEAPON);\n    if (draw_viewmodel && TEST_AABB(viewmodel_ray_origin, 1.\/viewmodel_ray_delta, VIEWMODEL_MINS, VIEWMODEL_MAXS))\n        g_entities.mask |= 1u << ENTITY_BIT_VIEWMODEL;\n    \n    vec3 inv_world_ray_delta = 1.\/(direction*depth);\n\n    const vec3 TORCH_MINS = vec3(-4, -4, -28);\n\tconst vec3 TORCH_MAXS = vec3( 4,  4,  18);\n    for (int i=0; i<NUM_TORCHES; ++i)\n        if (TEST_AABB(camera_pos - g_ent_pos.torches[i], inv_world_ray_delta, TORCH_MINS, TORCH_MAXS))\n            g_entities.mask |= (1u<<ENTITY_BIT_TORCHES) << i;\n    \n    const vec3 LARGE_FLAME_MINS = vec3(-10, -10, -18);\n\tconst vec3 LARGE_FLAME_MAXS = vec3( 10,  10,  34);\n    for (int i=0; i<NUM_LARGE_FLAMES; ++i)\n        if (TEST_AABB(camera_pos - g_ent_pos.large_flames[i], inv_world_ray_delta, LARGE_FLAME_MINS, LARGE_FLAME_MAXS))\n            g_entities.mask |= (1u<<ENTITY_BIT_LARGE_FLAMES) << i;\n        \n\tconst vec3 FIREBALL_MINS = vec3(-10);\n\tconst vec3 FIREBALL_MAXS = vec3( 10);\n    if (g_entities.fireball.offset.z > 8. &&\n        TEST_AABB(camera_pos - FIREBALL_ORIGIN - g_entities.fireball.offset, inv_world_ray_delta, FIREBALL_MINS, FIREBALL_MAXS))\n        g_entities.mask |= 1u << ENTITY_BIT_FIREBALL;\n\n    GameState game_state;\n    LOAD(game_state);\n    g_entities.target.scale = 0.;\n    g_entities.target.indices = 0u;\n    if (abs(game_state.level) >= 1.)\n    {\n        vec2 scale_bias = game_state.level > 0. ? vec2(1, 0) : vec2(-1, 1);\n        float fraction = linear_step(BALLOON_SCALEIN_TIME * .1, 0., fract(abs(game_state.level)));\n        g_entities.target.scale = fraction * scale_bias.x + scale_bias.y;\n        if (g_entities.target.scale > 1e-2)\n        {\n            float level = floor(abs(game_state.level));\n            int set = int(fract(level * PHI + .15) * float(NUM_BALLOON_SETS));\n            uint indices = g_ent_pos.balloon_sets[set];\n            g_entities.target.scale = overshoot(g_entities.target.scale, .5);\n        \tg_entities.target.indices = indices;\n            \n            vec3 BALLOON_MINS = vec3(-28, -28, -20) * g_entities.target.scale;\n            vec3 BALLOON_MAXS = vec3( 28,  28,  64) * g_entities.target.scale;\n            for (int i=0; i<NUM_TARGETS; ++i, indices>>=4)\n            {\n                Target target;\n                LOADR(vec2(i, 0.), target);\n                if (target.hits < ADDR_RANGE_SHOTGUN_PELLETS.z * .5)\n                    if (TEST_AABB(camera_pos - g_ent_pos.balloons[indices & 15u], inv_world_ray_delta, BALLOON_MINS, BALLOON_MAXS))\n\t                    g_entities.mask |= (1u << i);\n            }\n        }\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 map_torch_handle(vec3 p)\n{\n    p = rotate(p, 45.);\n    float dist = sdf_box(p, vec3(0, 0, -17), vec3(1, 1, 10));\n    dist = sdf_smin(dist, sdf_box(p, vec3(0, 0, -9), vec3(2, 2, 3)), 3.);\n    vec2 wood = vec2(dist, MATERIAL_WIZWOOD1_5);\n    dist = sdf_box(p, vec3(0, 0, p.z > -20.5 ? -14.5 : -26.5), vec3(1.25, 1.25, .75));\n    return sdf_union(wood, vec2(dist, MATERIAL_WIZMET1_1));\n}\n\nvec2 map_flame(vec3 p)\n{\n    const float scale = 1.;\n    p *= 1.\/scale;\n\n    p.z += 6.;\n    \n    float loop = g_entities.flame.loop;\n    float angle_jitter = hash(g_entities.flame.loop) * 360.;\n\n    vec3 ofs = vec3(-.5, -.5, 0);\n    vec3 p1 = rotate(p, angle_jitter + p.z * (360.\/16.)) + ofs;\n    float dist = sdf_cone(p1, 2.5, 16.);\n\n    ofs = vec3(-1, -1, -2);\n    p1 = rotate(p, angle_jitter + 180. - p.z * (360.\/32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 1.75, 10.), 1.);\n    \n    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 4), 2.5, 1.), 3.);\n\n    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));\n    p1 = vec3(loop_rotation * p.xy, p.z - 2.);\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2,  2, mix(8., 20., loop)), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2,  1, mix(12., 22., fract(loop + .3))), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1, -2, mix(10., 16., fract(loop + .6))), .25));\n\n    return vec2(dist*scale, MATERIAL_FLAME);\n}\n\nvec2 map_large_flame(vec3 p)\n{\n    const float scale = 2.;\n    p *= 1.\/scale;\n    p.z += 6.;\n\n    float loop = g_entities.flame.loop;\n    float angle_jitter = hash(g_entities.flame.loop) * 360.;\n\n    vec3 ofs = vec3(-.5, -.5, 0.);\n    vec3 p1 = rotate(p, angle_jitter + p.z * (360.\/16.)) + ofs;\n    float dist = sdf_cone(p1, 2., 14.);\n    \n    ofs = vec3(1., 1., 0.);\n    p1 = rotate(p, angle_jitter + p.z * (360.\/32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);\n\n    ofs = vec3(-.75, -.75, -1.5);\n    p1 = rotate(p, angle_jitter + 180. - p.z * (360.\/32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);\n\n    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 5), 3.25, 1.5), 2.);\n\n    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));\n    p1 = vec3(loop_rotation * p.xy, p.z);\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2, 2, mix(8., 20., loop)), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2, 1, mix(12., 22., fract(loop + .3))), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1,-2, mix(10., 16., fract(loop + .6))), .25));\n\n    return vec2(dist*scale, MATERIAL_FLAME);\n}\n\nvec2 map_torch(vec3 p, vec3 origin)\n{\n    p -= origin;\n    return sdf_union(map_torch_handle(p), map_flame(p));\n}\n\nvec2 map_fireball(vec3 p, vec3 origin)\n{\n    vec3 current_pos = origin + g_entities.fireball.offset;\n    p -= current_pos;\n    p = rotate(g_entities.fireball.rotation, p);\n    float dist = sdf_sphere(p, 3.);\n    dist = sdf_smin(dist, sdf_sphere(p - vec3(1.5, 1.5, 4), 4.), 3.);\n    dist = sdf_smin(dist, sdf_sphere(p - vec3(2.5,-1.5, 3), 2.5), 3.);\n    return vec2(dist, MATERIAL_LAVA1);\n}\n\n\/\/ very rough draft; work in progress\nvec2 map_zombie(vec3 p)\n{\n    const vec3\n        hip = vec3(2, 3, 2),\n    \tknee = vec3(-1, 1.5, -9),\n    \tankle = vec3(4, 1.25, -21),\n    \ttoe1 = vec3(1.5, 1.6, -24),\n    \ttoe2 = vec3(1, 1.1, -24),\n    \n        spine1 = vec3(1.5, 0, 2),\n        spine2 = vec3(1, 0, 13.5),\n\n        shoulder = vec3(2, 6, 16),\n        elbow = vec3(2, 14, 20),\n        wrist = vec3(2, 22, 26),\n\n        neck = vec3(1, 0, 18),\n        head = vec3(-1.5, 0, 22),\n        mouth = vec3(-1.5, 0, 20)\n\t;\n    \n    vec3 mp = p;\n    mp.y = abs(mp.y);\n\n    float dist = sdf_capsule(mp, ankle, knee, 1., 1.5);\n    dist = sdf_smin(dist, sdf_capsule(mp, knee, hip, 1.5, 2.), .05);\n    dist = sdf_smin(dist, sdf_capsule(mp, ankle, toe1, 1., .5), .5);\n\tdist = sdf_smin(dist, sdf_capsule(mp, ankle, toe2, 1., .5), .5);\n    \n    dist = sdf_smin(dist, sdf_capsule(mp, shoulder, elbow, 1.3, 1.2), 2.);\n    dist = sdf_smin(dist, sdf_capsule(mp, elbow, wrist, 1.2, .9), .5);\n\n    dist = sdf_smin(dist, sdf_round_box(p - spine1, vec3(.25, 3., 3.), .25), 1.5);\n    dist = sdf_smin(dist, sdf_capsule(p, spine1, spine2, 1.), 4.);\n    dist = sdf_smin(dist, sdf_round_box(p - spine2, vec3(.75, 2.5, 2.5), 1.25), 4.);\n\n    dist = sdf_smin(dist, sdf_capsule(p, neck, head, 1.5, 1.1), 1.);\n    dist = sdf_smin(dist, sdf_sphere(p - head, 2.5), 2.);\n    dist = sdf_smin(dist, sdf_round_box(p - mouth, vec3(.5, .5, .5), 1.), 1.);\n\n    \/\/return vec2(dist, MATERIAL_COP3_4);\n    return vec2(dist, MATERIAL_ZOMBIE);\n}\n\nvec2 map_viewmodel(vec3 p)\n{\n    p -= g_entities.viewmodel.offset;\n    float sq_dist = length_squared(p);\n    if (sq_dist > sqr(32.))\n        return bounding_sphere(sq_dist, 24., MATERIAL_SHOTGUN_BARREL);\n    \n    p = rotate(g_entities.viewmodel.rotation, p);\n    \n    const vec3\n        BARREL_0\t= vec3(0,    4, -4.375),\n    \tBARREL_1\t= vec3(0, 13.5, -4.375),\n    \tFLASH_0\t\t= vec3(0, 14.6, -4.375),\n    \tFLASH_1\t\t= vec3(0, 16.1, -4.375),\n    \tBODY_0\t\t= vec3(0,    2, -4.7),\n    \tBODY_1\t\t= vec3(0,  7.5, -4.7),\n        INDENT\t\t= vec3(0,  7.5, -4.7),\n\t\tPUMP_0\t\t= vec3(0,    9, -6.),\n    \tPUMP_1\t\t= vec3(0, 12.9, -6.),\n        PUMP_GROOVE\t= vec3(0, 12.7, -6.)\n\t;\n    \n    vec2 body = vec2(sdf_capsule(p, BARREL_0, BARREL_1, .5), MATERIAL_SHOTGUN_BARREL);\n    body.x = sdf_smin(body.x, sdf_capsule(p, BODY_0, BODY_1, .875), .05);\n    body.x = sdf_smin(body.x, sdf_torus(p - INDENT, vec2(.7, .3)), .05);\n    \n    float attack = g_entities.viewmodel.attack;\n    if (attack > 0.)\n        body = sdf_union(body, vec2(sdf_capsule(p, FLASH_0, FLASH_1, .6, .2), MATERIAL_SHOTGUN_FLASH));\n\n    const float GROOVE_SPACING = .675;\n    vec2 pump = vec2(sdf_capsule(p, PUMP_0, PUMP_1, 1.4), MATERIAL_SHOTGUN_PUMP);\n    p -= PUMP_GROOVE;\n    p.y = fract(p.y * GROOVE_SPACING - .25) * (1.\/GROOVE_SPACING) - .5;\n    pump.x = fOpDifferenceRound(pump.x, sdf_torus(p, vec2(1.3125, .375)), .125);\n    \n    return sdf_union(body, pump);\n}\n\nvoid add_targets(vec3 p, inout vec2 result)\n{\n    uint mask = g_entities.mask & ENTITY_MASK_TARGETS;\n    if (mask == 0u)\n        return;\n\n    float best_sq_dist = 1e+8;\n    int best_index = -1;\n    int best_material = 0;\n    uint indices = g_entities.target.indices;\n    for (int i=0; i<NUM_TARGETS; ++i, mask>>=1, indices>>=4)\n    {\n        if ((mask & 1u) == 0u)\n            continue;\n        int index = int(indices & 15u);\n        float sq_dist = length_squared(p - g_ent_pos.balloons[index]);\n        if (sq_dist < best_sq_dist)\n        {\n            best_sq_dist = sq_dist;\n            best_index = index;\n            best_material = i;\n        }\n    }\n\n    best_material += BASE_TARGET_MATERIAL;\n    if (best_sq_dist > sqr(64.))\n    {\n        result = sdf_union(result, bounding_sphere(best_sq_dist, 56., best_material));\n        return;\n    }\n    \n    vec3 target = g_ent_pos.balloons[best_index];\n    target.z += 8. * sin(TAU * fract(g_animTime * .25 + dot(target.xy, vec2(1.\/137., 1.\/163.))));\n    float scale = g_entities.target.scale;\n    result = sdf_union(result, vec2(sdRoundCone(p - target, 8.*scale, 24.*scale, 28.*scale), best_material));\n}\n\nvec2 map_entities(vec3 p)\n{\n    \/\/ Finding the closest instance and only mapping it instead of the whole list (even for such tiny lists)\n    \/\/ shaves about 4.9 seconds off the compilation time on my machine (~7.6 vs ~12.5)\n\n    vec2 entities = vec2(1e+8, MATERIAL_SKY1);\n    Closest closest;\n    \n    if (0u != (g_entities.mask & (ENTITY_MASK_TORCHES << ENTITY_BIT_TORCHES)))\n    {\n        FIND_CLOSEST(p, closest, g_ent_pos.torches, NUM_TORCHES);\n        if (closest.distance_squared > sqr(40.))\n            entities = bounding_sphere(closest.distance_squared, 32., MATERIAL_FLAME);\n        else\n            entities = map_torch(p, closest.point);\n    }\n\n    if (0u != (g_entities.mask & (ENTITY_MASK_LARGE_FLAMES << ENTITY_BIT_LARGE_FLAMES)))\n    {\n        FIND_CLOSEST(p, closest, g_ent_pos.large_flames, NUM_LARGE_FLAMES);\n        if (closest.distance_squared > sqr(48.))\n            entities = sdf_union(entities, bounding_sphere(closest.distance_squared, 40., MATERIAL_FLAME));\n        else\n            entities = sdf_union(entities, map_large_flame(p - closest.point));\n    }\n    \n#if 0\n    FIND_CLOSEST(p, closest, ZOMBIES);\n\tentities = sdf_union(entities, map_zombie(p - closest.point));\n    \/\/int num_zombies = NO_UNROLL(NUM_ZOMBIES);\n    \/\/for (int i=0; i<num_zombies; ++i)\n    \/\/    entities = sdf_union(entities, map_zombie(p - zombies[i]));\n#endif\n    \n    if (0u != (g_entities.mask & (1u << ENTITY_BIT_FIREBALL)))\n    \tentities = sdf_union(entities, map_fireball(p, FIREBALL_ORIGIN));\n\n    add_targets(p, entities);\n\n    #if RENDER_WEAPON\n    {\n        if ((g_entities.mask & (1u << ENTITY_BIT_VIEWMODEL)) != 0u)\n    \t\tentities = sdf_union(entities, map_viewmodel(p));\n    }\n\t#endif\n    \n    return entities;\n}\n\nvec3 estimate_entity_normal(vec3 p, float dist)\n{\n    const float EPSILON = 1e-3;\n    vec3 normal = vec3(-dist);\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec3 p2 = p;\n        p2[i] += EPSILON;\n        normal[i] += map_entities(p2).x;\n    }\n    return normalize(normal);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Intersection\n{\n    float\tt;\n    vec3\tnormal;\n    int\t\tplane;\n    int\t\tmaterial;\n    int\t\tuv_axis;\n    bool\tmips;\n};\n\nvoid reset_intersection(out Intersection result)\n{\n    result.t\t\t\t= 1.;\n    result.normal\t\t= vec3(0.);\n    result.plane\t\t= -1;\n    result.material\t\t= -1;\n    result.mips\t\t\t= false;\n    result.uv_axis\t\t= 0;\n}\n\nvoid intersect_entities(vec3 campos, vec3 angles, vec3 dir, bool is_thumbnail, inout Intersection result)\n{\n#if RENDER_ENTITIES\n    update_entity_state(campos, angles, dir, result.t, is_thumbnail);\n    if (g_entities.mask == 0u)\n        return;\n\n    float t = 0.;\n    float rcp_length = 1.\/length(dir);\n    int max_steps = NO_UNROLL(ENTITY_RAYMARCH_STEPS);\n    vec2 current = vec2(2, -1);\n    float tolerance = 1e-4;\n    float max_tolerance = ENTITY_RAYMARCH_TOLERANCE * VIEW_DISTANCE * FOV_FACTOR * .5 * g_downscale \/ iResolution[FOV_AXIS];\n    for (int i=0; i<max_steps; ++i)\n    {\n        current = map_entities(campos + dir * t);\n        tolerance = t*max_tolerance + .015;\n        if (current.x < tolerance)\n            break;\n        t += current.x * rcp_length;\n        if (t >= result.t)\n            break;\n    }\n    \n    if (t < result.t && t > 0. && current.x < tolerance)\n    {\n        vec3 hit_point = campos + dir * t;\n        \n        result.t\t\t\t= t;\n        result.material\t\t= int(current.y);\n        result.plane\t\t= -1;\n        result.normal\t\t= estimate_entity_normal(hit_point, current.x);\n        result.mips\t\t\t= true;\n        result.uv_axis\t\t= 3;\n    }\n#if DEBUG_ENTITY_AABB\n    else\n    {\n        result.material\t\t= BASE_TARGET_MATERIAL;\n    }\n#endif \/\/ DEBUG_ENTITY_AABB\n#endif \/\/ RENDER_ENTITIES\n}\n\nvoid intersect_axial_brushes\n(\n    int brush_begin, int brush_end,\n    vec3 campos, vec3 rcp_delta, float znear,\n    inout float best_dist, inout int best_index\n)\n{\n#if RENDER_WORLD & 1\n    brush_begin = brush_begin << 1;\n    brush_end = NO_UNROLL(brush_end) << 1;\n    for (int i=brush_begin; i<brush_end; i+=2)\n    {\n        vec3 mins = get_axial_point(i);\n        vec3 maxs = get_axial_point(i+1);\n        vec3 t0 = (mins - campos) * rcp_delta;\n        vec3 t1 = (maxs - campos) * rcp_delta;\n        vec3 tmin = min(t0, t1);\n        vec4 tmax = vec4(max(t0, t1), best_dist);\n        float t_enter = max_component(tmin);\n        float t_exit = min_component(tmax);\n        if (t_exit >= max(t_enter, 0.) && t_enter > znear)\n        {\n            best_dist = t_enter;\n            best_index = i;\n        }\n    }\n#endif \/\/ RENDER_WORLD & 1    \n}\n\nvoid resolve_axial_intersection(vec3 campos, vec3 rcp_delta, inout Intersection result, int best_index)\n{\n    if (best_index == -1)\n        return;\n\n    vec3 mins = get_axial_point(best_index);\n    vec3 maxs = get_axial_point(best_index+1);\n    vec3 t0 = (mins - campos) * rcp_delta;\n    vec3 t1 = (maxs - campos) * rcp_delta;\n    vec3 tmin = min(t0, t1);\n    float t = max_component(tmin);\n    int axis =\n        (t == tmin.x) ? 0 :\n    \t(t == tmin.y) ? 1 :\n    \t2;\n    bool side = rcp_delta[axis] > 0.;\n    int face = (axis << 1) + int(side);\n\n    result.plane\t\t= (best_index + (best_index<<1)) + face;\n    result.material\t\t= get_axial_brush_material(best_index>>1, face);\n    result.normal\t\t= vec3(0);\n    result.normal[axis]\t= side ? -1. : 1.;\n    result.uv_axis\t\t= axis;\n    result.mips\t\t\t= fwidth(float(result.plane)) < 1e-4;\n}\n\nvoid intersect_nonaxial_brushes\n(\n    int brush_begin, int brush_end,\n    vec3 campos, vec3 dir, float znear, \n    inout float best_dist, inout int best_plane\n)\n{\n#if RENDER_WORLD & 2\n    if (brush_begin >= brush_end)\n        return;\n    brush_end = NO_UNROLL(brush_end);\n    for (int i=brush_begin, first_plane=get_nonaxial_brush_start(i), last_plane; i<brush_end; ++i, first_plane=last_plane)\n    {\n       \tlast_plane = get_nonaxial_brush_start(i + 1);\n        int best_brush_plane = -1;\n        float t_enter = -1e6;\n        float t_leave = 1.;\n       \tfor (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_nonaxial_plane(j);\n            float dist = dot(plane.xyz, campos) + plane.w;\n            float align = dot(plane.xyz, dir);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                {\n                    t_enter = 2.;\n                    break;\n                }\n                continue;\n            }\n            dist \/= -align;\n            best_brush_plane = (align < 0. && t_enter < dist) ? j : best_brush_plane;\n            t_enter = (align < 0.) ? max(t_enter, dist) : t_enter;\n            t_leave = (align > 0.) ? min(t_leave, dist) : t_leave;\n            if (t_leave <= t_enter)\n                break;\n        }\n        if (t_leave > max(t_enter, 0.) && t_enter > znear && best_dist > t_enter)\n        {\n            best_plane = best_brush_plane;\n            best_dist = t_enter;\n        }\n    }\n#endif \/\/ RENDER_WORLD & 2\n}\n\nvoid resolve_nonaxial_intersection(inout Intersection result, int best_index)\n{\n    if (best_index == -1)\n        return;\n    \n    vec4 plane = get_nonaxial_plane(best_index);\n    \n    result.normal = plane.xyz;\n    result.uv_axis = dominant_axis(plane.xyz);\n    result.plane = best_index + NUM_MAP_AXIAL_PLANES;\n    result.material = get_plane_material(result.plane);\n\n    \/\/ pixel quad straddling geometric planes? no mipmaps for you!\n    float plane_hash = dot(plane, vec4(17463.12, 25592.53, 15576.84, 19642.77));\n    result.mips = fwidth(plane_hash) < 1e-4;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid intersect_world(vec3 campos, vec3 dir, float znear, inout Intersection result)\n{\n    vec3 inv_world_dir = 1.\/dir;\n    int best_index = -1;\n    \n    \/\/ axial brushes \/\/\n    \n\t#if USE_PARTITION & 1\n    {\n        for (int i=NO_UNROLL(0); i<NUM_AXIAL_NODES; ++i)\n        {\n            Node n = unpack(bvl.axial[i], AXIAL_BVL_MINS);\n            if (ray_vs_aabb(campos, inv_world_dir, result.t, n.mins, n.maxs))\n                intersect_axial_brushes(int(n.begin), int(n.end), campos, inv_world_dir, znear, result.t, best_index);\n        }\n    }\n\t#else\n    {\n    \tintersect_axial_brushes(0, NUM_MAP_AXIAL_BRUSHES, campos, inv_world_dir, znear, result.t, best_index);\n    }\n\t#endif\n    resolve_axial_intersection(campos, inv_world_dir, result, best_index);\n    \n    \/\/ non-axial brushes \/\/\n    \n    best_index = -1;\n\n\t#if USE_PARTITION & 2\n    {\n        for (int i=NO_UNROLL(0); i<NUM_NONAXIAL_NODES; ++i)\n        {\n            Node n = unpack(bvl.nonaxial[i], NONAXIAL_BVL_MINS);\n            if (ray_vs_aabb(campos, inv_world_dir, result.t, n.mins, n.maxs))\n                intersect_nonaxial_brushes(int(n.begin), int(n.end), campos, dir, znear, result.t, best_index);\n        }\n    }\n\t#else\n    {\n    \tintersect_nonaxial_brushes(0, NUM_MAP_NONAXIAL_BRUSHES, campos, dir, znear, result.t, best_index);\n    }\n\t#endif\n    resolve_nonaxial_intersection(result, best_index);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 get_light(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_LIGHTS.xy);\n    addr.x += index;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nvec4 get_lightmap_tile(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_LMAP_TILES.xy);\n    addr.x += index & 127;\n    addr.y += index >> 7;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nint find_tile(vec2 fragCoord, int num_tiles)\n{\n#if BAKE_LIGHTMAP\n    for (int i=NO_UNROLL(0); i<num_tiles; ++i)\n\t\tif (is_inside(fragCoord, get_lightmap_tile(i)) > 0.)\n            return i;\n#endif\n    return -1;\n}\n\nivec2 get_brush_and_side(int plane_index)\n{\n    if (plane_index < NUM_MAP_AXIAL_PLANES)\n        return ivec2(uint(plane_index) \/ 6u, uint(plane_index) % 6u);\n    \n    plane_index -= NUM_MAP_AXIAL_PLANES;\n\t\n    #define TEST(dist) (int((get_nonaxial_brush_start(brush + (dist)) <= plane_index)) * (dist))\n    \n\tint brush = 0;\n    brush  = TEST(NUM_MAP_NONAXIAL_BRUSHES-64);\n    brush += TEST(32);\n    brush += TEST(16);\n    brush += TEST(8);\n    brush += TEST(4);\n    brush += TEST(2);\n    brush += TEST(1);\n\n    #undef TEST\n\n    return ivec2(brush + NUM_MAP_AXIAL_BRUSHES, plane_index - get_nonaxial_brush_start(brush));\n}\n\nfloat find_edge_distance(vec3 p, int brush, int side)\n{\n    float dist = -1e8;\n    \n    if (brush < NUM_MAP_AXIAL_BRUSHES)\n    {\n        vec3[2] deltas;\n        deltas[0] = get_axial_point(brush*2) - p;\n        deltas[1] = p - get_axial_point(brush*2+1);\n        int axis = side >> 1;\n        int front = side & 1;\n        for (int i=0; i<6; ++i)\n            if (i != side)\n            \tdist = max(dist, deltas[1&~i][i>>1]);\n    }\n    else\n    {\n        int begin = get_nonaxial_brush_start(brush - NUM_MAP_AXIAL_BRUSHES);\n        int end = get_nonaxial_brush_start(brush - (NUM_MAP_AXIAL_BRUSHES - 1));\n        for (int i=begin; i<end; ++i)\n        {\n            if (i == begin + side)\n                continue;\n            vec4 plane = get_nonaxial_plane(i);\n            dist = max(dist, dot(p, plane.xyz) + plane.w);\n        }\n    }\n    \n    return dist;\n}\n\nvec2 get_lightmap_offset(int plane_index)\n{\n\tconst int NUM_BITS = 9, MASK = (1 << NUM_BITS) - 1;\n\tint packed_offset = LIGHTMAP_OFFSETS.data[plane_index];\n    return (packed_offset >= 0) ?\n        LIGHTMAP_OFFSET + vec2(packed_offset & MASK, packed_offset >> NUM_BITS) :\n        LIGHTMAP_OFFSET + vec2(-1);\n}\n\nfloat fetch_lightmap_texel(ivec2 addr)\n{\n    addr = clamp(addr, ivec2(0), ivec2(LIGHTMAP_SIZE) - 1);\n    int channel = addr.y & 3;\n    addr.y >>= 2;\n    return decode_lightmap_sample(texelFetch(iChannel1, addr, 0)).values[channel];\n}\n\nfloat sample_lightmap(vec3 camera_pos, vec3 dir, Options options, Intersection result)\n{\n    if (result.uv_axis == 3)\n        return clamp(-dot(result.normal, ENTITY_LIGHT_DIR), ENTITY_MIN_LIGHT, 1.);\n    if (result.plane == -1)\n        return 1.;\n\n    float unmapped_light = is_material_any_of(result.material, MATERIAL_MASK_LIQUID|MATERIAL_MASK_SKY) ? 1. : 0.;\n    vec3 point = camera_pos + dir * result.t;\n    vec2 offset = get_lightmap_offset(result.plane);\n    if (any(lessThan(offset, LIGHTMAP_OFFSET)))\n        return unmapped_light;\n\n    vec2 uv = uv_map_axial(point, result.uv_axis);\n#if LIGHTMAP_FILTER == 1 \/\/ snap to world texels\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tuv = floor(uv) + .5;\n#endif\n    uv = uv \/ LIGHTMAP_SCALE - offset;\n    \n#if LIGHTMAP_FILTER > 0\n    uv -= .5;\n#endif\n    \n    vec2 base = floor(uv);\n    ivec2 addr = ivec2(base);\n    if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y)\n        return unmapped_light;\n    \n    uv -= base;\n#if !LIGHTMAP_FILTER\n    uv = vec2(0);\n#endif\n    \n    float\n        s00 = fetch_lightmap_texel(addr + ivec2(0,0)),\n        s01 = fetch_lightmap_texel(addr + ivec2(0,1)),\n        s10 = fetch_lightmap_texel(addr + ivec2(1,0)),\n        s11 = fetch_lightmap_texel(addr + ivec2(1,1)),\n        light = mix(mix(s00, s01, uv.y), mix(s10, s11, uv.y), uv.x);\n\n#ifdef QUANTIZE_LIGHTMAP\n    const float LEVELS = float(QUANTIZE_LIGHTMAP);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) && g_demo_stage != DEMO_STAGE_LIGHTING)\n        light = floor(light * LEVELS + .5) * (1.\/LEVELS);\n#endif\n    \n    return light;\n}\n\nvec3 lightmap_to_world(vec2 fragCoord, int plane_index)\n{\n    fragCoord += get_lightmap_offset(plane_index);\n    vec4 plane = get_plane(plane_index);\n    return uv_unmap(fragCoord * LIGHTMAP_SCALE, plane) + plane.xyz * LIGHTMAP_HEIGHT_OFFSET;\n}\n\nfloat compute_light_atten(vec4 light, vec3 surface_point, vec3 surface_normal)\n{\n    vec3 light_dir = light.xyz - surface_point;\n\tfloat\n        dist = length(light_dir) * LIGHTMAP_SCALEDIST,\n    \tangle = mix(1., dot(surface_normal, normalize(light_dir)), LIGHTMAP_SCALECOS);\n    return max(0., (light.w - dist) * angle * (LIGHTMAP_RANGESCALE \/ 255.));\n}\n\n\/\/ dynamic lights didn't seem to be taking normals into account\n\/\/ (fireball light showing up on the right wall of the Normal hallway)\nfloat compute_dynamic_light_atten(vec4 light, vec3 surface_point)\n{\n    vec3 light_dir = light.xyz - surface_point;\n    float dist = length(light_dir);\n    float radius = light.w;\n    return clamp(1.-dist\/abs(radius), 0., 1.) * sign(radius);\n}\n\nvec3 simulate_lightmap_distortion(vec3 surface_point)\n{\n    surface_point = floor(surface_point);\n    surface_point *= 1.\/LIGHTMAP_SCALE;\n    vec3 f = fract(surface_point + .5);\n    return (surface_point + f - smoothen(f)) * LIGHTMAP_SCALE;\n}\n\nfloat sample_lighting(vec3 camera_pos, vec3 dir, Options options, Intersection result)\n{\n#if !BAKE_LIGHTMAP\n    return 1.;\n#endif\n\n    Transitions transitions;\n    LOAD(transitions);\n    \n    float lightmap = sample_lightmap(camera_pos, dir, options, result);\n    \n    float dynamic_lighting = 0.;\n    vec3 surface_point = camera_pos + dir * result.t;\n    surface_point = simulate_lightmap_distortion(surface_point);\n    \n    vec3 fireball_offset = get_fireball_offset(g_animTime);\n    vec4 fireball_light = vec4(fireball_offset + FIREBALL_ORIGIN, 150);\n    if (fireball_offset.z > 8.)\n    \tdynamic_lighting += compute_dynamic_light_atten(fireball_light, surface_point);\n    if (transitions.attack > .875)\n        dynamic_lighting += compute_dynamic_light_atten(vec4(camera_pos, 200), surface_point);\n    \n#ifdef QUANTIZE_DYNAMIC_LIGHTS\n    const float LEVELS = float(QUANTIZE_DYNAMIC_LIGHTS);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tdynamic_lighting = floor(dynamic_lighting * LEVELS + .5) * (1.\/LEVELS);\n#endif\n    \n    return lightmap + dynamic_lighting;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 addr = ivec2(fragCoord);\n    \n    vec3 pos, dir, angles;\n    float light_level = -1., znear = 0.;\n    bool is_ground_sample = false;\n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    vec4 plane;\n\n    Lighting lighting;\n    LOAD(lighting);\n    \n    Options options;\n    LOAD(options);\n\n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n    \n    \/\/ initial setup \/\/\n\n    bool baking = iFrame < NUM_LIGHTMAP_FRAMES;\n    if (baking)\n    {\n        if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y\/4u)\n            DISCARD;\n        fragColor = vec4(-1);\n        \n        int region = iFrame & 3;\n        int frame = iFrame >> 2;\n        addr.y += region * int(LIGHTMAP_SIZE.y\/4u);\n        vec2 lightmap_coord = vec2(addr);\n        \n        int plane_index = find_tile(lightmap_coord + .5, lighting.num_tiles);\n        if (plane_index == -1)\n            return;\n        lightmap_coord += hammersley(frame % NUM_LIGHTMAP_SAMPLES, NUM_LIGHTMAP_SAMPLES);\n\n        ivec2 brush_side = get_brush_and_side(plane_index);\n        int brush = brush_side.x;\n        int side = brush_side.y;\n\n        pos = lightmap_to_world(lightmap_coord, plane_index);\n        if (find_edge_distance(pos, brush, side) > LIGHTMAP_SCALE * LIGHTMAP_EXTRAPOLATE)\n            return;\n\n        plane = get_plane(plane_index);\n        znear = -1e8;\n    }\n    else\n    {\n        g_downscale = get_downscale(options);\n        is_ground_sample = all(equal(ivec2(fragCoord), ivec2(iResolution.xy)-1));\n        vec2 actual_res = min(ceil(iResolution.xy \/ g_downscale * .125) * 8., iResolution.xy);\n        if (max_component(fragCoord - .5 - actual_res) > 0. && !is_ground_sample)\n        \tDISCARD;\n\n        vec2 demo_coord = is_ground_sample ?\n            iResolution.xy * vec2(.5, .25) \/ g_downscale :\n        \tfragCoord;\n\n        UPDATE_TIME(lighting);\n        UPDATE_DEMO_STAGE(demo_coord, g_downscale, is_thumbnail);\n\n        pos = load_camera_pos(SETTINGS_CHANNEL, is_thumbnail).xyz;\n        angles = load_camera_angles(SETTINGS_CHANNEL, is_thumbnail).xyz;\n        if (!is_ground_sample)\n        {\n            vec2 uv = (fragCoord * 2. * g_downscale - iResolution.xy) \/ iResolution.x;\n            dir = unproject(uv) * VIEW_DISTANCE;\n            dir = rotate(dir, angles);\n        }\n        else\n        {\n            dir = vec3(0, 0, -VIEW_DISTANCE);\n            angles = vec3(0, -90, 0);\n        }\n    }\n\n    \/\/ render loop \/\/\n    \n    Intersection result;\n    \n#if !BAKE_LIGHTMAP\n    lighting.num_lights = 0;\n#endif\n\n    int num_iter = baking ? lighting.num_lights : 1;\n    for (int i=0; i<num_iter; ++i)\n    {\n        float contrib;\n        if (baking)\n        {\n            vec4 light = get_light(i);\n            contrib = compute_light_atten(light, pos, plane.xyz);\n            if (contrib <= 0.)\n                continue;\n            dir = light.xyz - pos;\n        }\n\n        reset_intersection(result);\n    \tintersect_world(pos, dir, znear, result);\n\n        if (baking)\n        {\n            if (result.t >= 1. || is_material_liquid(result.material))\n                light_level = max(light_level, 0.) + contrib;\n            else if (result.t > 0.)\n                light_level = max(light_level, 0.);\n\t\t}\n    }\n\n    if (!baking && !is_ground_sample)\n\t    intersect_entities(pos, angles, dir, is_thumbnail, result);\n\n    \/\/ output \/\/\n\n    if (baking)\n    {\n        fragColor.rgb = vec3(light_level);\n    }\n    else\n    {\n        if (result.material == -1)\n        {\n            result.t = 1.;\n            result.material = MATERIAL_SKY1;\n            result.normal = vec3(0, 0, -1);\n            result.mips = true;\n        }\n\n        GBuffer g;\n        g.normal\t= result.normal;\n        g.light\t\t= sample_lighting(pos, dir, options, result);\n        g.z\t\t\t= result.t;\n        g.material\t= result.material;\n        g.uv_axis\t= result.uv_axis;\n        g.edge\t\t= !result.mips;\n\n        \/\/ In demo mode, we can have the shotgun model rendered at two different map locations\n        \/\/ at the same time (during the stage transitions). We only take a single lightmap sample\n        \/\/ for the ground point per frame, so to avoid harsh transitions between different light\n        \/\/ levels, we just use a default light value for the weapon model if demo mode is enabled\n        if (is_ground_sample && test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL))\n            g.light\t= .5;\n        \n#if DITHER_ENTITY_NORMALS\n        vec2 noise = result.plane == -1 ? fract(BLUE_NOISE(fragCoord).xy) : vec2(.5);\n#else\n        vec2 noise = vec2(.5);\n#endif\n\n        fragColor = gbuffer_pack(g, noise);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Buffer C:\n\/\/ - lightmap accumulation and post-processing\n\/\/ - UI textures\n\/\/ - font glyphs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ config.cfg \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int TEXTURE_AA = 4;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ALWAYS_REFRESH_TEXTURES\t\t0\n#define DEBUG_TEXT_MASK\t\t\t\t0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int\n    NUM_DILATE_PASSES\t\t\t\t= 1,\n    NUM_BLUR_PASSES\t\t\t\t\t= 0,\n    NUM_POSTPROCESS_PASSES\t\t\t= NUM_DILATE_PASSES + NUM_BLUR_PASSES;\n\n#define USE_DIAGONALS\t\t\t\t0\n\nvoid accumulate(inout LightmapSample total, LightmapSample new)\n{\n    total.values = (total.values*total.weights + new.values*new.weights) \/ max(total.weights + new.weights, 1.);\n    total.weights += new.weights;\n}\n\nvoid accumulate(inout LightmapSample total, vec4 encoded_new)\n{\n    accumulate(total, decode_lightmap_sample(encoded_new));\n}\n\nbool postprocess(inout vec4 fragColor, ivec2 address)\n{\n\tif (iFrame < NUM_LIGHTMAP_FRAMES)\n        return false;\n\n    int pass = iFrame - NUM_LIGHTMAP_FRAMES;\n    bool blur = pass >= NUM_DILATE_PASSES;\n\n    const ivec2 MAX_COORD = ivec2(LIGHTMAP_SIZE.x - 1u, LIGHTMAP_SIZE.y\/4u - 1u);\n    vec4\n        N  = texelFetch(iChannel1, clamp(address + ivec2( 0, 1), ivec2(0), MAX_COORD), 0),\n        S  = texelFetch(iChannel1, clamp(address + ivec2( 0,-1), ivec2(0), MAX_COORD), 0),\n        E  = texelFetch(iChannel1, clamp(address + ivec2( 1, 0), ivec2(0), MAX_COORD), 0),\n        W  = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0),\n        NE = texelFetch(iChannel1, clamp(address + ivec2( 1, 1), ivec2(0), MAX_COORD), 0),\n        SE = texelFetch(iChannel1, clamp(address + ivec2( 1,-1), ivec2(0), MAX_COORD), 0),\n        NW = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0),\n        SW = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0);\n\n    N  = vec4(fragColor.yzw, N.x);\n    NE = vec4(E.yzw, NE.x);\n    NW = vec4(W.yzw, NW.x);\n    S  = vec4(S .w, fragColor.xyz);\n    SE = vec4(SE.w, E.xyz);\n    SW = vec4(SW.w, W.xyz);\n\n    LightmapSample\n        current = decode_lightmap_sample(fragColor),\n        total = empty_lightmap_sample();\n\n    accumulate(total, N);\n    accumulate(total, S);\n    accumulate(total, E);\n    accumulate(total, W);\n#if USE_DIAGONALS\n    accumulate(total, NE);\n    accumulate(total, NW);\n    accumulate(total, SE);\n    accumulate(total, SW);\n#endif\n\n    if (blur)\n    {\n        accumulate(total, current);\n\t    fragColor = encode(total);\n    }\n    else\n    {\n        vec4 neighbors = encode(total);\n        fragColor = mix(fragColor, neighbors, lessThanEqual(current.weights, vec4(0)));\n    }\n    \n    return true;\n}\n\nvoid accumulate_lightmap(inout vec4 fragColor, ivec2 address)\n{\n    if (uint(address.x) >= LIGHTMAP_SIZE.x || uint(address.y) >= LIGHTMAP_SIZE.y\/4u)\n        return;\n    if (iFrame >= NUM_LIGHTMAP_FRAMES + NUM_POSTPROCESS_PASSES)\n        return;\n\n    if (postprocess(fragColor, address))\n        return;\n    \n    int region = iFrame & 3;\n    int base_y = region * int(LIGHTMAP_SIZE.y\/16u);\n    if (uint(address.y - base_y) >= LIGHTMAP_SIZE.y\/16u)\n        return;\n\n    address.y = (address.y - base_y) * 4;\n    vec4 light = vec4\n        (\n            texelFetch(iChannel0, address + ivec2(0,0), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,1), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,2), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,3), 0).x\n\t\t);\n\n    vec4 weights = step(vec4(0), light);\n    vec4 values = max(light, 0.);\n    \n    LightmapSample total = decode_lightmap_sample(fragColor);\n    accumulate(total, LightmapSample(weights, values));\n    fragColor = encode(total);\n}\n\n\/\/ Options text \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_Options(vec2 p)\n{\n    const float\n        OFFSET_P = 15.,\n        OFFSET_T = 35.,\n        OFFSET_I = 53.,\n        OFFSET_O = 63.,\n        OFFSET_N = 81.,\n        OFFSET_S = 98.;\n\n    vec4 box = vec4(0);\n    vec3 disk1 = vec3(0), disk2 = vec3(0,0,1), disk3 = vec3(0,0,2);\n    float vline_x = 1e3, vline_thickness = 2.5;\n    float max_ydist = 6.;\n    \n    p.x -= 15.;\n    \n\t#define MIRROR(compare, midpoint, value) (compare <= midpoint ? value : midpoint*2.-value)\n    \n    if (p.x <= 20.)\n    {\n    \tmax_ydist = 7.;\n        disk1 = vec3(MIRROR(p.x, 8.5, 7.5), 11.5, 8.);\n        disk2 = vec3(MIRROR(p.x, 8.5, 12.), 11.5, 9.);\n    }\n    else if (p.x <= OFFSET_T)\n    {\n        p.x -= OFFSET_P;\n        vline_x = 9.;\n        disk1 = vec3(14.5, 13.5, 4.);\n        disk2 = vec3(10.5, 13.5, 5.);\n    }\n    else if (p.x <= OFFSET_I)\n    {\n        const float\n            BOX_X = 4., BOX_Y = 15.5, BOX_SIZE = 1.5,\n            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y-BOX_SIZE, R3 = BOX_SIZE * 2.;\n        \n        p.x -= OFFSET_T;\n        disk3 = vec3(MIRROR(p.x, 9., X3), Y3, R3);\n        box   = vec4(MIRROR(p.x, 9., BOX_X), BOX_Y, BOX_SIZE, BOX_SIZE);\n        vline_x = 9.;\n    }\n    else if (p.x <= OFFSET_O)\n    {\n        vline_x = OFFSET_I + 4.5;\n    }\n    else if (p.x <= OFFSET_N)\n    {\n        p.x -= OFFSET_O;\n        disk1 = vec3(MIRROR(p.x, 9., 8.), 11.5, 7.);\n        disk2 = vec3(MIRROR(p.x, 9., 12.), 11.5, 8.);\n    }\n    else if (p.x <= OFFSET_S)\n    {\n        p.x -= OFFSET_N;\n        vline_x = p.x < 9. ? 4.5 : 15.;\n        vline_thickness = 2.;\n        box = vec4(clamp(p.x, 5., 14.) * vec2(1, -.75) + vec2(0, 18), 1., 2.);\n    }\n    else\n    {\n        const float\n            X1 = 8., Y1 = 14., R1 = 3.5,\n            X2 = 9.5, Y2 = 15.5, R2 = 2.5,\n            BOX_X = 6., BOX_Y = 7., BOX_SIZE = 1.5,\n            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y+BOX_SIZE, R3 = BOX_SIZE * 2.;\n        \n        p.x -= OFFSET_S;\n        \/\/ TODO: simplify\n        if (p.x < 9.)\n        {\n            disk1 = vec3(X1, Y1, R1);\n            disk2 = vec3(X2, Y2, R2);\n            disk3 = vec3(X3, Y3, R3);\n            box   = vec4(BOX_X, BOX_Y, BOX_SIZE, BOX_SIZE);\n        }\n        else\n        {\n            disk1 = vec3(18. - X1, 23. - Y1, R1);\n            disk2 = vec3(18. - X2, 23. - Y2, R2);\n            disk3 = vec3(18. - X3, 23. - Y3, R3);\n            box   = vec4(18. - BOX_X, 23. - BOX_Y, BOX_SIZE, BOX_SIZE);\n        }\n    }\n    \n    #undef MIRROR\n    \n    float dist;\n    dist = sdf_disk(p, disk1.xy, disk1.z);\n    dist = sdf_exclude(dist, sdf_disk(p, disk2.xy, disk2.z));\n    \n    dist = sdf_union(dist, sdf_seriffed_box(p, vec2(vline_x, 5.5), vec2(vline_thickness, 12.), vec2(1,.2), vec2(1,.2)));\n                       \n\tfloat d2 = sdf_centered_box(p, box.xy, box.zw);\n    d2 = sdf_exclude(d2, sdf_disk(p, disk3.xy, disk3.z));\n    dist = sdf_union(dist, d2);\n    dist = sdf_exclude(dist, max_ydist - abs(p.y - 11.5));\n   \n    return dist;\n}\n\nvec2 engraved_Options(vec2 uv)\n{\n    const float EPS = .1, BEVEL_SIZE = 1.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_Options(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1.);\n    float bevel = clamp(1. + sdf.z\/BEVEL_SIZE, 0., 1.);\n    float intensity = .4 + sqr(bevel) * dot(gradient, vec2(0, -1.1));\n    intensity = mix(1.5, intensity, mask);\n    mask = sdf_mask(sdf.z - 1., 1.);\n    return vec2(intensity, mask);\n}\n\n\/\/ QUAKE text \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sdf_QUAKE(vec2 uv)\n{\n    uv \/= 28.;\n    uv.y -= 4.;\n    uv.x -= .0625;\n    \n    float sdf\t\t\t\t\t\t   = sdf_Q_top(uv);\n    uv.y += .875;   sdf = sdf_union(sdf, sdf_U(uv));\n    uv.y += .75;\tsdf = sdf_union(sdf, sdf_A(uv));\n    uv.y += .75;\tsdf = sdf_union(sdf, sdf_K(uv - vec2(.2, 0)));\n    uv.y += .8125;\tsdf = sdf_union(sdf, sdf_E(uv));\n    \n    sdf *= 28.;\n    uv += sin(uv.yx * TAU) * (5.\/28.);\n    sdf = sdf_union(sdf, 28. * (.75 - around(.3, .25, smooth_weyl_noise(2. + uv * 3.24))));\n    return sdf_exclude(sdf, (uv.y - .15) * 28.);\n}\n\nvec2 engraved_QUAKE(vec2 uv)\n{\n    const float EPS = .1, BEVEL_SIZE = 2.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_QUAKE(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1.);\n    float bevel = clamp(1. + sdf.z\/BEVEL_SIZE, 0., 1.);\n    float intensity = .75 + sqr(bevel) * dot(gradient, vec2(0, -3));\n    intensity = mix(1.5, intensity, mask);\n    mask = sdf_mask(sdf.z - 1., 1.);\n    return vec2(intensity, mask * .7);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid generate_ui_textures(inout vec4 fragColor, vec2 fragCoord)\n{\n#if !ALWAYS_REFRESH_TEXTURES\n    if (iFrame != 0)\n        return;\n#endif\n    \n    const int\n\t\tUI_TEXTURE_OPTIONS\t\t= 0,\n\t\tUI_TEXTURE_QUAKE_ID\t\t= 1,\n        AA_SAMPLES\t\t\t\t= clamp(TEXTURE_AA, 1, 128);\n    int id = -1;\n\n    vec2 texture_size, bevel_range;\n    vec3 base_color;\n    \n    if (is_inside(fragCoord, ADDR2_RANGE_TEX_OPTIONS) > 0.)\n    {\n        id = UI_TEXTURE_OPTIONS;\n        fragCoord -= ADDR2_RANGE_TEX_OPTIONS.xy;\n        texture_size = ADDR2_RANGE_TEX_OPTIONS.zw;\n        bevel_range = vec2(1.7, 3.9);\n        base_color = vec3(.32, .21, .13);\n    }\n\n    if (is_inside(fragCoord, ADDR2_RANGE_TEX_QUAKE) > 0.)\n    {\n        id = UI_TEXTURE_QUAKE_ID;\n        fragCoord -= ADDR2_RANGE_TEX_QUAKE.xy;\n        fragCoord = fragCoord.yx;\n        texture_size = ADDR2_RANGE_TEX_QUAKE.wz;\n        bevel_range = vec2(2.7, 4.9);\n        base_color = vec3(.16, .12, .07);\n    }\n    \n    if (id == -1)\n        return;\n\n    vec2 base_coord = floor(fragCoord);\n    float grain = random(base_coord);\n\n    vec3 accum = vec3(0);\n    for (int i=NO_UNROLL(0); i<AA_SAMPLES; ++i)\n    {\n        fragCoord = base_coord + hammersley(i, AA_SAMPLES);\n        vec2 uv = fragCoord \/ min_component(texture_size);\n\n        float base = weyl_turb(3.5 + uv * 3.1, .7, 1.83);\n        if (id == UI_TEXTURE_QUAKE_ID && fragCoord.y < 26. + base * 4. && fragCoord.y > 3. - base * 2.)\n        {\n            base = mix(base, grain, .0625);\n            fragColor.rgb = vec3(.62, .30, .19) * linear_step(.375, .85, base);\n            vec2 logo_uv = (uv - .5) * vec2(1.05, 1.5) + .5;\n            logo_uv.y += .0625;\n            float logo_sdf = sdf_id(logo_uv);\n            float logo = sdf_mask(logo_sdf + .25\/44., 1.5\/44.);\n            fragColor.rgb *= 1. - sdf_mask(logo_sdf - 2.\/44., 1.5\/44.);\n            fragColor.rgb = mix(fragColor.rgb, vec3(.68, .39, .17) * mix(.5, 1.25, base), logo);\n        }\n        else\n        {\n            base = mix(base, grain, .3);\n            fragColor.rgb = base_color * mix(.75, 1.25, smoothen(base));\n        }\n\n        float bevel_size = mix(bevel_range.x, bevel_range.y, smooth_weyl_noise(uv * 9.));\n        vec2 mins = vec2(bevel_size), maxs = texture_size - bevel_size;\n        vec2 duv = (fragCoord - clamp(fragCoord, mins, maxs)) * (1.\/bevel_size);\n        float d = mix(length(duv), max_component(abs(duv)), .75);\n        fragColor.rgb *= clamp(1.4 - d*mix(1., 1.75, sqr(base)), 0., 1.);\n        float highlight = \n            (id == UI_TEXTURE_OPTIONS) ?\n            \tmax(0., duv.y) * step(d, .55) :\n        \t\tsqr(sqr(1. + duv.y)) * around(.4, .4, d) * .35;\n        fragColor.rgb *= 1. + mix(.75, 2.25, base) * highlight;\n\n        if (DEBUG_TEXT_MASK != 0)\n        {\n            float sdf = (id == UI_TEXTURE_OPTIONS) ? sdf_Options(fragCoord) : sdf_QUAKE(fragCoord);\n            fragColor.rgb = vec3(sdf_mask(sdf, 1.));\n            accum += fragColor.rgb;\n            continue;\n        }\n\n        vec2 engrave = (id == UI_TEXTURE_OPTIONS) ? engraved_Options(fragCoord) : engraved_QUAKE(fragCoord);\n        fragColor.rgb *= mix(1., engrave.x, engrave.y);\n\n        if (id == UI_TEXTURE_OPTIONS)\n        {\n            vec2 side = sign(fragCoord - texture_size * .5); \/\/ keep track of side before folding to 'unmirror' light direction\n            fragCoord = min(fragCoord, texture_size - fragCoord);\n            vec2 nail = add_knob(fragCoord, 1., vec2(6), 1.25, side * vec2(0, -1));\n            fragColor.rgb *= mix(clamp(length(fragCoord - vec2(6, 6.+2.*side.y))\/2.5, 0., 1.), 1., .25);\n            nail.x += pow(abs(nail.x), 16.) * .25;\n            fragColor.rgb = mix(fragColor.rgb, vec3(.7, .54, .43) * nail.x, nail.y * .75);\n        }\n\n        accum += fragColor.rgb;\n    }\n    fragColor.rgb = accum * (1.\/float(AA_SAMPLES));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int NUM_GLYPHS = 56;\n\nWRAP(FontBitmap,FONT_BITMAP,int,NUM_GLYPHS*2)(0,0,0x7c2c3810,25190,0x663e663e,15974,0x606467c,31814,0x6666663e,15974,0x61e467e,\n31814,0x61e467c,1542,0x7303233e,1062451,0x637f6363,25443,404232216,6168,808464432,792624,991638339,17251,0x6060606,32326,\n0x6f7f7763,26989,0x5f4f4743,6320505,0x6363633e,15971,0x6666663e,1598,0x6b436322,526398,0x663e663e,17990,0x603c067c,15970,\n404249214,530456,0x66666666,15462,0x3e367763,2076,0x7f7b5b5b,8758,941379271,58230,0xc1c3462,3084,473461374,32334,0x66663c00,\n15462,404233216,6168,0x7c403e00,32258,945831424,536672,909651968,12415,0x3c043c00,536672,0x3e061c00,15462,541097472,12336,\n0x3c663c00,15462,0x7c663c00,536672,0x7e181800,6168,63<<25,0,0xc183060,774,0,1542,0,198150,1579008,6168,404232216,6144,406347838,\n6144,0x3f3f3f3f,16191,0xc0c1830,3151884,808458252,792624,0,32256,0xc0c0c3c,15372,808464444,15408,0xc183000,6303768,806882304,\n396312,0x83e7f7f,8355646,0x7f7f3e1c,67640382,0x3f3f0f03,783));\n\nint glyph_bit(uint glyph, int index)\n{\n    if (glyph >= uint(NUM_GLYPHS))\n        return 0;\n    uint data = uint(FONT_BITMAP.data[(glyph<<1) + uint(index>=32)]);\n    return int(uint(data >> (index & 31)) & 1u);\n}\n\nvec4 glyph_color(uint glyph, ivec2 pixel, float variation)\n{\n    pixel &= 7;\n    pixel.y = 7 - pixel.y;\n    int bit_index = pixel.x + (pixel.y << 3);\n    int bit = glyph_bit(glyph, bit_index);\n    int shadow_bit = min(pixel.x, pixel.y) > 0 ? glyph_bit(glyph, bit_index - 9) : 0;\n    return vec4(vec3(bit > 0 ? variation : .1875), float(bit|shadow_bit));\n}\n\nvoid bake_font(inout vec4 fragColor, vec2 fragCoord)\n{\n#if !ALWAYS_REFRESH_TEXTURES\n    if (iFrame != 0)\n        return;\n#endif\n\n    ivec2 addr = ivec2(floor(fragCoord - ADDR2_RANGE_FONT.xy));\n    if (any(greaterThanEqual(uvec2(addr), uvec2(ADDR2_RANGE_FONT.zw))))\n        return;\n    \n    const int GLYPHS_PER_LINE = int(ADDR2_RANGE_FONT.z) >> 3;\n    \n    int glyph = (addr.y >> 3) * GLYPHS_PER_LINE + (addr.x >> 3);\n    float variation = mix(.625, 1., random(fragCoord));\n    fragColor = glyph_color(uint(glyph), addr, variation);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (is_inside(fragCoord, ADDR2_RANGE_PARAM_BOUNDS) < 0.)\n        DISCARD;\n\n    ivec2 address = ivec2(fragCoord);\n    fragColor = (iFrame == 0) ? vec4(0) : texelFetch(iChannel1, address, 0);\n    \n    accumulate_lightmap\t\t(fragColor, address);\n    generate_ui_textures\t(fragColor, fragCoord);\n    bake_font\t\t\t\t(fragColor, fragCoord);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Buffer D:\n\/\/ - UV\/texture mapping\n\/\/ - particles (fireball trail, shotgun pellets, teleporter effect)\n\/\/ - volumetric light shafts\n\/\/ - demo mode stages\n\/\/ - GBuffer debug vis\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ config.cfg \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define TEXTURE_FILTER\t\t\t\t1\t\t\/\/ [0=nearest; 1=linear]\n#define USE_MIPMAPS\t\t\t\t\t2\t\t\/\/ [0=off; 1=derivative-based; 2=depth+slope]\n#define LOD_SLOPE_SCALE\t\t\t\t0.9\t\t\/\/ [0.0=authentic\/sharp\/aliased - 1.0=smooth]\n#define LOD_BIAS\t\t\t\t\t0.0\n#define LOD_DITHER\t\t\t\t\t0.0\t\t\/\/ 1.0=discount linear mip filtering\n\n\/\/ I know, mixing my Marvel and my DC here...\n\/\/ Note: if you enable UV dithering, make sure to also\n\/\/ comment out QUANTIZE_SCENE below\n\/\/ and set LIGHTMAP_FILTER to 2 in Buffer B\n#define USE_UV_DITHERING\t\t\t0\n#define UV_DITHER_STRENGTH\t\t\t1.00\n\n#define QUANTIZE_SCENE\t\t\t\t48\t\t\/\/ comment out to disable\n\n#define RENDER_PARTICLES\t\t\t1\n#define CULL_PARTICLES\t\t\t\t1\n\n#define RENDER_VOLUMETRICS\t\t\t1\n#define RENDER_WINDOW_PROJECTION\t1\n#define VOLUMETRIC_STRENGTH\t\t\t0.125\n#define VOLUMETRIC_SAMPLES\t\t\t8\t\t\/\/ 4=low..8=medium..16=high\n#define VOLUMETRIC_MASK_LOD\t\t\t1\n#define VOLUMETRIC_FALLOFF\t\t\t400.\t\/\/ comment out to disable\n#define VOLUMETRIC_SOFT_EDGE\t\t64.\t\t\/\/ comment out to disable\n#define VOLUMETRIC_SUN_DIR\t\t\tvec3(8, -2, -3)\n#define VOLUMETRIC_PLAYER_SHADOW\t2\t\t\/\/ [0=off; 1=capsule; 2=capsule+sphere]\n#define VOLUMETRIC_ANIM\t\t\t\t1\n#define WINDOW_PROJECTION_STRENGTH\t64.\n\n#define DEBUG_DEPTH\t\t\t\t\t0\n#define DEBUG_NORMALS\t\t\t\t0\n#define DEBUG_TEXTURES\t\t\t\t0\t\t\/\/ aka fullbright mode\n#define DEBUG_MIPMAPS\t\t\t\t0\n#define DEBUG_LIGHTING\t\t\t\t0\n#define DEBUG_PARTICLE_CULLING\t\t0\n#define DEBUG_VOLUMETRICS\t\t\t0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Implementation \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define NOISE_CHANNEL\t\t\t\tiChannel1\n#define SETTINGS_CHANNEL\t\t\tiChannel3\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n\/\/ Texturing \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 uv_map_axial(vec3 pos, int axis)\n{\n    return (axis==0) ? pos.yz : (axis==1) ? pos.xz : pos.xy;\n}\n\nvec2 tri(vec2 x)\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nvec3 rainbow(float hue)\n{\n    return clamp(vec3(min(hue, 1.-hue), abs(hue-1.\/3.), abs(hue-2.\/3.))*-6.+2., 0., 1.);\n}\n\nvec4 get_balloon_color(const int material, const float current_level)\n{\n    vec4 color = vec4(vec3(.25),.35);\n    float hue = float(material-BASE_TARGET_MATERIAL)*(1.\/float(NUM_TARGETS));\n    hue = fract(hue + current_level * 1.\/6.);\n    color.rgb += rainbow(hue) * .5;\n    return color;\n}\n\n\/\/ iq: https:\/\/iquilezles.org\/articles\/checkerfiltering\nfloat checkersGrad(vec2 uv, vec2 ddx, vec2 ddy)\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 1e-4;    \/\/ filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))\/w;   \/\/ analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   \/\/ xor pattern\n}\n\nstruct SamplerState\n{\n    vec4 tile;\n    float atlas_scale;\n    int flags;\n};\n\nvec4 texture_lod(SamplerState state, vec2 uv, int lod)\n{\n    float texel_scale = state.atlas_scale * exp2i(-lod);\n    bool use_filter = test_flag(state.flags, OPTION_FLAG_TEXTURE_FILTER);\n\tif (use_filter)\n    \tuv += -.5 \/ texel_scale;\n    \n    uv = fract(uv \/ state.tile.zw);\n    state.tile *= texel_scale;\n    uv *= state.tile.zw;\n  \n    vec2 mip_base = mip_offset(lod) * ATLAS_SIZE * state.atlas_scale + state.tile.xy + ATLAS_OFFSET;\n\n    if (use_filter)\n    {\n        ivec4 address = ivec2(mip_base + uv).xyxy;\n        address.zw++;\n        if (uv.x >= state.tile.z - 1.) address.z -= int(state.tile.z);\n        if (uv.y >= state.tile.w - 1.) address.w -= int(state.tile.w);\n\n        vec4 s00 = gamma_to_linear(texelFetch(iChannel3, address.xy, 0));\n        vec4 s10 = gamma_to_linear(texelFetch(iChannel3, address.zy, 0));\n        vec4 s01 = gamma_to_linear(texelFetch(iChannel3, address.xw, 0));\n        vec4 s11 = gamma_to_linear(texelFetch(iChannel3, address.zw, 0));\n\n        uv = fract(uv);\n        return linear_to_gamma(mix(mix(s00, s10, uv.x), mix(s01, s11, uv.x), uv.y));\n    }\n    else\n    {\n        return texelFetch(iChannel3,  ivec2(mip_base + uv), 0);\n    }\n}\n\nvec4 sample_tile(GBuffer gbuffer, vec2 uv, float depth, float alignment, int flags, vec2 noise)\n{\n    int material = gbuffer.material;\n    \n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    \n#if USE_MIPMAPS\n    int max_lod = clamp(int(round(atlas_info.x)) - 1, 0, MAX_MIP_LEVEL - int(atlas_lod));\n    float lod_bias = LOD_BIAS - atlas_lod;\n    lod_bias += LOD_DITHER * (noise.y - .5);\n\n    #if USE_MIPMAPS >= 2\n    \tfloat deriv = depth*VIEW_DISTANCE * FOV_FACTOR * g_downscale \/ (iResolution[FOV_AXIS]*.5 * alignment);\n\t#else\n    \tfloat deriv = max(fwidth(uv.x), fwidth(uv.y));\n    \tif (gbuffer.edge)\n    \t\tmax_lod = int(max(LOD_BIAS, atlas_lod));\n\t#endif\n\n    int lod = int(floor(log2(max(1., deriv)) + lod_bias));\n    lod = clamp(lod, 0, max_lod);\n#else\n    const int lod = 0;\n#endif \/\/ USE_MIPMAPS\n    \/\/lod = 0;\n    \n#if USE_UV_DITHERING\n    if (!test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tuv += (noise - .5) * UV_DITHER_STRENGTH * exp2(float(lod)+atlas_lod);\n#endif\n    \n#if DEBUG_MIPMAPS\n\treturn vec4(vec3(float(lod)\/6.), 0.);\n#endif\n    \n    return texture_lod(SamplerState(get_tile(material), atlas_scale, flags), uv, lod);\n}\n\nvec4 apply_material(GBuffer gbuffer, vec3 surface_point, vec3 surface_normal, vec3 eye_dir, float depth, int flags, vec2 noise)\n{\n    int material = gbuffer.material;\n    int on_edge = int(gbuffer.edge);\n    int axis = gbuffer.uv_axis;\n    \n    if (material == MATERIAL_SHOTGUN_FLASH)\n        material = MATERIAL_FLAME;\n\n    GameState game_state;\n    LOAD(game_state);\n    if (is_material_balloon(material))\n    {\n        vec4 color = get_balloon_color(material, floor(abs(game_state.level)));\n        if (game_state.level < 0.)\n        {\n            float fraction = linear_step(0., BALLOON_SCALEIN_TIME*.1, fract(-game_state.level));\n            color.rgb = mix(vec3(.25), color.rgb, sqr(fraction));\n        }\n        return color;\n    }\n    \n    if (is_material_viewmodel(material))\n    {\n        const vec4 SHOTGUN_COLORS[NUM_SHOTGUN_MATERIALS] = vec4[](vec4(.25,.18,.12,.5), vec4(.0,.0,.0,.5), vec4(0));\n        vec4 color = SHOTGUN_COLORS[min(material - NUM_MATERIALS, NUM_SHOTGUN_MATERIALS)];\n        float light = clamp(dot(vec2(abs(surface_normal.y), surface_normal.z), normalize(vec2(1, 8))), 0., 1.);\n        vec2 uv = surface_point.xy * 8.;\n#if USE_UV_DITHERING\n        uv += (noise - .5) * UV_DITHER_STRENGTH;\n#endif\n        color.rgb *= .125 + .875*light;\n        if (material == MATERIAL_SHOTGUN_BARREL)\n        {\n            color.rgb = mix(vec3(.14,.11,.06), color.rgb, sqr(sqr(light)));\n            color.rgb = mix(color.rgb, vec3(.2,.2,.25), around(.87, .17, light));\n            float specular = pow(light, 16.) * .75;\n            color.rgb += specular;\n        }\n        else\n        {\n        \tlight = clamp(dot(surface_normal.yz, normalize(vec2(-1, 1))), 0., 1.);\n            float highlight = pow(light, 4.) * .125;\n            color.rgb *= 1. + highlight;\n        }\n        if (!test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n            uv = round(uv);\n        float variation = mix(1., .83, smooth_noise(uv));\n        return vec4(color.rgb * variation, color.a);\n    }\n    \n    \/\/ brief lightning flash when shooting the sky to start a new game\n    const float LIGHTNING_DURATION = .125;\n    bool lightning =\n        game_state.level <= 1.+.1*LEVEL_WARMUP_TIME &&\n        game_state.level >= 1.+.1*(LEVEL_WARMUP_TIME - LIGHTNING_DURATION);\n    \n#if USE_MIPMAPS >= 2\n    float alignment = abs(dot(normalize(eye_dir), surface_normal));\n    alignment = mix(1., alignment, LOD_SLOPE_SCALE);\n#else\n    float alignment = 1.;\n#endif\n    \n    vec2 sample_uv[3];\n    int material2 = material;\n    int num_uvs;\n    \n    if (material == MATERIAL_SKY1)\n    {\n    \t\/\/ ellipsoidal mapping for the sky\n        const float SKY_FLATTEN = 4.;\n        sample_uv[0] = 512. * normalize(eye_dir*vec3(1.,1.,SKY_FLATTEN)).xy;\n        sample_uv[1] = rotate(sample_uv[0] + g_animTime * 24., 30.);\n        sample_uv[0] += g_animTime * 12.;\n        material2 = MATERIAL_SKY1B;\n        \n        num_uvs = 2;\n        depth = 0.;\n        alignment = 1.;\n    }\n    else if (axis != 3)\n    {\n        \/\/ world brushes, project using dominant axis\n        sample_uv[0] = uv_map_axial(surface_point, axis);\n        if (is_material_liquid(material))\n            sample_uv[0] += sin(g_animTime + sample_uv[0].yx * (1.\/32.)) * 12.;\n        num_uvs = 1;\n    }\n    else\n    {\n    \t\/\/ triplanar mapping (for entities)\n        const float SCALE = 2.; \/\/ higher res\n        vec3 uvw = surface_point * SCALE;\n        vec2 uv_bias = vec2(0);\n        if (material == MATERIAL_FLAME)\n        {\n        \tfloat loop = floor(g_animTime * 10.) * .1;\n        \tuv_bias.y = -fract(loop) * 64.;\n        }\n        \n        sample_uv[0] = uvw.xy + uv_bias;\n        sample_uv[1] = uvw.yz + uv_bias;\n        sample_uv[2] = uvw.xz + uv_bias;\n        num_uvs = 3;\n        depth *= SCALE;\n    }\n    \n    vec4 colors[3];\n    gbuffer.material = material;\n    colors[0] = sample_tile(gbuffer, sample_uv[0], depth, alignment, flags, noise);\n    \n    gbuffer.material = material2;\n    if (num_uvs >= 2)\n    \tcolors[1] = sample_tile(gbuffer, sample_uv[1], depth, alignment, flags, noise);\n    \n    gbuffer.material = material;\n    if (num_uvs >= 3)\n    \tcolors[2] = sample_tile(gbuffer, sample_uv[2], depth, alignment, flags, noise);\n    \n    vec4 textured;\n    if (material == MATERIAL_SKY1)\n    {\n        \/\/textured = (dot(colors[1].rgb, vec3(1)) + noise.y*.1 < .45) ? colors[0] : colors[1];\n        textured = mix(colors[0], colors[1], linear_step(.35, .45, dot(colors[1].rgb, vec3(1))));\n        textured.rgb *= mix(1., 2., lightning);\n    }\n    else if (axis != 3)\n    {\n        textured = colors[0];\n    }\n\telse\n    {\n        vec3 axis_weights = abs(surface_normal);\n        axis_weights *= 1. \/ (axis_weights.x + axis_weights.y + axis_weights.z);\n\n        textured =\n            colors[0] * axis_weights.z +\n            colors[1] * axis_weights.x +\n            colors[2] * axis_weights.y ;\n    }\n    \n    \/\/ disable AO and reduce shadowing during flash\n    textured.a = mix(textured.a, min(textured.a, .35), lightning);\n    \n    return textured;\n}\n\n\/\/ Fireball particle trail \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid add_to_aabb(inout vec3 min_point, inout vec3 max_point, vec3 point)\n{\n    min_point = min(min_point, point);\n    max_point = max(max_point, point);\n}\n\nvoid get_fireball_bounds\n(\n    const Fireball fireball,\n    const vec3 camera_pos, const mat3 view_matrix,\n    float zslack,\n    out vec3 mins, out vec3 maxs\n)\n{\n    float apex_time = fireball.velocity.z * (1.\/GRAVITY);\n    vec3 apex;\n    apex.z = sqr(fireball.velocity.z) * (.5\/GRAVITY);\n    apex.xy = fireball.velocity.xy * apex_time;\n    \n    vec3 pos = FIREBALL_ORIGIN - camera_pos;\n    mins = maxs = project(pos * view_matrix);\n    \n    vec3 p;\n    p = (pos + vec3(fireball.velocity.xy * (apex_time*2.), 0.));\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n\n    p = pos + fireball.velocity * fireball.velocity.z * (.5\/GRAVITY);\n    p.z += zslack;\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n    \n    p = mix(p, pos + vec3(apex.xy, apex.z+zslack), 2.);\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n}\n\nvoid add_teleporter_effect(inout vec4 fragColor, vec2 fragCoordNDC, vec3 camera_pos, float teleport_time)\n{\n    if (teleport_time <= 0.)\n        return;\n    \n    const float TELEPORT_EFFECT_DURATION = .25;\n\n    \/\/ at 144 FPS the trajectories are too obvious\/distracting\n    const float TELEPORT_EFFECT_FPS = 60.;\n    float fraction = floor((iTime - teleport_time)*TELEPORT_EFFECT_FPS+.5) * (1.\/TELEPORT_EFFECT_FPS);\n    \n    if (fraction >= TELEPORT_EFFECT_DURATION)\n        return;\n    fraction = fraction * (1.\/TELEPORT_EFFECT_DURATION);\n\n    const int PARTICLE_COUNT = 96;\n    const float MARGIN = .125;\n    const float particle_radius = 12.\/1080.;\n    float aspect = min_component(iResolution.xy) \/ max_component(iResolution.xy);\n    float pos_bias = (-1. + MARGIN) * aspect;\n    float pos_scale = pos_bias * -2.;\n\n    \/\/ this vignette makes the transition stand out a bit more using just visuals\n    \/\/ Quake didn't have it, but Quake had sound effects...\n    float vignette = clamp(length(fragCoordNDC*.5), 0., 1.);\n    fragColor.rgb *= 1. - vignette*(1.-fraction);\n\n    int num_particles = NO_UNROLL(PARTICLE_COUNT);\n    for (int i=0; i<num_particles; ++i) \/\/ ugh... :(\n    {\n        vec4 hash = hash4(teleport_time*13.37 + float(i));\n        float speed = mix(1.5, 2., hash.z);\n        float angle = hash.w * TAU;\n        float intensity = mix(.25, 1., fract(float(i)*PHI + .1337));\n        vec2 direction = vec2(cos(angle), sin(angle));\n        vec2 pos = hash.xy * pos_scale + pos_bias;\n        pos += (fraction * speed) * direction;\n        pos -= fragCoordNDC;\n        float inside = step(max(abs(pos.x), abs(pos.y)), particle_radius);\n        if (inside > 0.)\n            fragColor = vec4(vec3(intensity), 0.);\n    }\n}\n\nvoid add_particles\n(\n    inout vec4 fragColor, vec2 fragCoordNDC,\n    vec3 camera_pos, mat3 view_matrix, float depth,\n    float attack, float teleport_time\n)\n{\n#if RENDER_PARTICLES\n    const float\n        WORLD_RADIUS\t\t= 1.5,\n    \tMIN_PIXEL_RADIUS\t= 2.,\n    \tSPAWN_INTERVAL\t\t= .1,\n    \tLIFESPAN\t\t\t= 1.,\n    \tLIFESPAN_VARIATION\t= .5,\n    \tMAX_GENERATIONS\t\t= ceil(LIFESPAN \/ SPAWN_INTERVAL),\n    \tBUNCH\t\t\t\t= 4.,\n        ATTACK_FADE_START\t= .85,\n        ATTACK_FADE_END\t\t= .5,\n        PELLET_WORLD_RADIUS\t= .5;\n    const vec3 SPREAD\t\t= vec3(3, 3, 12);\n    \n    add_teleporter_effect(fragColor, fragCoordNDC, camera_pos, teleport_time);\n    \n    float depth_scale = MIN_PIXEL_RADIUS * g_downscale\/iResolution.x;\n    depth *= VIEW_DISTANCE;\n    \n    \/\/ shotgun pellets \/\/\n    if (attack > ATTACK_FADE_END)\n    {\n        \/\/ Game stage advances immediately after the last balloon is popped.\n        \/\/ When we detect a warmup phase (fractional value for game stage)\n        \/\/ we have to use the previous stage for coloring the particles.\n\n        vec4 game_state = load(ADDR_GAME_STATE);\n        float level = floor(abs(game_state.x));\n        if (game_state.x != level && game_state.x > 0.)\n            --level;\n\n        float fade = sqrt(linear_step(ATTACK_FADE_START, ATTACK_FADE_END, attack));\n        vec3 base_pos = camera_pos;\n        base_pos.z += (1. - attack) * 8.;\n\n        float num_pellets = ADDR_RANGE_SHOTGUN_PELLETS.z + min(iTime, 0.);\n        for (float f=0.; f<num_pellets; ++f)\n        {\n            vec2 address = ADDR_RANGE_SHOTGUN_PELLETS.xy;\n            address.x += f;\n            vec2 props = hash2(address);\n            if (props.x <= fade)\n                continue;\n            vec4 pellet = load(address);\n            int hit_material = int(pellet.w + .5);\n            if (is_material_sky(hit_material))\n                continue;\n            vec3 pos = pellet.xyz - base_pos;\n            float particle_depth = dot(pos, view_matrix[1]) + (-2.*PELLET_WORLD_RADIUS);\n            if (particle_depth < 0. || particle_depth > depth)\n                continue;\n            vec2 ndc_pos = vec2(dot(pos, view_matrix[0]), dot(pos, view_matrix[2]));\n            float radius = max(PELLET_WORLD_RADIUS, particle_depth * depth_scale);\n            vec2 delta = abs(ndc_pos - fragCoordNDC * particle_depth);\n            if (max(delta.x, delta.y) <= radius)\n            {\n                fragColor = vec4(vec3(.5 * (1.-sqr(props.y))), 0.);\n                depth = particle_depth;\n\t\t\t    if (is_material_balloon(hit_material))\n                    fragColor.rgb *= get_balloon_color(hit_material, level).rgb * 2.;\n            }\n        }\n    }\n    \n    Fireball fireball;\n    get_fireball_props(g_animTime, fireball);\n\n\t#if CULL_PARTICLES\n    {\n        vec3 mins, maxs;\n        get_fireball_bounds(fireball, camera_pos, view_matrix, 40., mins, maxs);\n        if (maxs.z <= 0. || mins.z > depth)\n            return;\n\n        float slack = 8.\/mins.z + depth_scale;\n        mins.xy -= slack;\n        maxs.xy += slack;\n        if (mins.z > 0. && is_inside(fragCoordNDC, vec4(mins.xy, maxs.xy - mins.xy)) < 0.)\n            return;\n    }\n\t#endif\n    \n\t#if DEBUG_PARTICLE_CULLING\n    {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.), .25);\n    }\n\t#endif\n    \n    float end_time = min(get_landing_time(fireball), g_animTime);\n    float end_generation = ceil((end_time - fireball.launch_time) * (1.\/SPAWN_INTERVAL) - .25);\n    \n    for (float generation=max(0., end_generation - 1. - MAX_GENERATIONS); generation<end_generation; ++generation)\n    {\n        float base_time=fireball.launch_time + generation * SPAWN_INTERVAL;\n        float base_age = (g_animTime - base_time) * (1.\/LIFESPAN) + (LIFESPAN_VARIATION * -.5);\n        if (base_age > 1.)\n            continue;\n        \n        vec3 base_pos = get_fireball_offset(base_time, fireball) + FIREBALL_ORIGIN;\n\n        for (float f=0.; f<BUNCH; ++f)\n        {\n            float age = base_age + hash(f + base_time) * LIFESPAN_VARIATION;\n            if (age > 1.)\n                continue;\n            vec3 pos = base_pos - camera_pos;\n            pos += hash3(base_time + f*(SPAWN_INTERVAL\/BUNCH)) * (SPREAD*2.) - SPREAD;\n            pos.z += base_age * 32.;\n            float particle_depth = dot(pos, view_matrix[1]);\n            if (particle_depth < 0. || particle_depth > depth)\n                continue;\n            vec2 ndc_pos = vec2(dot(pos, view_matrix[0]), dot(pos, view_matrix[2]));\n            float radius = max(WORLD_RADIUS, particle_depth * depth_scale);\n            vec2 delta = abs(ndc_pos - fragCoordNDC * particle_depth);\n            if (max(delta.x, delta.y) <= radius)\n            {\n                fragColor = vec4(mix(vec3(.75,.75,.25), vec3(.25), linear_step(.0, .5, age)), 0.);\n                depth = particle_depth;\n            }\n        }\n    }\n#endif \/\/ RENDER_PARTICLES\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec3\n    VOL_SUN_DIR\t\t= normalize(VOLUMETRIC_SUN_DIR),\n    VOL_WINDOW_MINS\t= vec3(64, 992, -32),\n    VOL_WINDOW_MAXS\t= vec3(64, 1056, 160),\n    VOL_WALL_POS\t= vec3(368, VOL_WINDOW_MINS.y, -72);\n\n#define MAKE_PLANE(dir, point) vec4(dir, -dot(point, dir))\n\nconst vec4 VOL_PLANES[7] = vec4[7]\n(\n\tMAKE_PLANE(normalize(cross(vec3(0, 0,-1), VOL_SUN_DIR)), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0, 0, 1), VOL_SUN_DIR)), VOL_WINDOW_MAXS),\n\tMAKE_PLANE(vec3( 1, 0, 0), VOL_WALL_POS),\n\tMAKE_PLANE(vec3(-1, 0, 0), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0, 1, 0), VOL_SUN_DIR)), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0,-1, 0), VOL_SUN_DIR)), VOL_WINDOW_MAXS),\n\tMAKE_PLANE(vec3(0, 0, -1), VOL_WALL_POS)\n);\n\nfloat volumetric_falloff(float dist)\n{\n#if defined(VOLUMETRIC_FALLOFF)\n    float x = clamp(sqr(1. - dist * (1.\/float(VOLUMETRIC_FALLOFF))), 0., 1.);\n    return x;\n    return (x * x + x) * .5;\n#else\n    return 1.;\n#endif\n}\n\nfloat volumetric_player_shadow(vec3 p, vec3 rel_cam_pos)\n{\n#if VOLUMETRIC_PLAYER_SHADOW\n    vec3 occluder_p0 = rel_cam_pos;\n    vec3 occluder_p1 = occluder_p0 - vec3(0, 0, 48);\n#if VOLUMETRIC_PLAYER_SHADOW >= 2\n    occluder_p0.z -= 20.;\n#endif \/\/ VOLUMETRIC_PLAYER_SHADOW >= 2\n\n    float window_dist = p.x * (1. \/ VOL_SUN_DIR.x);\n    float occluder_dist = occluder_p0.x * (1. \/ VOL_SUN_DIR.x);\n    p -= VOL_SUN_DIR * max(0., window_dist - occluder_dist);\n    vec3 occluder_point = closest_point_on_segment(p, occluder_p0, occluder_p1);\n    float vis = linear_step(sqr(16.), sqr(24.), length_squared(p - occluder_point));\n\n#if VOLUMETRIC_PLAYER_SHADOW >= 2\n    vis = min(vis, linear_step(sqr(8.), sqr(12.), length_squared(p - rel_cam_pos)));\n#endif \/\/ VOLUMETRIC_PLAYER_SHADOW >= 2\n\n    return vis;\n#else\n    return 1.;\n#endif \/\/ VOLUMETRIC_PLAYER_SHADOW\n}\n\nvoid add_volumetrics\n(\n    inout vec4 fragColor,\n    vec3 camera_pos, vec3 dir, float depth01,\n    vec3 normal, int uv_axis, bool viewmodel,\n    int flags, float noise, bool thumbnail\n)\n{\n#if RENDER_VOLUMETRICS\n    if (is_demo_mode_enabled(thumbnail))\n    {\n        if (!is_demo_stage_composite() || g_demo_scene < 2)\n            return;\n    }\n    else\n    {\n        if (!test_flag(flags, OPTION_FLAG_LIGHT_SHAFTS) || test_flag(flags, OPTION_FLAG_SHOW_LIGHTMAP))\n            return;\n    }\n\n    dir *= VIEW_DISTANCE;\n\n    float t_enter = 0.;\n    float t_leave = depth01;\n    for (int i=0; i<7; ++i)\n    {\n        vec4 plane = VOL_PLANES[i];\n        float dist = dot(plane.xyz, camera_pos) + plane.w;\n        float align = dot(plane.xyz, dir);\n        if (align == 0.)\n        {\n            if (dist > 0.)\n                return;\n            continue;\n        }\n        dist \/= -align;\n        t_enter = (align < 0.) ? max(t_enter, dist) : t_enter;\n        t_leave = (align > 0.) ? min(t_leave, dist) : t_leave;\n        if (t_leave <= t_enter)\n            return;\n    }\n\n    if (t_leave <= t_enter)\n        return;\n    \n#if DEBUG_VOLUMETRICS\n    fragColor.rgb = clamp(fragColor.rgb * 4., 0., 1.);\n    return;\n#endif\n\n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float num_mips = atlas_info.x;\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    int mask_lod = clamp(VOLUMETRIC_MASK_LOD - int(atlas_lod), 0, int(num_mips) - 1);\n\n    SamplerState sampler_state;\n    sampler_state.tile\t\t\t= get_tile(MATERIAL_WINDOW02_1);\n\tsampler_state.atlas_scale\t= atlas_scale;\n    sampler_state.flags\t\t\t= flags;\n    vec2 uv_offset = -vec2(.5, .5\/3.) * sampler_state.tile.zw;\n\n    vec3 relative_cam_pos = camera_pos - VOL_WINDOW_MINS;\n    vec3 enter = relative_cam_pos + dir * t_enter;\n    vec3 travel = dir * (t_leave - t_enter);\n\n#if RENDER_WINDOW_PROJECTION\n    sampler_state.flags = flags | OPTION_FLAG_TEXTURE_FILTER;\n    float n_dot_l = dot(-VOL_SUN_DIR, normal);\n    if (abs(t_leave - depth01) < 1e-3\/VIEW_DISTANCE && n_dot_l > 0.)\n    {\n        vec3 p = relative_cam_pos + dir * depth01;\n        if (uint(uv_axis) < 3u && !test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n        {\n            vec3 snap = .5 - fract(p);\n            p += snap * vec3(notEqual(ivec3(uv_axis), ivec3(0, 1, 2)));\n        }\n        float window_dist = p.x * (1. \/ VOL_SUN_DIR.x);\n        float weight = WINDOW_PROJECTION_STRENGTH * volumetric_falloff(window_dist);\n        weight *= clamp(n_dot_l, 0., 1.);\n        weight *= volumetric_player_shadow(p, relative_cam_pos);\n        weight *= linear_step(0., 2., p.z - (VOL_WALL_POS.z - VOL_WINDOW_MINS.z));\n        \n        vec2 uv = (p - window_dist * VOL_SUN_DIR).yz + uv_offset;\n        vec3 color = gamma_to_linear(texture_lod(sampler_state, uv, 0).rgb);\n\t\t\n        fragColor.rgb += fragColor.rgb * color * weight;\n    }\n    sampler_state.flags = flags;\n#endif \/\/ RENDER_WINDOW_PROJECTION\n\n    const float SAMPLE_WEIGHT = 1. \/ float(VOLUMETRIC_SAMPLES);\n    float base_weight = VOLUMETRIC_STRENGTH * SAMPLE_WEIGHT;\n\n#if defined(VOLUMETRIC_SOFT_EDGE)\n    float travel_dist = (t_leave - t_enter) * VIEW_DISTANCE;\n    base_weight *= linear_step(0., sqr(VOLUMETRIC_SOFT_EDGE), sqr(travel_dist));\n#endif\n\n\tfor (float f=noise*SAMPLE_WEIGHT; f<1.; f+=SAMPLE_WEIGHT)\n    {\n        vec3 p = enter + travel * f;\n        float window_dist = p.x * (1. \/ VOL_SUN_DIR.x);\n        float weight = base_weight * volumetric_falloff(window_dist);\n\n        vec2 uv = (p - window_dist * VOL_SUN_DIR).yz + uv_offset;\n        vec4 sample_color = texture_lod(sampler_state, uv, mask_lod);\n        sample_color = gamma_to_linear(sample_color);\n\n#if VOLUMETRIC_ANIM\n        float time = g_animTime;\n        time += smooth_noise(window_dist * (1.\/16.));\n        uv += time * vec2(7., 1.3);\n        uv += sin(uv.yx * (1.\/15.) + time * .3) * 3.;\n        weight *= smooth_noise(uv * (7.\/64.)) * 1.5 + .25;\n#endif \/\/ VOLUMETRIC_ANIM\n\n        weight *= volumetric_player_shadow(p, relative_cam_pos);\n        \n        fragColor.rgb += sample_color.rgb * weight;\n    }\n\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n#endif \/\/ RENDER_VOLUMETRICS\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    Options options;\n    LOAD(options);\n    \n    g_downscale = get_downscale(options);\n    vec2 actual_res = min(ceil(iResolution.xy \/ g_downscale * .125) * 8., iResolution.xy);\n    if (max_component(fragCoord - .5 - actual_res) > 0.)\n        DISCARD;\n    \n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    Lighting lighting;\n    LOAD(lighting);\n    \n\tUPDATE_TIME(lighting);\n    UPDATE_DEMO_STAGE(fragCoord, g_downscale, is_thumbnail);\n\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    GBuffer gbuffer = gbuffer_unpack(current);\n    if (current.z <= 0.)\n    {\n        fragColor = vec4(vec3(1.\/16.), 1);\n        return;\n    }\n    \n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n    \n    bool is_viewmodel = is_material_viewmodel(gbuffer.material);\n    vec4 noise = BLUE_NOISE(fragCoord);\n    \n\tvec4 camera_pos = load_camera_pos(SETTINGS_CHANNEL, is_thumbnail);\n    vec3 camera_angles = load_camera_angles(SETTINGS_CHANNEL, is_thumbnail).xyz;\n    vec3 velocity = load(ADDR_VELOCITY).xyz;\n    Transitions transitions; LOAD(transitions);\n    mat3 view_matrix = rotation(camera_angles.xyz);\n    if (is_viewmodel)\n    {\n        float base_fov_y = scale_fov(FOV, 9.\/16.);\n        float fov_y = compute_fov(iResolution.xy).y;\n        float fov_y_delta = base_fov_y - fov_y;\n        view_matrix = view_matrix * rotation(vec2(0, fov_y_delta*.5));\n    }\n\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame, iResolution.xy, g_downscale);\n    ndc_scale_bias.xy \/= iResolution.xy;\n    vec2 fragCoordNDC = fragCoord * ndc_scale_bias.xy + ndc_scale_bias.zw;\n    \n    vec4 plane;\n    plane.xyz = gbuffer.normal;\n    if (is_viewmodel)\n    \tplane.xyz = plane.xyz * view_matrix;\n    vec3 dir = view_matrix * unproject(fragCoordNDC);\n    vec3 surface_point = dir * VIEW_DISTANCE * current.z;\n    plane.w = -current.z * dot(plane.xyz, dir);\n    \n    if (is_viewmodel)\n    {\n        float light_level =\n            is_demo_mode_enabled(is_thumbnail) ?\n            mix(.4, .6, hash1(camera_pos.xy)) :\n        \tgbuffer_unpack(texelFetch(iChannel0, ivec2(iResolution.xy)-1, 0)).light;\n        gbuffer.light = mix(gbuffer.light, 1., .5) * light_level * 1.33;\n        surface_point = surface_point * view_matrix;\n        surface_point.y -= get_viewmodel_offset(velocity, transitions.bob_phase, transitions.attack);\n    }\n    else\n    {\n        surface_point += camera_pos.xyz;\n    }\n    \n    fragColor = apply_material(gbuffer, surface_point, plane.xyz, dir, current.z, options.flags, noise.zw);\n\tadd_particles(fragColor, fragCoordNDC, camera_pos.xyz, view_matrix, current.z, transitions.attack, camera_pos.w);\n\n    if (g_demo_stage == DEMO_STAGE_DEPTH || DEBUG_DEPTH != 0)\n        fragColor = vec4(vec3(sqrt(current.z)), 0);\n    if (g_demo_stage == DEMO_STAGE_LIGHTING || DEBUG_LIGHTING != 0 || test_flag(options.flags, OPTION_FLAG_SHOW_LIGHTMAP))\n        fragColor.rgb = vec3(1);\n    if (g_demo_stage == DEMO_STAGE_NORMALS || DEBUG_NORMALS != 0)\n        fragColor = vec4(plane.xyz*.5+.5, 0);\n    if (g_demo_stage == DEMO_STAGE_TEXTURES || DEBUG_TEXTURES != 0)\n        fragColor.a = 0.;\n    \n    fragColor.rgb *= mix(1., min(2., gbuffer.light), linear_step(.0, .5, fragColor.a));\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n\n#ifdef QUANTIZE_SCENE\n    const float LEVELS = float(QUANTIZE_SCENE);\n    const int SMOOTH_STAGES = (1<<DEMO_STAGE_DEPTH) | (1<<DEMO_STAGE_LIGHTING) | (1<<DEMO_STAGE_NORMALS);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) &&\n        !test_flag(SMOOTH_STAGES, 1<<g_demo_stage) &&\n        !test_flag(options.flags, OPTION_FLAG_SHOW_LIGHTMAP))\n    \tfragColor.rgb = round(fragColor.rgb * LEVELS) * (1.\/LEVELS);\n#endif\n    \n    fragColor.rgb = gamma_to_linear(fragColor.rgb);\n    \n    add_volumetrics\n\t(\n        fragColor,\n        camera_pos.xyz, dir, current.z,\n        gbuffer.normal, gbuffer.uv_axis, is_viewmodel,\n        options.flags, noise.y, is_thumbnail\n    );\n\n    \/\/ hack: disable motion blur for the gun model\n    fragColor.a = is_viewmodel ? -1. : current.z;\n}\n","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4ttGDH","date":"1490104585","viewed":25296,"name":"Abstract Glassy Field","username":"Shane","description":"An abstract, blobby-looking field - rendered in the style of hot, glowing, fluid-filled glass. All produced using cheap low-budget pseudoscience. :)","likes":342,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n\tAbstract Glassy Field\n\t---------------------\n\n\tAn abstract, blobby-looking field - rendered in the style of hot, glowing glass. It was \n\tproduced using cheap low-budget psuedoscience. :)\n\n\tThe surface was constructed with a spherized sinusoidal function, of sorts. I like it, because \n\tit's very cheap to produce, mildly reminiscent of noise and allows a camera to pass through it \n\twithout having to resort to trickery.\n\n\tThe fluid filled glass look is fake, but at least interesting to look at. Basically, it was\n\tproduced by indexing the reflected and refracted surface rays into a 3D tri-planar texture\n\tlookup. By the way, I've tried the real thing on this particular surface - with multiple ray \n\tbounces and so forth - and to say it's slower is an understatement. :)\n\n\tBy the way, if anyone is aware of some cheap and simple improvements, corrections, etc, feel\n\tfree to let me know.\n\n*\/\n\n#define FAR 50. \/\/ Far plane, or maximum distance.\n\n\/\/float objID = 0.; \/\/ Object ID\n\nfloat accum; \/\/ Used to create the glow, by accumulating values in the raymarching function.\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\/\/ Camera path.\nvec3 camPath(float t){\n  \n    \/\/return vec3(0, 0, t); \/\/ Straight path.\n    \/\/return vec3(-sin(t\/2.), sin(t\/2.)*.5 + 1.57, t); \/\/ Windy path.\n    \n    \/\/float s = sin(t\/24.)*cos(t\/12.);\n    \/\/return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.7 + a*1.5, t);\n    \n}\n\n\n\/\/ A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n\/\/ combination. I came up with it when I was bored one day. :) Lousy to hone in\n\/\/ on, but it has the benefit of being able to guide a camera through it.\nfloat map(vec3 p){\n \n    p.xy -= camPath(p.z).xy; \/\/ Perturb the object around the camera path.\n    \n     \n\t\/\/p = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); \/\/ 3D sinusoidal mutation.\n    \/\/\n    \/\/ Partial fix to alleviate artifacts after running the program for a while.\n    \/\/ Thanks to Reyparis and Ollj.\n    float PI = 3.14159265358979;\n    p = cos(mod(p*.315*1.25 + sin(mod(p.zxy*.875*1.25, 2.*PI)), 2.*PI));\n    \n    float n = length(p); \/\/ Spherize. The result is some mutated, spherical blob-like shapes.\n\n    \/\/ It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    \/\/ is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.025)*1.33;\n    \n}\n\n\/*\n\/\/ Alternative, even more abstract, field.\nfloat map(vec3 p){\n    \n    p.xy -= camPath(p.z).xy; \/\/ Perturb the object around the camera path.\n   \n\tp = cos(p*.1575 + sin(p.zxy*.4375)); \/\/ 3D sinusoidal mutation.\n    \n    \/\/ Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3.+cos(p.yzx*3.)); \/\/ Finer bumps. Subtle.\n    \n    return (n - p.x*p.y*p.z*.35 - .9)*1.33; \/\/ Combine, and we're done.\n    \n}\n*\/\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35\/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0., h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro + rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.25 + 1.) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        \/\/ Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35 - abs(h))\/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\/\/ Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist));\n\n        dist += clamp(h, .01, .2);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + .4, 1.); \n}\n\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(.299, .587, .114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize(n + g*bf); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\n\/\/ Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel1, rd*4., n);\n    return smoothstep(0., 1., col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n    float speed = 4.;\n    vec3 o = camPath(iTime*speed); \/\/ Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  \/\/ \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); \/\/ Light position, somewhere near the moving camera.\n\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/2.; \/\/\/3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    \/\/ Unit direction ray.\n    \/\/vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \/\/ Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    \/\/ Raymarch.\n    float t = trace(o, r);\n    \n    \/\/ Save the object ID directly after the raymarching equation, since other equations that\n    \/\/ use the \"map\" function will distort the results. I leaned that the hard way. :)\n    \/\/float sObjID = objID;\n\n    \/\/ Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    \/\/ If the surface is hit, light it up.\n    if(t<FAR){\n    \n        \/\/ Position.\n        vec3 p = o + r*t;\n\t\t\n        \/\/ Normal.\n        vec3 n = nr(p);\n        \n        \/\/ Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        \/\/ bumps on the surface to not have as much influence on the reflrection and \n        \/\/ refraction vectors, so I tone down the bumped normal with this. See the reflection\n        \/\/ and refraction lines.\n        vec3 svn = n;\n        \n        \/\/ Texture bump the normal.\n        float sz = 1.\/3.; \n        n = db(iChannel0, p*sz, n, .1\/(1. + t*.25\/FAR));\n\n        l -= p; \/\/ Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); \/\/ Light to surface distance.\n        l \/= d; \/\/ Normalizing the light direction vector.\n\n        \n        float at = 1.\/(1. + d*.05 + d*d*.0125); \/\/ Light attenuation.\n        \n        \/\/ Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        \/\/ Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); \/\/ Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); \/\/ Fresnel reflection term.\n \n         \n        \n        \/\/ Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        \/\/ of it's contents, so just make it dark.\n        vec3 tx = vec3(.05); \/\/ tpl(iChannel0, p*sz, n);\n         \n\n\t\t\/\/ Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(.5, .7, 1)*sp*2. + vec3(1, .7, .4)*pow(fr, 8.)*.25;\n \n        \/\/ Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        \/\/ refraction vectors at the surface, then pass them to the environment mapping function.\n        \/\/ Note that glass and fluid have different refractive indices, so I've fudged them into \n        \/\/ one figure.\n        vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1.\/1.35)), svn*.5 + n*.5);\n        \n        \/*\n\t\t\/\/ You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel2, normalize(reflect(r, svn*.5 + n*.5))).xyz;\n        vec3 refr = texture(iChannel2, normalize(refract(r, svn*.5 + n*.5, 1.\/1.31))).xyz;\n        refl *= refl*.5;\n        refr *= refr*.5;\n        *\/\n        \n        \/\/ More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        \/\/ colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); \/\/(refr + refl)*.5; \/\/ Adding them, if preferred.\n        \n        \/\/ Obviously, the reflected\\refracted colors will involve lit values from their respective\n        \/\/ hit points, but this is fake, so we're just combining it with a portion of the surface \n        \/\/ diffuse value.\n        col += refCol*((di*di*.25+.75) + ao*.25)*1.5; \/\/ Add the reflected color. You could combine it in other ways too.\n        \n        \/\/ Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        \/\/ hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        \/\/ taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        \/\/ depth guage - later to see if it makes a difference.\n        col = mix(col.xzy, col, di*.85 + .15); \n        \n        \/\/ Glow.\n        \/\/ Taking the accumulated color (see the raymarching function), tweaking it to look a little\n        \/\/ hotter, then combining it with the object color.\n        vec3 accCol = vec3(1, .3, .1)*accum;\n        vec3 gc = pow(min(vec3(1.5, 1, 1)*accum, 1.), vec3(1, 2.5, 12.))*.5 + accCol*.5;\n        col += col*gc*12.;\n        \n        \n        \/\/ Purple electric charge.\n        float hi = abs(mod(t\/1. + iTime\/3., 8.) - 8.\/2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*col*1.\/(.001 + hi*hi*.2);\n        col += mix(cCol.yxz, cCol, n3D(p*3.));\n \t\t\/\/ Similar effect.\n        \/\/vec3 cCol = vec3(.01, .05, 1)*col*abs(tan(t\/1.5 + iTime\/3.));\n        \/\/col += cCol;\n \n        \n        \/\/ Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    \/\/ Blend in a bit of light fog for atmospheric effect.\n    vec3 fog = vec3(.125, .04, .05)*(r.y*.5 + .5);    \n    col = mix(col, fog, smoothstep(0., .95, t\/FAR)); \/\/ exp(-.002*t*t), etc. fog.zxy\n\n    \n    \/\/ Subtle vignette.\n    u = fragCoord\/iResolution.xy;\n    col = mix(vec3(0), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.5 + .5);\n\n \n    \n    \/\/ Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4scfR2","date":"1525866410","viewed":25139,"name":"Mobius trans in hyper 3-space","username":"neozhaoliang","description":"This shader is based on Roice Nelson's work at https:\/\/www.shadertoy.com\/view\/MstcWr","likes":55,"published":3,"flags":16,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n    Keyboard control:\n    \n    Key 1 turn on\/off applying the Mobius transformation\n    Key 2 turn on\/off applying the elliptic rotation\n    Key 3 turn on\/off applying the hyperbolic scaling\n    Key 4 turn on\/off showing the Riemann sphere\n*\/\n\n#define PI  3.1415926536\n#define E_  2.71828118285\n\n\/\/ Raymarching constants\n#define AA               1\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_STEPS  255\n#define PRECISION        1e-5\n#define FAR              100.\n\n\/\/ Animation speed\n#define anim_speed (iTime * .5)\n#define hue_speed  (iTime * .3)\n\n\/\/ grid and cone size\nconst vec2 polar_grid = vec2(0.4, PI \/ 7.0);\nconst vec2 cone_angle = normalize(vec2(1.5, 1.0));\n\n\/\/ Intensity constants\nconst float intensity_divisor = 40000.;\nconst float intensity_factor_max = 7.2;\nconst float center_intensity = 12.;\nconst float dist_factor = 3.;\nconst float ppow = 1.9;\n\n\/\/ Color constants\nconst float center_hue = 0.5;\nconst float center_sat = 0.18;\n\n\/\/ shape constants\nconst float strong_factor = 7.;\nconst float weak_factor = 1.;\nconst vec2 star_hv_factor = vec2(30, 1);\nconst vec2 star_diag_factor = vec2(30, 1);\n\/\/const vec2 star_hv_factor = vec2(9.0, 0.3);\n\/\/const vec2 star_diag_factor = vec2(12.0, 0.6);\n\n\n\/\/ b_apply: apply Mobius transformation or not\n\/\/ b_elliptic: apply rotation or not\n\/\/ b_hyperbolic: apply scaling or not\n\/\/ b_parabolic is true if b_elliptic and b_parabolic are both false\n\/\/ b_loxodromic is true if b_elliptic and b_parabolic are both true\nbool b_apply = true;\nbool b_elliptic = true;\nbool b_hyperbolic = true;\nbool b_riemann = true;  \/\/ action on Riemman sphere or not\nbool b_parabolic, b_loxodromic;\n\n\/\/ hsv to rgb conversion\nvec3 hsv2rgb(vec3 hsv)\n{\n    const vec3 p = vec3(0.0, 2.0\/3.0, 1.0\/3.0);\n    hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n    return hsv.z*(0.63*hsv.y*(cos(2.*PI*(hsv.x + p)) - 1.0) + 1.0);\n}\n\n\/\/ Conversion between Euclidean distance and hyperbolic distance\n\/\/ in upper half space. They are inverse of each other.\nfloat eucToHyp(float d) { return log(d); }\nfloat hypToEuc(float d) { return pow(E_, d); }\n\n\/\/ 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\/\/ 1d and 2d rectangular grids\nfloat grid1d(float x, float size)\n{\n    return mod(x + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 grid2d(vec2 p, vec2 size)\n{\n    return mod(p + 0.5 * size, size) - 0.5 * size;\n}\n\n\/\/ 2d polar grids\nvec2 polarGrid(vec2 p, vec2 size)\n{\n    float theta = atan(p.y, p.x);\n    float r = eucToHyp(length(p));\n    return grid2d(vec2(r, theta), size);\n}\n\n\/*\n * Complex arithmetic\n*\/\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) \/ dot(w, w);\n}\n\nvec2 csqrt(vec2 z)\n{\n    float r2 = dot(z, z);\n    float r = sqrt(sqrt(r2));\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle \/ 2.0), sin(angle \/ 2.0));\n}\n\n\/*\n * Quaternion arithmetic\n*\/\nvec4 qmul(vec4 p, vec4 q)\n{\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw),\n                p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 qdiv(vec4 p, vec4 q)\n{\n    return qmul(p, vec4(q.x, -q.yzw) \/ dot(q, q));\n}\n\n\/*\n * Mobius transformation z --> (Az + B) \/ (Cz + D)\n*\/\nstruct Mobius\n{\n    vec2 A, B, C, D;\n};\n\nconst Mobius mob = Mobius(\n    vec2(-1, 0),\n    vec2(1.2, 0),\n    vec2(-1, 0),\n    vec2(-1.2, 0)\n);\n\n\/\/ Apply Mobius transformation on complex plane\nvec2 applyMobius(vec2 z)\n{\n    vec2 z1 = cmul(mob.A, z) + mob.B;\n    vec2 z2 = cmul(mob.C, z) + mob.D;\n    return cdiv(z1, z2);\n}\n\n\/\/ Apply Mobius transformation on upper half space as quaternions\n\/\/ (x, y, z) --> (x + yi + zj + 0k)\nvec4 applyMobius(vec4 p)\n{\n    vec4 p1 = qmul(vec4(mob.A, 0., 0.), p) + vec4(mob.B, 0., 0.);\n    vec4 p2 = qmul(vec4(mob.C, 0., 0.), p) + vec4(mob.D, 0., 0.);\n    return qdiv(p1, p2);\n}\n\nfloat applyMobius(inout vec3 p)\n{\n    if (!b_apply)\n        return 1.0;\n\n    p = applyMobius(vec4(p, 0)).xyz;\n    float scale = length(p);\n    return scale > 1.0 ? 1.0 \/ scale : scale;\n}\n\n\/\/ A Mobius transformation of hyperbolic type is conjugate to a pure scaling\nvoid trans_hyperbolic(inout vec2 p)\n{\n    float d = eucToHyp(length(p)) - anim_speed * polar_grid.x;\n    \/\/ This avoids running out of resolution.\n    d = grid1d(d, polar_grid.x);\n    p = normalize(p) * hypToEuc(d);\n}\n\n\/\/ A Mobius transformation of elliptic type is conjugate to a pure rotation\nvoid trans_elliptic(inout vec2 p)\n{\n    p = rot2d(p, anim_speed * polar_grid.y);\n}\n\n\/\/ A Mobius transformation of parabolic type is conjugate to a pure translation\nvoid trans_parabolic(inout vec2 p)\n{\n    p.x += iTime * polar_grid.x \/ 3.;\n}\n\n\/\/ signed distance function for sphere kissing at y=0 with radius r\nfloat sdSphere(vec3 p, float r) { p.y -= r; return length(p) - r; }\n\/\/ signed distance functions for plane y=0 and y=c\nfloat sdPlane(vec3 p) { return p.y; }\nfloat sdPlane(vec3 p, float c) { return p.y - c; }\n\/\/ a cone in the upper hyperbolic space may be a usual cone at the origin\n\/\/ or a Dupin cyclide with its two horns on the plane\nfloat sdCone(vec3 p)\n{\n    float t = 1.0;\n    if (b_apply)\n    {\n        t = applyMobius(p);\n        p = normalize(p);\n    }\n    float q = length(p.xz);\n    return dot(cone_angle, vec2(q, -p.y)) * t;\n}\n\n\/\/ signed distance function for parabolic case\nfloat sdScene1(vec3 p)\n{\n    return b_apply ? min(sdPlane(p), sdSphere(p, 1.0)) : sdPlane(p, 0.5);\n}\n\n\/\/ signed distance function for elliptic\/hyperbolic case\nfloat sdScene2(vec3 p)\n{\n    if (b_riemann)\n        return min(sdPlane(p), sdSphere(p, 1.));\n\n    return min(sdPlane(p), sdCone(p));\n}\n\nvec3 getColor(vec2 p, float pint)\n{\n    float sat = 0.75 \/ pow(pint, 2.5) + center_sat;\n    \/\/ change hue by time\n    float hue2 = b_parabolic ?\n        hue_speed - length(p.y) \/ 5.0 :\n        hue_speed - eucToHyp(length(p)) \/ 7.0;\n    float hue = center_hue + hue2;\n    return hsv2rgb(vec3(hue, sat, pint)) + pint \/ 3.;\n}\n\nfloat getIntensity1(vec2 p)\n{\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q = 0.7071 * vec2(dot(p, vec2(1.)), dot(p, vec2(1., -1.)));\n    float dist1 = length(q * star_diag_factor);\n    float dist2 = length(q * star_diag_factor.yx);\n\n    \/\/ Middle point star intensity\n    float pint1 = .5 \/ (dist * dist_factor + 0.015)\n        + strong_factor \/ (distv * dist_factor + 0.01)\n        + weak_factor \/ (disth * dist_factor + 0.01)\n        + weak_factor \/ (dist1 * dist_factor + 0.01)\n        + weak_factor \/ (dist2 * dist_factor + 0.01);\n\n    return center_intensity * intensity_factor_max * pow(pint1, ppow) \/ intensity_divisor;\n}\n\nfloat getIntensity2(vec2 p)\n{\n    float angle = atan(polar_grid.x, polar_grid.y);\n    float dist  = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q1 = rot2d(p, angle);\n    float dist1 = length(q1 * star_diag_factor);\n    vec2 q2 = rot2d(p, -angle);\n    float dist2 = length(q2 * star_diag_factor);\n\n    float pint1 = 1. \/ (dist * dist_factor  + .5);\n    if (b_loxodromic)\n    {\n        pint1 = strong_factor \/ (dist2 * dist_factor + 0.01)\n            + weak_factor  \/ (dist1 * dist_factor + 0.01)\n            + weak_factor \/ (disth * dist_factor + 0.01)\n            + weak_factor \/ (distv * dist_factor + 0.01);\n    }\n    else if (b_elliptic)\n    {\n        pint1 += weak_factor \/ (distv * dist_factor + 0.01) +\n            strong_factor \/ (disth * dist_factor + 0.01) +\n            weak_factor \/ (dist1 * dist_factor + 0.01) +\n            weak_factor \/ (dist2 * dist_factor + 0.01);\n    }\n    else\n    {\n        pint1 += weak_factor \/ (disth * dist_factor + 1.) +\n            strong_factor \/ (distv * dist_factor + .01) +\n            weak_factor \/ (dist1 * dist_factor + 0.01) +\n            weak_factor \/ (dist2 * dist_factor + 0.01);\n    }\n    return intensity_factor_max * pow(pint1, ppow) \/ intensity_divisor * center_intensity * 3.;\n}\n\nfloat map(vec3 pos)\n{\n    return b_parabolic ? sdScene1(pos) : sdScene2(pos);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(.003, 0);\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    const int maxShadeIterations = 20;\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, smoothstep(0., 1., k * h \/ t));\n        t += clamp(h, 0.01, 0.2);\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return clamp(res+0.15, 0.0, 1.0);\n}\n\n\n\/\/ iq's ambient occlusion\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) \/ 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec2 p, out float pint)\n{\n    float depth = MIN_TRACE_DIST;\n    float dist;\n    vec3 pos;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        pos = ro + rd * depth;\n        dist = map(pos);\n        if (dist < PRECISION || depth >= FAR)\n            break;\n        depth += dist;\n    }\n    if (b_parabolic)\n    {\n        if (b_apply)\n            pos \/= dot(pos, pos);\n\n        p = pos.xz;\n        trans_parabolic(pos.xz);\n        pos.xz = grid2d(pos.xz, vec2(polar_grid.x \/ 2.0));\n        pint = getIntensity1(pos.xz);\n    }\n    else\n    {\n        applyMobius(pos);\n        p = pos.xz;\n        if (b_hyperbolic) trans_hyperbolic(pos.xz);\n        if (b_elliptic)   trans_elliptic(pos.xz);\n        pos.xz = polarGrid(pos.xz, polar_grid);\n        pint = getIntensity2(pos.xz);\n    }\n    return depth;\n}\n\n\/\/ ACES tone mapping\n\/\/ https:\/\/knarkowicz.wordpress.com\/2016\/01\/06\/aces-filmic-tone-mapping-curve\/\nvec3 tonemap(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) \/ (color * (C * color + D) + E);\n}\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\n\n\/\/ https:\/\/www.shadertoy.com\/view\/lsXGzf\nbool keypress(int code) \n{\n\treturn texelFetch(iChannel0, ivec2(code,2), 0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    b_apply = !keypress(CHAR_1);\n    b_elliptic = !keypress(CHAR_2);\n    b_hyperbolic = !keypress(CHAR_3);\n    b_riemann = keypress(CHAR_4);\n\n    b_parabolic = !(b_elliptic || b_hyperbolic);\n    b_loxodromic = b_elliptic && b_hyperbolic;\n    vec3 ro = vec3(-2.4, 4.8, 7.0);\n    \/\/ro.xz = rot2d(ro.xz, iTime*0.3);\n    vec3 lookat = vec3(0.0, 0.6, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 tot = vec3(0);\n    vec3 lp = ro + vec3(.2, .8, -0.2);\n    \n\n    for (int ii = 0; ii < AA; ii++)\n    {\n        for (int jj = 0; jj < AA; jj++)\n        {\n            vec2 offset = vec2(float(ii), float(jj)) \/ float(AA);\n            vec2 uv = (fragCoord + offset) \/ iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x \/ iResolution.y;\n            vec3 rd = normalize(uv.x * r + uv.y * u + 4.0 * f);\n            vec2 p;\n            float pint;\n            float t = trace(ro, rd, p, pint);\n            if (t >= 0.0)\n            {            \n                vec3 col = tonemap(4.0 * getColor(p, pint));\n                vec3 pos = ro + rd * t;\n                vec3 nor = getNormal(pos);\n                vec3 ld = lp - pos;\n                float dist = max(length(ld), 0.001);\n                ld \/= dist;\n                float at = 2.2\/(1. + dist*.1 + dist*dist*.05); \n                float ao = calcAO(pos, nor);\n                float sh = softShadow(pos, ld, 0.04, dist, 8.);\n         \n                float diff = clamp(dot(nor, ld), 0.0, 1.0);\n                float spec = max( 0.0, dot( reflect(-ld, nor), -rd));\n\t            spec = pow(spec, 50.0);\n                tot += diff * 2.5 * col + vec3(0.6, 0.8, 0.8) * spec * 2.;\n                tot *= ao * sh * at;\n            }\n            if(t >= FAR)\n                lp = normalize(lp - ro - rd*FAR);\n \n            vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), .5 - .5*lp.y) * .3;\n            tot = mix(clamp(tot, 0., 1.), bg, smoothstep(0., FAR-2., t));\n        }\n    }\n    tot \/= float(AA * AA);\n    fragColor = vec4(sqrt(clamp(tot, 0., 1.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xsl3zX","date":"1375892237","viewed":25096,"name":"galaxy3","username":"FabriceNeyret2","description":"Rotating galaxy (colors from M51).\nDust clouds are stretched along the spiral.\nArms are density waves compressing stars and dust clouds.\nStars density adapts to display size.\nNumericKeys =  toggles.\n(Note that the arms are not really rotating :-D )","likes":404,"published":3,"flags":16,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/---  Galaxy --- Fabrice NEYRET  august 2013\n\nconst float RETICULATION = 3.;  \/\/ strenght of dust texture\nconst float NB_ARMS = 5.;       \/\/ number of arms\n\/\/const float ARM = 3.;         \/\/ contrast in\/out arms\nconst float COMPR = .1;         \/\/ compression in arms\nconst float SPEED = .1;\nconst float GALAXY_R = 1.\/2.;\nconst float BULB_R = 1.\/4.;\nconst vec3 GALAXY_COL = vec3(.9,.9,1.); \/\/(1.,.8,.5);\nconst vec3 BULB_COL   = vec3(1.,.8,.8);\nconst vec3 SKY_COL    = .5*vec3(.1,.3,.5);\n\t\t\n#define t iTime\n\n\/\/ --- base noise\nfloat tex(vec2 uv) \n{\n\tfloat n = texture(iChannel0,uv, 0.).r;\n\t\n#define MODE 3  \/\/ kind of noise texture\n#if MODE==0         \/\/ unsigned\n\t#define A 2.\n\treturn n;\n#elif MODE==1       \/\/ signed\n\t#define A 3.\n\treturn 2.*n-1.;\n#elif MODE==2       \/\/ bulbs\n\t#define A 3.\n\treturn abs(2.*n-1.);\n#elif MODE==3       \/\/ wires\n\t#define A 1.5\n\treturn 1.-abs(2.*n-1.);\n#endif\n}\n\n\n\/\/ --- perlin turbulent noise + rotation\nfloat noise(vec2 uv)\n{\n\tfloat v=0.;\n\tfloat a=-SPEED*t,\tco=cos(a),si=sin(a); \n\tmat2 M = mat2(co,-si,si,co);\n\tconst int L = 7;\n\tfloat s=1.;\n\tfor (int i=0; i<L; i++)\n\t{\n\t\tuv = M*uv;\n\t\tfloat b = tex(uv*s);\n\t\tv += 1.\/s* pow(b,RETICULATION); \n\t\ts *= 2.;\n\t}\n\t\n    return v\/2.;\n}\n\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy\/iResolution.y-vec2(.8,.5);\n\tvec3 col;\n\t\n\t\/\/ spiral stretching with distance\n\tfloat rho = length(uv); \/\/ polar coords\n\tfloat ang = atan(uv.y,uv.x);\n\tfloat shear = 2.*log(rho); \/\/ logarythmic spiral\n\tfloat c = cos(shear), s=sin(shear);\n\tmat2 R = mat2(c,-s,s,c);\n\n\t\/\/ galaxy profile\n\tfloat r; \/\/ disk\n\tr = rho\/GALAXY_R; float dens = exp(-r*r);\n\tr = rho\/BULB_R;\t  float bulb = exp(-r*r);\n\tfloat phase = NB_ARMS*(ang-shear);\n\t\/\/ arms = spirals compression\n\tang = ang-COMPR*cos(phase)+SPEED*t;\n\tuv = rho*vec2(cos(ang),sin(ang));\n\t\/\/ stretched texture must be darken by d(new_ang)\/d(ang)\n\tfloat spires = 1.+NB_ARMS*COMPR*sin(phase);\n\t\/\/ pires = mix(1.,sin(phase),ARM);\n\tdens *= .7*spires;\t\n\t\n\t\/\/ gaz texture\n\tfloat gaz = noise(.09*1.2*R*uv);\n\tfloat gaz_trsp = pow((1.-gaz*dens),2.);\n\n\t\/\/ stars\n\t\/\/float a=SPEED*t, co=cos(a),si=sin(a); \n\t\/\/mat2 M = mat2(co,-si,si,co);\n\t\/\/ adapt stars size to display resolution\n\tfloat ratio = .8*iResolution.y\/iChannelResolution[0].y;\n\tfloat stars1 = texture(iChannel1,ratio*uv+.5, 0.).r, \/\/ M*uv\n\t      stars2 = texture(iChannel0,ratio*uv+.5, 0.).r,\n\t\t  stars = pow(1.-(1.-stars1)*(1.-stars2),5.);\n\t\n\t\/\/stars = pow(stars,5.);\n\t\n\t\/\/ keybord controls (numbers)\n\tif (keyToggle(49)) gaz_trsp = 1.\/1.7;\n\tif (keyToggle(50)) stars = 0.;\n\tif (keyToggle(51)) bulb = 0.;\n\tif (keyToggle(52)) dens = .3*spires;\n\t\n\t\/\/ mix all\t\n\tcol = mix(SKY_COL,\n\t\t\t  gaz_trsp*(1.7*GALAXY_COL) + 1.2*stars, \n\t\t\t  dens);\n\tcol = mix(col, 1.2*BULB_COL, bulb);\n\t\t\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=192&num=12">17</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=204&num=12">18</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=216&num=12">19</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=228&num=12">20</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=240&num=12">21</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=192&num=12">17</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=204&num=12">18</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=216&num=12">19</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=228&num=12">20</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=240&num=12">21</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
