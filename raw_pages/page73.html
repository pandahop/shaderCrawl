<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (74) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"MsBSzW","date":"1409439633","viewed":8130,"name":"DanceWalker1","username":"VJSpackOMat","description":"First Attempt creating a walk animation from scratch, next is more joints in arms\/legs \n\nyoutube recording\nhttps:\/\/www.youtube.com\/watch?v=KZNppSXiZUM","likes":10,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"\/media\/a\/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"\/media\/ap\/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by c.Kleinhuis - VJSpackOMat\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.facebook.com\/VJSpackOMat\n\/\/ http:\/\/www.fractalforums.com \n#define PI 3.14159265359\n#define PI2 PI*2.0\n\n\nvec2 siney(float t){\n\n\treturn vec2(0,-clamp(sin(t),0.0,1.0));\n\n}\n\nvec2 cosey(float t){\n\nt=mod(t,PI2);\n\n\treturn vec2(0,-clamp(cos(t),0.0,1.0));\n\n}\n\nfloat circle(vec2 center,float radius)\n{\n\tfloat result=1.0;\n\n\n\tfloat l=length(center);\n\n\n\tl-=radius;\n\n\tif(l>radius)result=0.0;\n\n\treturn result;\n\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat capsule( vec2 p, vec2 a, vec2 b, float r )\n{\n\n\tif(sdCapsule(p,a,b,r)<0.0)return 1.0;\n\n\treturn 0.0;\n\n} \nfloat cos3Big(float t){\n\n\treturn (cos(t)+cos(t*2.0)*0.5+cos(PI\/4.0+t*4.0)*0.25)\/3.0;\n\n}\nfloat circleHalve(vec2 center,float radius)\n{\n\tfloat result=1.0;\n\n\n\tfloat l=length(center);\n\n\n\tl-=radius;\n\n\tif(center.y<0.0)result=0.0;\n\tif(l>radius)result=0.0;\n\n\treturn result;\n\n}\n\nfloat walkingDude(vec2 uv,float time){\n\n\tfloat val=0.0;\nfloat floorHeight= (-0.5 );\n    float tempduetocomplainingcompiler=(uv.x+1.5)\/3.0-1.5;\n\/\/ WTF ?! floor not defined !??!?!\ntempduetocomplainingcompiler=    floor(tempduetocomplainingcompiler) ;\n    time=time+tempduetocomplainingcompiler *112.00;\nuv.x=mod(uv.x,3.0)-1.5;\n \n\t\/\/body\n\tvec2 bodyPos=vec2(0.0,sin(time*8.0)*.15+.55-floorHeight);\n\tval+=circle((uv-bodyPos)*vec2(1.25,1.0),.2);\n\n\n\tvec2 headPos=bodyPos+vec2(cos3Big(time)*0.2,0.4+cos3Big(time*1.12)*0.2);\n\t\t\tval+=circle(uv-headPos,.1);\n\n\t\/\/val+=circleHalve(uv+footDist+cosey(iTime*4)*0.4,cos(PI+iTime*4)*0.05+0.1);\n\n\n\t\t\tvec2 footDist=vec2(0.35,0);\n\t\t\tvec2 footLeft=footDist+cosey(PI\/2.0+time*4.0+PI)*0.4;\n\t\t\tfloat footLeftRadius=cos(time*4.0+PI)*0.05+0.15;\n\t\t\tval+=circleHalve(uv+footLeft,footLeftRadius);\n\n\n\tfootDist=vec2(-0.35,0.0);\n\tvec2 footRightPos=footDist+cosey(PI\/2.0+time*4.0)*0.4 ;\n\tval+=circleHalve(uv+footRightPos,cos(time*4.0)*0.05+0.15);\n\n\n\tval+=capsule(uv,bodyPos,-footRightPos+vec2(0,0.1),0.1);\n\n\tval+=capsule(uv,bodyPos,-footLeft+vec2(0,0.1),0.1);\n\n\n\n\tvec2 handDist=bodyPos+vec2(-0.6,-2.25);\n\tvec2 handLeft=handDist+vec2(-cos3Big(PI\/2.0+time*1.3+PI)*0.2,cos3Big(PI\/2.0+time*1.11+PI)*0.25);\n\tfloat handLeftRadius=0.05;\n\tval+=circle(uv+handLeft,handLeftRadius);\n\tval+=capsule(uv,bodyPos+vec2(0,0.2),-handLeft ,0.05);\n\n\n\t handDist=bodyPos+vec2(0.6,-2.25);;\n\tvec2 handRight=handDist+vec2(cos3Big(PI\/2.0+time*1.3+PI)*0.2,cos3Big(PI\/2.0+time*1.11+PI)*0.25);\n\tfloat handRightRadius=0.05;\n\tval+=circle(uv+handRight,handLeftRadius);\n\tval+=capsule(uv,bodyPos+vec2(0,0.2),-handRight ,0.05);\n\nval=clamp(val,0.0,1.0);\n\n\treturn val;\n\n}\n\n\nfloat walkingDudeScaled(vec2 uv,float time,float scale){\n\n\treturn walkingDude(uv*scale+vec2(0,scale),time);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t  vec2  xy= -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\t  vec2 uv = xy * vec2(iResolution.x\/iResolution.y,1.0);\nfloat val=0.0;\n\n\/\/head\n\n\/\/val+=circle(+vec2(0,sin(iTime*8)*.25-.25),.25);\nvec2 uvorig=uv;\nuv.x+=iTime;\n\/\/body\nval=walkingDudeScaled(uv,iTime,1.0);\nuv.x=uvorig.x+iTime*.5;\nval=max(val,walkingDudeScaled(uv+vec2(-1.0,0.0),345.0+iTime*1.0,2.0)*0.5);\n\/\/val+=walkingDudeScaled(uv+vec2(1,0),2314+iTime*1,2)*0.75;\nuv.x=uvorig.x+iTime*.25;\n\nval=max(val,walkingDudeScaled(uv+vec2(1.5,0.0),34256.0+iTime*1.0,4.0)*0.25);\n\/\/val+=walkingDudeScaled(uv+vec2(-1.5,0),7655+iTime*1,4)*0.5;\n\/\/val+=walkingDudeScaled(uv+vec2(sawtooth(-iTime*.1)*6,0),iTime*1.73,sawtooth(-iTime*.1)*8);\n\/\/val+=walkingDudeScaled(vec2(-2,0)+uv+vec2(sawtooth(-iTime*.14)*3,0),234+iTime*2.1,sawtooth(-iTime*.14)*8);\n\/\/val+=walkingDudeScaled(vec2(-1,0)+uv+vec2(sawtooth(-iTime*.14)*3,0),44+iTime*1.3,sawtooth(-iTime*.14)*8);\n\n\/\/val+=walkingDudeScaled(uv+vec2(1,0),iTime*3,3);\n\/\/val+=walkingDudeScaled(uv+vec2(1,0),iTime*2,4)*0.5;\n\/\/val+=walkingDudeScaled(uv+vec2(-1,0),iTime*2.3,0.5)*0.5;\n\n\n\tvec3 color=vec3(1.0,1.0,1.0);\n\n\tfragColor = vec4( color*val, 1 );\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sGcWz","date":"1521711398","viewed":8116,"name":"Tropical Fish","username":"rigel","description":"An abstract tropical fish made with a complex map. Whatever you do, don't STRESS HIM with your mouse. :)","likes":53,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/**\n\tAuthor: Rigel rui@gil.com\n\tlicence: https:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\tlink: https:\/\/www.shadertoy.com\/view\/4sGcWz\n\t------------------------------------------------------\n\n\tMy goal with this shader was to learn about the voronoi algorithm.\n\tThe algorithm in itself is pretty straighforward, but the distance\n\tto edges is a bit more tricky.\n\n\tSo I started with this reference article by IQ.\n\thttps:\/\/iquilezles.org\/articles\/voronoilines\n\n\tAnd then searching Shadertoy I stumbled on Shane quest for the perfect \n\tround borders voronoi and his interactions with FabriceNeyret2, DR2 and Tomkh.\n\tIt was quite fun to follow the breadcrumbs and I learned a lot :)\n\n\tShane - https:\/\/www.shadertoy.com\/view\/4dsfDl\n\tDR2 - https:\/\/www.shadertoy.com\/view\/Xsyczh\n\tFabriceNeyret2 - https:\/\/www.shadertoy.com\/view\/4dKSDV\n\tTomkh - https:\/\/www.shadertoy.com\/view\/llG3zy\n\t\n\tThe voronoi algorithm is constant time, because it's based on a grid.\n\tBut that makes the feature points evenly distributed, wich can be kind of\n\tlimitied from an artistic perspective...\n\tI wanted to have a variable point density, so I needed a way to distort the grid.\n\t\n\tLuckly complex functions have this tendency of distorting space around zeros\n\tand poles (infinity), so I decided to try that.\n\n\tThere is a way to visualize complex functions called Domain Coloring \n\thttps:\/\/en.wikipedia.org\/wiki\/Domain_coloring\n\n\tThis shader is nothing more than Domain Coloring taken literaly.\n\tI use the domain as a kind coloring book, and then apply the transform.\n\n\tThe complex function is the Lambert Series https:\/\/en.wikipedia.org\/wiki\/Lambert_series\n\tThat I used in my shader about Domain Coloring https:\/\/www.shadertoy.com\/view\/ltjczK\n\tI already thought at that time, that it looked like a fish, so I only needed to make it so. :)\n*\/\n\n\/\/ uncomment if you want to see the domain without the transform\n\/\/#define DOMAIN \n\n\/\/ uncomment to see the grid, and visualize the distortion\n\/\/#define GRID\n\n\n\/\/ a few utility functions\n\/\/ smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v\/fwidth(v)); }\n\/\/ stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n\/\/ fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n\/\/ a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n\/\/ a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n\/\/ hash function for pseudorandom numbers\nvec2 hash2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(1275.1,3131.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\n\/\/ a cosine palette with domain d between 0-1\nvec3 pal(float d) { return .5 * ( cos(d*6.283*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. ); }\n\/\/ a simple square grid, you can control the scale and the width\nfloat grid(vec2 uv, float scale, float w) { vec2 guv = fract((uv*scale)-.5)-.5; return max(stroke(guv.x,w,true),stroke(guv.y,w,true)); }\n\/\/ conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n\/\/ conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n\/\/ complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x\/z2.x,z1.y-z2.y); }\n\/\/ complex pow in polar form z = vec2(radius,angle)\nvec2 zpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\n\/\/ complex sub in polar form z = vec2(radius,angle)\nvec2 zsub(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) - toCarte(z2)); }\n\n\n\/\/ This is the Lambert series transform\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Lambert_series\nvec2 lambert(vec2 uv, float m) {\n    vec2 z = toPolar(uv);\n    vec2 sum = vec2(.0);\n    vec2 offset = vec2(1.+m * cos(iTime*3.),.2*cos(iTime*(2.+m*2.)));\n    for (float i=1.; i<7.; i++)\n        sum += toCarte(zdiv(zpow(z,i),zsub(offset,zpow(z,i))));\n   return sum;\n}\n\n\/\/ IQ's smooth minimum function.\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)\/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n\/\/ Classic voronoi algorithm taken from tomkh\n\/\/ https:\/\/www.shadertoy.com\/view\/llG3zy\nvec3 voronoi( in vec2 x, float m) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n            vec2 r = g + seed - f;\n            float d = dot(r,r);\n            if( d<md ) {\n                md = d;\n                mr = r;\n            }\n    }\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders,\n    \/\/----------------------------------\n    md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n\t\t    vec2 r = g + seed - f;\n\n            if( dot(mr-r,mr-r)>.0001 ) { \/\/ skip the same cell \n                \/\/ smooth minimum for rounded borders\n                \/\/ apparently I need the max(,.0) to filter out weird values\n                md = max(smin(md,dot( 0.5*(mr+r), normalize(r-mr) ),.25),.0);\n            }\n        }\n    \n\n    return vec3( mr, sqrt(md));\n}\n\n\/\/ The scene\nvec3 TropicalFish(vec2 uv) {\n\n    vec2 z = uv;\n    bool dom = false;\n\n    #ifdef DOMAIN\n        z = uv*15.-vec2(4.,.0); dom = true;\n    #else\n        \/\/ transform uv with the complex lambert series\n        z = lambert(uv*4., iMouse.z > 0. ? .4 : .0);\n    #endif\n\n    \/\/ the voronoi tesselation is \"pulled back\" by the complex map\n    \/\/ this means that we pick a color from the domain after the transform\n    vec3 vvz = voronoi(z, iMouse.w > 0. ? .7 : .2);\n\n    \/\/ a few helpers for the domain coloring\n    vec2 zv = floor(z + vvz.xy); \/\/ voronoi feature point center\n    float phase = atan(uv.y,uv.x); \/\/ phase in untransformed space to apply some masks\n\n    \/\/ the scales and back fin\n\tvec3 colorphase = pal(atan(z.y,z.x)\/6.283);\n    vec3 c = mix(colorphase*.8,pal(.4+vvz.z*.7)*.7,smoothstep(0.,.2,vvz.z)); \/\/ mixin the fins with the ocean\n    c = mix(c,pal(vvz.z+.3)*.8*.5*(sin(vvz.z*6.283*8.)+1.), step(.2,vvz.z) ); \/\/ scales in the fin\n    \/\/ the center of the back fin\n    c = mix(c,colorphase*(sin(6.5*log(1.+length(zv+vec2(4.,.0)))))*.7,fill(sdfCircle(zv.xy+vec2(4.,.0),7.),false));\n\n    \/\/ scales mouth\n    vec3 mouth = mix(pal(.47+z.y*.05)*.8,pal(.5+vvz.z*.15)*.9, step(.4,vvz.z) )*smoothstep(18.,7.,length(z));\n    \/\/ kind of cheating here. It is not domain coloring, because the scales in the mouth are the same\n    \/\/ that the scales in in the back fin, so I apply the mask in the untransformed space to break the symmetry.\n    c = mix(c,mouth,smoothstep(radians(130.),radians(170.),abs(phase)) ); \/\/ phase mask\n    \n    \/\/ ocean mask\n    float ocmask = step(sdfRect(zv.xy+vec2(6.,.5),vec2(1.,1.)),.0);\n    c = mix(c,pal(.1+z.x*.05)*.6,ocmask); \/\/ ocean\n\n    \/\/ dorsal fins\n    vec3 dorsalFin = mix(pal(.47+z.y*.15),pal(.5+vvz.z*.5)*.4,.5*cos(z.y*6.283*4.));\n    float fpm = dom ? 1. : smoothstep(radians(30.),radians(17.),abs(abs(phase)-radians(100.))); \/\/ fin phase mask\n    c = mix(c,dorsalFin,fill(sdfRect(zv+vec2(4.5,.5),vec2(.5,.5)),true)*fpm);\n\n    \/\/ bubbles mask\n    float bubble = max(stroke(sdfCircle(vvz.xy,.05),.01,true),fill(sdfCircle(vvz.xy+vec2(.01),.02),true));\n    c = mix(c,pal(.8+vvz.z*.2),bubble*ocmask);  \/\/ bubles\n\n    \/\/ body\n    c = mix(c,pal(.47+z.y*.15),fill(sdfRect(zv.xy+vec2(.5,.5),vec2(.5,.5)),true)); \n    \n    \/\/ eye mask\n    float eye = max(fill(sdfCircle(z-vec2(-.33,-.14)+.05*vec2(cos(iTime),sin(iTime*2.)),.05),true),stroke(sdfCircle(z-vec2(-.33,-.14),.17),.03,true));\n    \/\/ if you remove this mask you will get a multieye monster ! :)\n    float epm = dom ? 1. : float(abs(phase-radians(150.)) < radians(30.)); \/\/ eye phase mask\n    c = mix(c,mix(pal(.8+z.x),vec3(.0),eye),fill(sdfCircle(z-vec2(-.33,-.14),.17),true)*epm); \/\/ eye\n\n\t\/\/ vignette\n\tc *= exp(-.5*dot(uv,uv));\n\n    #ifdef GRID\n        c = mix(c,vec3(1.),grid(z,1.,.05));\n    #endif\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) \/ iResolution.y;\n\n\tfragColor = vec4( TropicalFish(uv), 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ttcSD8","date":"1585915249","viewed":8069,"name":"Swiss Alps","username":"piyushslayer","description":"My first attempt at volumetric clouds based on Horizon Zero Dawn clouds. Most of the logic for the clouds is in buffer C. Use the mouse to drag around the sun for different times of the day, or click at the bottom for an automated day\/night cycle.","likes":196,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/**\n  My first attempt at rendering volumetric clouds and ray marched terrain. Terrain is\n  rendered based on ray marching techniques by iq, and the clouds are rendered based\n  on techniques by Nathan Vos and Andrew Schneider(Guerrilla), and S\u00e9bastien Hillaire\n  (Epic), see buffer C for more details. \n\n  This main image tab mostly apples some post-process effects to the terrain and cloud\n  textures, including a gaussian blue for the clouds to hide noise\/ray marching\n  artifacts, and some lens flares and light scattering effects, along with a\n  luminance based reinhard tonemapper. \n*\/\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Gaussian Blur\n\/\/-------------------------------------------------------------------------------------\n\n#define texelOffset vec2(1.75 \/ iResolution.xy)\n\nconst float kernel[9] = float[]\n(\n\t.0625, .125, .0625,\n    .125,  .25,  .125,\n    .0625, .125, .0625  \n);\n\nvec4 gaussianBlur(sampler2D buffer, vec2 uv)\n{\n    vec4 col = vec4(0.);\n    \n \tvec2 offsets[9] = vec2[](\n        vec2(-texelOffset.x,  texelOffset.y),  \/\/ top-left\n        vec2( \t\t\t0.,   texelOffset.y),  \/\/ top-center\n        vec2( texelOffset.x,  texelOffset.y),  \/\/ top-right\n        vec2(-texelOffset.x,  \t\t\t 0.),  \/\/ center-left\n        vec2( \t\t\t0.,\t\t\t \t 0.),  \/\/ center-center\n        vec2( texelOffset.x,  \t \t\t 0.),  \/\/ center-right\n        vec2(-texelOffset.x,  -texelOffset.y), \/\/ bottom-left\n        vec2( \t\t\t0.,   -texelOffset.y), \/\/ bottom-center\n        vec2( texelOffset.x,  -texelOffset.y)  \/\/ bottom-right    \n    );\n    \n    for(int i = 0; i < 9; i++)\n    {\n        col += textureLod(buffer, uv + offsets[i], 0.) * kernel[i];\n    }\n    \n    return col;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Lens Flare (from shadertoy.com\/view\/XdfXRX)\n\/\/-------------------------------------------------------------------------------------\n\n#define ORB_FLARE_COUNT\t8\n#define DISTORTION_BARREL 1.3\n\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy;\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy) * 2.221 * DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset, 0.);\n    \n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset)\n        * sin(angle) + prep * dot(prep, oldoffset) * (1. - cos(angle));\n    \n    return rotated.xy;\n}\n\nvec3 flare(vec2 uv, vec2 pos, float dist, float size)\n{\n    pos = GetDistOffset(uv, pos);\n    \n    float r = max(.01 - pow(length(uv + (dist - .05)*pos), 2.4) \n                  *(1. \/ (size * 2.)), 0.) * 6.0;\n\tfloat g = max(.01 - pow(length(uv +  dist       *pos), 2.4) \n                  *(1. \/ (size * 2.)), 0.) * 6.0;\n\tfloat b = max(.01 - pow(length(uv + (dist + .05)*pos), 2.4) \n                  *(1. \/ (size * 2.)), 0.) * 6.0;\n    \n    return vec3(r, g, b);\n}\n\nvec3 ring(vec2 uv, vec2 pos, float dist)\n{\n    vec2 uvd = uv*(length(uv));\n    \n    float r = max(1. \/ (1. + 32. * pow(length(uvd + (dist - .05)\n\t\t\t\t  * pos), 2.)), 0.) * .25;\n\tfloat g = max(1. \/ (1. + 32. * pow(length(uvd +  dist       \n\t\t\t\t  * pos), 2.)), 0.) * .23;\n\tfloat b = max(1. \/ (1. + 32. * pow(length(uvd + (dist + .05)\n\t\t\t\t  * pos), 2.)), 0.) * .21;\n    \n    return vec3(r,g,b);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos, float brightness, float size)\n{\n\t\n    vec3 c = flare(uv, pos, -1., size) * 3.;\n    c += flare(uv, pos, .5, .8 * size) * 2.;\n    c += flare(uv, pos, -.4, .8 * size);\n    \n    c += ring(uv, pos, -1.) * .5 * size;\n    c += ring(uv, pos, 1.) * .5 * size;\n    \n    return c * brightness;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Light Scattering\n\/\/-------------------------------------------------------------------------------------\n\n#define NUM_SAMPLES 48\n#define DENSITY .768\n#define WEIGHT .14\n#define DECAY .97\n\nvec3 lightScattering(vec2 uv, vec2 lightPos, vec3 sun)\n{    \n    vec2 deltauv = vec2(uv - lightPos);\n    vec2 st = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x \/ iResolution.y;\n    deltauv *= 1. \/  float(NUM_SAMPLES) * DENSITY;\n    float illuminationDecay = 1.;\n    vec3 result = vec3(0.);\n\n    for(int i = 0; i < NUM_SAMPLES; i++)\n    {\n        st -= deltauv;\n        float lightStep = textureLod(iChannel1, st, 0.).a\n            \t\t* smoothstep(2.5, -1., length(uv-sun.xy));\n\n        lightStep *= illuminationDecay * WEIGHT;\n\n        result += lightStep;\n\n        illuminationDecay *= DECAY;\n    }\n    \n    return result * (SUN_COLOR) * .2;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Tone mapping\n\/\/-------------------------------------------------------------------------------------\n\nvec3 luminanceReinhard(vec3 color)\n{\n\tfloat lum = dot(color, vec3(.2126, .7152, .0722));\n\tfloat toneMappedLum = lum \/ (1. + lum);\n\tcolor *= toneMappedLum \/ lum;\n\treturn color;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord\/iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) \/ iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) \/ iResolution.y;\n    vec3 sun = getSun(mouse, iTime);\n\n\tvec4 terrain = textureLod(iChannel0, vec2(st.x, st.y - 1. \/ iResolution.y), 0.);\n    vec4 clouds = gaussianBlur(iChannel1, st);\n    float cloudsAlphaMask = clouds.a + (terrain.a > CAMERA_FAR ? 0. : 1.);\n    \n    vec2 lightPosScreenSpace = vec2(sun.x * iResolution.y\/iResolution.x, sun.y) * .5 + .5;\n    float lensflareMask = textureLod(iChannel1, lightPosScreenSpace, 0.).a;\n    \n    vec3 col = vec3(0.);\n    col = vec3(clouds.rgb + terrain.rgb * cloudsAlphaMask);\n    col += lightScattering(st, lightPosScreenSpace, sun) * smoothstep(.01, .16, sun.z)\n        \t\t* smoothstep(.3, 1.5, terrain.a);\n\tcol += lensflare(uv, sun.xy, .8, 4.) * vec3(1.4, 1.2, 1.) * lensflareMask;\n    col = mix(col, pow(luminanceReinhard(col), vec3(.4545)), .75);\n    col += hash12(fragCoord) * .004;\n\n    fragColor = vec4(col, 1.);\n    \n    \/\/ hide the ugly red pixel\n    if (fragCoord.y < 2. && fragCoord.x < 2.)\n        fragColor = vec4(.6) * sun.z;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/**\n  Common tab contains all the control values for the terrain, clouds, sky etc, along\n  with all the helper functions used in multiple buffers. \n*\/\n\n\n#define PI 3.1415926535\n\n#define SAT(x) clamp(x, 0., 1.)\n\n#define TERRAIN_FREQ .1\n#define TERRAIN_HEIGHT 3.\n#define HQ_OCTAVES 12\n#define MQ_OCTAVES 7\n\n#define CAMERA_NEAR .001\n#define CAMERA_FAR 200.\n#define CAMERA_FOV 75.\n#define CAMERA_HEIGHT 1.6\n#define CAMERA_PITCH .15\n#define CAMERA_ZOOM -2.\n#define CAMERA_DEPTH -1125.\n\n#define FOG_B .3\n#define FOG_C .1\n\n#define SUN_INTENSITY 6.66\n#define SUN_COLOR vec3(1.2, 1., .6)\n#define SKY_COLOR vec3(.25, .5, 1.75)\n#define SUN_SPEED .04\n\n#define EARTH_RADIUS 6378100. \n#define CLOUD_BOTTOM 2500.\n#define CLOUD_TOP 4200.\n#define CLOUD_COVERAGE .555 \/\/ lower means more cloud coverage, and vice versa\n#define CLOUD_BASE_FREQ .00006\n#define CLOUD_DETAIL_FREQ .0018\n#define CLOUD_STEPS 18\n#define CLOUD_LIGHT_STEPS 6\n#define CLOUD_TOP_OFFSET 250.\n#define CLOUD_ABSORPTION_TOP 1.8\n#define CLOUD_ABSORPTION_BOTTOM 3.6\n\n#define WIND_DIR vec3(.4, .1, 1.)\n#define WIND_SPEED 75.\n\n#define CLOUDS_AMBIENT_TOP vec3(1., 1.2, 1.6)\n#define CLOUDS_AMBIENT_BOTTOM vec3(.6, .4, .8)\n\n#define BAYER_LIMIT 16\n#define BAYER_LIMIT_H 4\n\n\/\/ 4 x 4 Bayer matrix\nconst int bayerFilter[BAYER_LIMIT] = int[]\n(\n\t 0,  8,  2, 10,\n\t12,  4, 14,  6,\n\t 3, 11,  1,  9,\n\t15,  7, 13,  5\n);\n\nstruct Ray\n{\n\tvec3 origin, direction;   \n};\n    \n\/\/-------------------------------------------------------------------------------------\n\/\/  Helper functions\n\/\/-------------------------------------------------------------------------------------\n    \nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) \/ (b - a)) * (d - c)) + c;\n}\n\nfloat remap01(float x, float a, float b)\n{\n\treturn ((x - a) \/ (b - a));   \n}\n\nbool writeToPixel(vec2 fragCoord, int iFrame)\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFrame % BAYER_LIMIT;\n    return (((iFragCoord.x + BAYER_LIMIT_H * iFragCoord.y) % BAYER_LIMIT)\n            == bayerFilter[index]);\n\t\t\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/  Camera stuff\n\/\/-------------------------------------------------------------------------------------\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, -lookAt);\n}\n\nRay getCameraRay(vec2 uv, float t)\n{\n    uv *= (CAMERA_FOV \/ 360.) * PI; \/\/ fov\n    vec3 origin = vec3(0., CAMERA_HEIGHT, CAMERA_DEPTH);\n    vec3 target = vec3(0., origin.y + CAMERA_PITCH,  CAMERA_DEPTH - 1.2);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, CAMERA_ZOOM));\n    return Ray(origin, direction);\n}\n\nvec3 getSun(vec2 mouse, float iTime)\n{\n    vec2 sunPos = mouse;\n    \n    if (mouse.y < -.95)\n    {\n        sunPos = vec2(cos(mod(iTime * SUN_SPEED, PI)) * .7, 0.);\n    \tsunPos.y = 1. - 3.05 * sunPos.x * sunPos.x;\n    }\n    \n    float sunHeight = (max(0., sunPos.y * .75 + .25));\n    \n    return vec3(sunPos, sunHeight);\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/  Atmospheric Scattering\n\/\/-------------------------------------------------------------------------------------\n\n\/** Slightly modified version of robobo1221's fake atmospheric scattering\n \t(https:\/\/www.shadertoy.com\/view\/4tVSRt)\n*\/\nvec3 miePhase(float dist, vec3 sunL)\n{\n    return max(exp(-pow(dist, .3)) * sunL - .4, 0.);\n}\n\nvec3 atmosphericScattering(vec2 uv, vec2 sunPos, bool isSun)\n{\n    \n    float sunDistance = distance(uv, sunPos);\n\tfloat scatterMult = SAT(sunDistance);\n\tfloat dist = uv.y;\n\tdist = (.5 * mix(scatterMult, 1., dist)) \/ dist;\n    vec3 mieScatter = miePhase(sunDistance, vec3(1.)) * SUN_COLOR;\n\tvec3 color = dist * SKY_COLOR;\n    color = max(color, 0.);\n    vec3 sun = .0002 \/ pow(length(uv-sunPos), 1.7) * SUN_COLOR;\n    \n\tcolor = max(mix(pow(color, .8 - color),\n\tcolor \/ (2. * color + .5 - color * 1.3),\n\tSAT(sunPos.y * 2.5)), 0.)\n\t+ (isSun ? (sun + mieScatter) : vec3(0.));\n    \n\tcolor *=  (pow(1. - scatterMult, 5.) * 10. * SAT(.666 - sunPos.y)) + 1.5;\n\tfloat underscatter = distance(sunPos.y, 1.);\n\tcolor = mix(color, vec3(0.), SAT(underscatter));\n\t\n\treturn color;\t\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/  Hash Functions\n\/\/-------------------------------------------------------------------------------------\n    \n\/\/ Hash functions by Dave_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. \/ float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Noise generation\n\/\/-------------------------------------------------------------------------------------\n\n\/\/ Iq's value noise, and its analytical derivatives\nvec3 valueNoiseDerivative(vec2 x, sampler2D smp)\n{\n    vec2 f = fract(x);\n    vec2 u = f * f * (3. - 2. * f);\n\n#if 1\n    \/\/ texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch(smp, (p + ivec2(0, 0)) & 255, 0).x;\n\tfloat b = texelFetch(smp, (p + ivec2(1, 0)) & 255, 0).x;\n\tfloat c = texelFetch(smp, (p + ivec2(0, 1)) & 255, 0).x;\n\tfloat d = texelFetch(smp, (p + ivec2(1, 1)) & 255, 0).x;\n#else    \n    \/\/ texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod(smp, (p + vec2(.5, .5)) \/ 256., 0.).x;\n\tfloat b = textureLod(smp, (p + vec2(1.5, .5)) \/ 256., 0.).x;\n\tfloat c = textureLod(smp, (p + vec2(.5, 1.5)) \/ 256., 0.).x;\n\tfloat d = textureLod(smp, (p + vec2(1.5, 1.5)) \/ 256., 0.).x;\n#endif\n    \n\treturn vec3(a + (b - a) * u.x + (c - a) * u.y + (a - b - c + d) * u.x * u.y,\n\t\t\t\t6. * f * (1. - f) * (vec2(b - a, c - a) + (a - b - c + d) * u.yx));\n}\n\nfloat valueNoise(vec3 x, float freq)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3. - 2. * f);\n\t\n    return mix(mix(mix(hash13(mod(i + vec3(0, 0, 0), freq)),  \n                       hash13(mod(i + vec3(1, 0, 0), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 0), freq)),  \n                       hash13(mod(i + vec3(1, 1, 0), freq)), f.x), f.y),\n               mix(mix(hash13(mod(i + vec3(0, 0, 1), freq)),  \n                       hash13(mod(i + vec3(1, 0, 1), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 1), freq)),  \n                       hash13(mod(i + vec3(1, 1, 1), freq)), f.x), f.y), f.z);\n}\n\n\/\/ Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq, bool tileable)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    float minDist = 10000.;\n    \n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 h = vec3(0.);\n                if (tileable)\n                    h = hash33(mod(id + offset, vec3(freq))) * .4 + .3; \/\/ [.3, .7]\n\t\t\t\telse\n                    h = hash33(id + offset) * .4 + .3; \/\/ [.3, .7]\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    \/\/ inverted worley noise\n    return 1. - minDist;\n}\n\n\/\/ Fbm for Perlin noise based on iq's blog\nfloat perlinFbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * valueNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n\/\/ Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n\/\/ chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq, bool tileable)\n{\n    float fbm = worleyNoise(p * freq, freq, tileable) * .625 +\n        \t \tworleyNoise(p * freq * 2., freq * 2., tileable) * .25 +\n        \t \tworleyNoise(p * freq * 4., freq * 4., tileable) * .125;\n    return max(0., fbm * 1.1 - .1);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/**\n  Buffer A generates Perlin-Worley and Worley fbm noises used for modeling clouds\n  in buffer C. This buffer only writes to texture at the beginning or whenever the\n  viewport resolution is changed.\n*\/\n\nbool resolutionChanged() {\n    return int(texelFetch(iChannel1, ivec2(0), 0).r) != int(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (resolutionChanged())\n    {\n        vec2 uv = fragCoord \/ iResolution.xy;\n        vec4 col = vec4(0.);\n        col.r += perlinFbm(vec3(uv, .4), 4., 15) * .5;\n        col.r = abs(col.r * 2. - 1.);\n        col.r = remap(col.r,  worleyFbm(vec3(uv, .2), 4., true) - 1., 1., 0., 1.);\n        col.g += worleyFbm(vec3(uv, .5), 8., true) * .625 + \n            \t worleyFbm(vec3(uv, .5), 16., true) * .25  +\n            \t worleyFbm(vec3(uv, .5), 32., true) * .125;\n        col.b = 1. - col.g;\n        fragColor = col;\n    }\n    else\n    {\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);   \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/**\n  Buffer B ray marches and shades the terrain using iq's 3 light model and improved\n  height fog. This buffer only updates 1 pixel in a 4x4 grid per frame, and the rest\n  are reprojected.\n*\/\n\n\/\/ Iq's slightly modified terrain fbm\nconst mat2 m2 = mat2(.8, -.6, .6, .8);\n\nfloat terrainFbm(vec2 uv, int octaves, sampler2D smp)\n{\n    vec2  p = uv * TERRAIN_FREQ;\n    float a = 0.;\n    float b = 1.;\n\tvec2  d = vec2(0.);\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        vec3 n = valueNoiseDerivative(p, smp);\n        d += n.yz;\n        a += b * n.x \/ (1. + dot(d, d));\n\t\tb *= .5;\n        p = m2 * p * 2.;\n    }\n    \n    a = abs(a) * 2. - 1.;\n    \n    return smoothstep(-.95, .5, a) * a * TERRAIN_HEIGHT;\n}\n\nvec3 calcNormal(vec3 pos, float freq, float t)\n{\n    vec2 eps = vec2( 0.002 * t, 0.0 );\n    int norLod = int(max(5., float(HQ_OCTAVES) - (float(HQ_OCTAVES) - 1.)\n                         * t \/ CAMERA_FAR));\n    return normalize( \n        vec3(terrainFbm(pos.xz - eps.xy, norLod, iChannel0) - terrainFbm(pos.xz\n\t\t\t\t\t+ eps.xy, norLod, iChannel0),\n             2.0 * eps.x,\n             terrainFbm(pos.xz - eps.yx, norLod, iChannel0) - terrainFbm(pos.xz\n\t\t\t\t\t+ eps.yx, norLod, iChannel0)));\n}\n\nfloat raymarchShadow(Ray ray)\n{\n    float shadow = 1.;\n\tfloat t = CAMERA_NEAR;\n    vec3 p = vec3(0.);\n    float h = 0.;\n    for(int i = 0; i < 80; ++i)\n\t{\n\t    p = ray.origin + t * ray.direction;\n        h = p.y - terrainFbm(p.xz, MQ_OCTAVES, iChannel0);\n\t\tshadow = min(shadow, 8. * h \/ t);\n\t\tt += h;\n\t\tif (shadow < 0.001 || p.z > CAMERA_FAR) break;\n\t}\n\treturn SAT(shadow);\n}\n\nfloat raymarchTerrain(Ray ray)\n{\n\tfloat t = CAMERA_NEAR, h = 0.;\n    for (int i = 0; i < 200; ++i)\n    {\n    \tvec3 pos = ray.origin + ray.direction * t;\n        h = pos.y - terrainFbm(pos.xz, MQ_OCTAVES, iChannel0);\n        if (abs(h) < (t * .002) || t > CAMERA_FAR)\n            break;\n        t += h * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord \/ iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) \/ iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) \/ iResolution.y;\n    \n    bool updatePixel = writeToPixel(fragCoord, iFrame);\n    \n    vec4 col = textureLod(iChannel1, st, 0.);\n    \n    if(updatePixel) \/\/ only draw 1\/16th resolution per frame\n    {\n        Ray ray = getCameraRay(uv, iTime);\n    \n        float terrainDist = raymarchTerrain(ray);\n\n        vec3 sun = getSun(mouse, iTime);\n        vec3 sunDir = normalize(vec3(sun.x, sun.z, -1.));\n        vec3 sunHalf = normalize(sunDir+ray.direction);\n        float sunDot = max(0., dot(ray.direction, sunDir));\n        \n\t\tvec3 terrainNormal = vec3(0.);\n        \n        col *= 0.;\n        \n        if (terrainDist > CAMERA_FAR)\n        {\n            \/\/ sky\n            col.rgb += atmosphericScattering(uv * .5 + .225, sun.xy * .5 + .225, true);\n            col.gb += .006 - uv.y * .0048; \/\/ slight night time blue-green tint\n\n            \/\/ stars\n            float t = iTime * .15;\n            float stars = pow(hash12(fragCoord), 4. * iResolution.x);\n            float twinkle = sin(t * 3.7 + uv.x - sin(uv.y * 20. + t) * 10.) * 2.;\n            twinkle *= cos(uv.y + t * 4.4 - sin(uv.x * 15. + t) * 7.) * 1.5;\n            twinkle = twinkle * .5 + .5;\n            col += max(0., stars * twinkle * smoothstep(.075, 0., sun.z) * 2.);\n        }\n        else\n        {\n            vec3 marchPos = ray.origin + ray.direction * terrainDist;\n            terrainNormal += calcNormal(marchPos, TERRAIN_FREQ, terrainDist); \n\t\t\t\n            \/\/ terrain colors\n            vec3 rock = vec3(.1, .1, .08);\n            vec3 snow = vec3(.9);\n            vec3 grass = vec3(.02, .1, .05);\n\n            vec3 albedo = mix(grass, rock, smoothstep(0., .1 * TERRAIN_HEIGHT,\n\t\t\t\t\t\t\t\tmarchPos.y)); \n            albedo = mix(albedo, snow, smoothstep(.4 * TERRAIN_HEIGHT,\n\t\t\t\t\t\t\t1.4 * TERRAIN_HEIGHT, marchPos.y));\n            albedo = mix(rock, albedo, smoothstep(.4, .7, terrainNormal.y));\n\n            float terrainShadow = clamp(raymarchShadow(Ray(marchPos - sunDir * .001, \n\t\t\t\t\t\t\t\t\t\tsunDir)), 0., 8.) + .2;\n\n            float diffuse = max(dot(sunDir, terrainNormal), 0.) * terrainShadow;\n            float specular = SAT(dot(sunHalf, ray.direction));\n            float skyAmbient = SAT(.5 + .5 * terrainNormal.y);\n\n            col.rgb += SUN_INTENSITY * SUN_COLOR * diffuse; \/\/ sun diffuse\n            \/\/ sky ambient\n            col.rgb += vec3(.5, .7, 1.2) * skyAmbient;\n            \/\/ backlight ambient\n            col.rgb += SUN_COLOR * (SAT(.5 + .5 * dot(\n                normalize(vec3(-sunDir.x, sunDir.y, sunDir.z)), terrainNormal)));\n            \/\/ terrain tex color\n            col.rgb *= albedo;\n\n            \/\/ specular\n            col.rgb += SUN_INTENSITY * .4 * SUN_COLOR * diffuse \n                \t\t\t* pow(SAT(specular), 16.);\n\n            \/\/ Iq's height based density fog\n            float fogMask = FOG_C * exp(-ray.origin.y * FOG_B) *\n                (1. - exp(-pow(terrainDist * FOG_B, 1.5) * ray.direction.y))\n                \/ ray.direction.y;\n            vec3 fogCol = mix(atmosphericScattering(uv * .5 + .75, sun.xy * .5 + .225,\n\t\t\t\t\t\t\t\tfalse) * .75, vec3(.8, .6, .3), pow(sunDot, 8.));\n            \/\/ shitty night time fog hack\n            fogCol = mix(vec3(.4, .5, .6), fogCol, smoothstep(0., .1, sun.z));\n            col.rgb = mix(col.rgb, fogCol, SAT(fogMask));\n\n            col.rgb *= max(.0, sun.z)\n                + mix(vec3(smoothstep(.1, 0., sun.z)) * terrainNormal.y, fogCol, \n                      SAT(fogMask)) * (.012, .024, .048);\n        }\n        col.a = terrainDist;\n    }\n    \n    fragColor = col;\n    \n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n    \tfragColor = vec4(iResolution.x, vec3(0.));   \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/**\n  Buffer C draws the clouds in the sky. The texture from buffer A is used to model the\n  clouds in the ray march and the light march loops. Just like buffer B, only 1 out 16\n  pixels are processed per frame and the rest are reprojected. If anyone's interested,\n  I've compiled a useful list of resources for rendering realtime volumetric clouds\n  here: https:\/\/gist.github.com\/pxv8270\/e3904c49cbd8ff52cb53d95ceda3980e\n*\/\n\nconst vec3 noiseKernel[6u] = vec3[] \n(\n\tvec3( .38051305,  .92453449, -.02111345),\n\tvec3(-.50625799, -.03590792, -.86163418),\n\tvec3(-.32509218, -.94557439,  .01428793),\n\tvec3( .09026238, -.27376545,  .95755165),\n\tvec3( .28128598,  .42443639, -.86065785),\n\tvec3(-.16852403,  .14748697,  .97460106)\n);\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Clouds modeling\n\/\/-------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(Ray ray, float radius)\n{\n    \/\/ note to future me: don't need \"a\" bcuz rd is normalized and dot(rd, rd) = 1\n \tfloat b = 2. * dot(ray.origin, ray.direction);\n    float c = dot(ray.origin, ray.origin) - radius * radius;\n    float d = sqrt(b * b - 4. * c);\n    return (-b + d) * .5;\n}\n\nfloat cloudGradient(float h)\n{\n    return smoothstep(0., .05, h) * smoothstep(1.25, .5, h);\n}\n\nfloat cloudHeightFract(float p)\n{\n\treturn (p - EARTH_RADIUS - CLOUD_BOTTOM) \/ (CLOUD_TOP - CLOUD_BOTTOM);\n}\n\nfloat cloudBase(vec3 p, float y)\n{\n    vec3 noise = textureLod(iChannel2, (p.xz - (WIND_DIR.xz * iTime * WIND_SPEED))\n                            * CLOUD_BASE_FREQ, 0.).rgb;\n    float n = y * y * noise.b + pow(1. - y, 12.);\n    float cloud = remap01(noise.r - n, noise.g - 1., 1.);\n    return cloud;\n}\n\nfloat cloudDetail(vec3 p, float c, float y)\n{\n    p -= WIND_DIR * 3. * iTime * WIND_SPEED;\n    \/\/ this is super expensive :(\n    float hf = worleyFbm(p, CLOUD_DETAIL_FREQ, false) * .625 +\n        \t   worleyFbm(p, CLOUD_DETAIL_FREQ*2., false) * .25 +\n        \t   worleyFbm(p, CLOUD_DETAIL_FREQ*4., false) * .125;\n    hf = mix(hf, 1. - hf, y * 4.);\n    return remap01(c, hf * .5, 1.);\n}\n\nfloat getCloudDensity(vec3 p, float y, bool detail)\n{\n    p.xz -= WIND_DIR.xz * y * CLOUD_TOP_OFFSET;\n    float d = cloudBase(p, y);\n    d = remap01(d, CLOUD_COVERAGE, 1.) * (CLOUD_COVERAGE);\n    d *= cloudGradient(y);\n    bool cloudDetailTest = (d > 0. && d < .3) && detail; \n    return ((cloudDetailTest) ? cloudDetail(p, d, y) : d);\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Clouds lighting\n\/\/-------------------------------------------------------------------------------------\n\nfloat henyeyGreenstein( float sunDot, float g) {\n\tfloat g2 = g * g;\n\treturn (.25 \/ PI) * ((1. - g2) \/ pow( 1. + g2 - 2. * g * sunDot, 1.5));\n}\n\nfloat marchToLight(vec3 p, vec3 sunDir, float sunDot, float scatterHeight)\n{\n    float lightRayStepSize = 11.;\n\tvec3 lightRayDir = sunDir * lightRayStepSize;\n    vec3 lightRayDist = lightRayDir * .5;\n    float coneSpread = length(lightRayDir);\n    float totalDensity = 0.;\n    for(int i = 0; i < CLOUD_LIGHT_STEPS; ++i)\n    {\n        \/\/ cone sampling as explained in GPU Pro 7 article\n     \tvec3 cp = p + lightRayDist + coneSpread * noiseKernel[i] * float(i);\n        float y = cloudHeightFract(length(p));\n        if (y > .95 || totalDensity > .95) break; \/\/ early exit\n        totalDensity += getCloudDensity(cp, y, false) * lightRayStepSize;\n        lightRayDist += lightRayDir;\n    }\n    \n    return 32. * exp(-totalDensity * mix(CLOUD_ABSORPTION_BOTTOM,\n\t\t\t\tCLOUD_ABSORPTION_TOP, scatterHeight)) * (1. - exp(-totalDensity * 2.));\n}\n\n\/\/-------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord \/ iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) \/ iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) \/ iResolution.y;\n    float terrainDist = texelFetch(iChannel0, ivec2(fragCoord), 0).w;\n    vec4 prevCol = textureLod(iChannel1, st, 0.);\n    vec4 col = vec4(0.);\n    \n    bool updatePixel = writeToPixel(fragCoord, iFrame);\n    \n    if (updatePixel) \/\/ only draw 1\/16th resolution per frame\n    {\n        \n        Ray ray = getCameraRay(uv, iTime);\n        vec3 sun = getSun(mouse, iTime);\n        \/\/ clouds don't get blindingly bright with sun at zenith\n        sun.z = clamp(sun.z, 0., .8);\n        vec3 sunDir = normalize(vec3(sun.x, sun.z, -1.));\n        float sunDot = max(0., dot(ray.direction, sunDir));\n        float sunHeight = smoothstep(.01, .1, sun.z + .025);\n        \n        if (terrainDist > CAMERA_FAR)\n        {\n\n            \/\/ clouds\n            ray.origin.y = EARTH_RADIUS;\n            float start = raySphereIntersect(ray, EARTH_RADIUS + CLOUD_BOTTOM);\n            float end = raySphereIntersect(ray, EARTH_RADIUS + CLOUD_TOP);\n            float cameraRayDist = start;\n            float cameraRayStepSize = (end - start) \/ float(CLOUD_STEPS);\n            \n            \/\/ blue noise offset\n            cameraRayDist += cameraRayStepSize * texelFetch(iChannel3,\n\t\t\t\t\t\t\t(ivec2(fragCoord) + iFrame * ivec2(113, 127)) & 1023, 0).r;\n            vec3 skyCol = atmosphericScattering(vec2(0.15, 0.05),\n                                vec2(.5, sun.y*.5+.25), false);\n            skyCol.r *= 1.1;\n\t\t\tskyCol = SAT(pow(skyCol * 2.1, vec3(4.2)));\n            float sunScatterHeight = smoothstep(.15, .4, sun.z);\n            float hgPhase = mix(henyeyGreenstein(sunDot, .4),\n                                henyeyGreenstein(sunDot, -.1), .5);\n            \/\/ sunrise\/sunset hack\n            hgPhase = max(hgPhase, 1.6 * henyeyGreenstein(sqrt(sunDot),\n\t\t\t\t\t\t\tSAT(.8 - sunScatterHeight)));\n            \/\/ shitty night time hack\n            hgPhase = mix(pow(sunDot, .25), hgPhase, sunHeight);\n            \n            vec4 intScatterTrans = vec4(0., 0., 0., 1.);\n            vec3 ambient = vec3(0.);\n            for (int i = 0; i < CLOUD_STEPS; ++i)\n            {\n                vec3 p = ray.origin + cameraRayDist * ray.direction;\n                float heightFract = cloudHeightFract(length(p));\n                float density = getCloudDensity(p, heightFract, true);\n                if (density > 0.)\n                {\n                    ambient = mix(CLOUDS_AMBIENT_BOTTOM, CLOUDS_AMBIENT_TOP, \n                                  \theightFract);\n\t\t\t\t\t\n                    \/\/ cloud illumination\n                    vec3 luminance = (ambient * SAT(pow(sun.z + .04, 1.4))\n\t\t\t\t\t\t+ skyCol * .125 + (sunHeight * skyCol + vec3(.0075, .015, .03))\n\t\t\t\t\t\t* SUN_COLOR * hgPhase\n\t\t\t\t\t\t* marchToLight(p, sunDir, sunDot, sunScatterHeight)) * density;\n\n                    \/\/ improved scatter integral by S\u00e9bastien Hillaire\n                    float transmittance = exp(-density * cameraRayStepSize);\n                    vec3 integScatter = (luminance - luminance * transmittance)\n                        * (1. \/ density);\n                    intScatterTrans.rgb += intScatterTrans.a * integScatter; \n                    intScatterTrans.a *= transmittance;\n\n                }\n\n                if (intScatterTrans.a < .05)\n                    break;\n                cameraRayDist += cameraRayStepSize;\n            }\n\n            \/\/ blend clouds with sky at a distance near the horizon (again super hacky)\n            float fogMask = 1. - exp(-smoothstep(.15, 0., ray.direction.y) * 2.);\n            vec3 fogCol = atmosphericScattering(uv * .5 + .2, sun.xy * .5 + .2, false);\n            intScatterTrans.rgb = mix(intScatterTrans.rgb,\n                                      fogCol * sunHeight, fogMask);\n            intScatterTrans.a = mix(intScatterTrans.a, 0., fogMask);\n\n            col = vec4(max(vec3(intScatterTrans.rgb), 0.), intScatterTrans.a);\n            \n            \/\/temporal reprojection\n    \t\tcol = mix(prevCol, col, .5);\n        }\n    }\n    else\n    {\n\t\tcol = prevCol;\n    }\n    \n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/**\n  Buffer D performs TXAA on the clouds from buffer C to hide some blue noise and\n  ghosting artifacts.\n*\/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec4 currentBuffer = textureLod(iChannel0, uv, 0.);\n    vec4 historyBuffer = textureLod(iChannel1, uv, 0.);\n\n    vec4 colorAvg = currentBuffer;\n    vec4 colorVar = currentBuffer * currentBuffer;\n    \n    \/\/ Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec4 neighborTexel = texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0);\n        colorAvg += neighborTexel;\n        colorVar += neighborTexel * neighborTexel;\n    }\n    colorAvg \/= 9.;\n    colorVar \/= 9.;\n    float gColorBoxSigma = .75;\n\tvec4 sigma = sqrt(max(vec4(0.), colorVar - colorAvg * colorAvg));\n\tvec4 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec4 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n\n\tfragColor = mix(currentBuffer, historyBuffer, 0.95);\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdGfDG","date":"1530203931","viewed":8063,"name":"Space Glider 2020 VR","username":"scholarius","description":"You fly the 'Super-XR 7000' spaceplane around a small planet.\nSelect a start location by pressing the corresponding key.\nAfter watching the transfer sequence you are free to go.\n\nAccompanying article: [url]http:\/\/www.thetenthplanet.de\/archives\/4519[\/url]\n","likes":98,"published":1,"flags":49,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 6 of 6: Image shader (postprocess, HMD and text overlay)\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\n * ----------------------------------------------------------------------------\n *\n * You fly the 'Super-XR 7000' spaceplane around a small planet.\n * Select a start location by pressing the corresponding key.\n * After watching the transfer sequence you are free to go.\n *\n *\n * Controls\n * --------\n *\n *\t\tmouse\t\t\t\tMouse look\n *\t\tbackspace\t\t\tForward look\n *\n *\t\tshift + 1..4\t\tSubsample resolution (100%,67%,50%,33%)\n *\n *\t\tTAB\t\t\t\t\tMenu (press again to dismiss)\n *\t\tM\t\t\t\t\tMap view\n *\n *\t\tup\/down\t\t\t\tPitch control\n *\t\tup\/down + alt\/ctrl\tPitch trim (for aero controls only)\n *\t\tleft\/right\t\t\tRoll control\n *\t\tA\/D or Q\/D\t\t\tYaw control or wheel steering\n *\t\tW\/S or Z\/S\t\t\tThrottle control (with stops at 15%, 35% and 70%)\n *\n *\t\t(pressing shift gives finer controls for all of the above)\n *\n *\t\tF\t\t\t\t\tMove flaps down one notch\n *\t\tF + shift\t\t\tMove flaps up one notch\n *\t\tV\t\t\t\t\tToggle spoilers (airbrakes)\n *\t\tG\t\t\t\t\tToggle landing gear\n *\t\tL\t\t\t\t\tToggle landing lights\n *\t\tC\t\t\t\t\tToggle canopy\n *\t\tB\t\t\t\t\tHold wheel brakes\n *\t\tB + shift\t\t\tHold wheel brakes (less effort)\n *\t\tspace\t\t\t\tHalt (Cut throttle and apply brakes)\n *\n *\t\t< or `\t\t\t\tRotate thrust vector up one position\n *\t\t< or ` + shift\t\tRotate thrust vector down one position\n *\n *\t\tR\t\t\t\t\tIncrease image magnification\n *\t\tR + shift\t\t\tDecrease image magnification\n *\t\tH\t\t\t\t\tIncrease overlay brightness\n *\t\tH + shift\t\t\tDecrease overlay brightness\n *\t\tN\t\t\t\t\tToggle photo multiplier overlay ('night vision')\n *\t\tT\t\t\t\t\tToggle terrain radar overlay\n *\t\tI\t\t\t\t\tToggle J-band infrared image\n *\n *\t\tbackspace\t\t\treset view\n *\t\tNUM 8\t\t\t\tview forward\n *\t\tNUM 4\t\t\t\tview left\n *\t\tNUM 6\t\t\t\tview right\n *\t\tNUM 2\t\t\t\tview back\n *\n *\t\tP\t\t\t\t\t'dynamic pause' mode\n *\t\tF1\t\t\t\t\tTime acceleration up to \u00d710\n *\t\tF2\t\t\t\t\tTime acceleration up to \u00d7100\n *\t\tF3\t\t\t\t\tTime acceleration up to \u00d71000\n *\t\tF4\t\t\t\t\tTime acceleration up to \u00d710000 (only in space)\n *\t\tF12\t\t\t\t\tCHEESE mode (hide all text and HMD overlays)\n *\n *\tWhen in map view\n *\n *\t\tTAB\t\t\t\t\tMenu\n *\t\tM\t\t\t\t\tExit map view\n *\n *\t\tW\/S or Z\/S\t\t\tzoom\n *\t\tmouse drag\t\t\tmove\/pan\n *\t\tmouse click\t\t\tset marker position\n *\t\t\t\t\t\t\t\t- double click to remove\n *\t\t\t\t\t\t\t\t- convert marker to waypoint via menu item 6\n *\t\tbackspace\t\t\treset position\n *\n *\n * Menu: Info pages\n * ----------------\n *\tInfo pages can be selected via menu item 1.\n *\n *\tLocation info:\n *\t\tShows current position.\n *\t\tLatitude (lat), longitude (long), altitude (alt), heading (hdg).\n *\n *\tWaypoint info:\n *\t\tShows relation to the selected waypoint.\n *\t\tBearing (brg), slant range (dst), height difference (delta-h),\n *\t\testimated time to arrival (eta).\n *\n *\tOrbit info:\n *\t\tShows continuously updated orbital elements.\n *\t\tApoapsis (Ap), periapsis (Pe), eccentricity (e),\n *\t\ttrue anomaly (theta, disabled at zero e).\n *\n *\tGlide info:\n *\t\tShows continuously updated aerodynamic coefficients.\n *\t\tLift coeffienct (CL), drag coefficient (CD), glide ratio (L\/D),\n *\t\tangle of attack (alpha).\n *\n *\tControl info:\n *\t\tShows current control inputs.\n *\t\tElevator (elev), aileron (ail), rudder (rudd), trim tab (trim).\n *\n *\tAir info:\n *\t\tShows current outside air data.\n *\t\tTemperature (T), static pressure (P), dynamic pressure (Q),\n *\t\tdensity (rho).\n *\n *\tTime info:\n *\t\tShows current in-game date (year-day), time (hours:minutes),\n *\t\tlocal time with timezone. The ingame time scale is defined by the\n *\t\tconstant SECONDS_PER_MINUTE in the common tab.\n *\n *\n * Menu: HMD modes\n * ---------------\n *\tModes for the helmet mounted display (HMD) can be selected via menu item 2.\n *\n *\tHMD off:\n *\t\tHMD overlay is disabled.\n *\n *\tSurface overlay:\n *\t\tShows speed and flight path relative to the local surface\n *\t\tand a pitch ladder oriented to the local horizon.\n *\n *\tOrbit overlay:\n *\t\tSame as surface mode but speed and flight path are shown relative\n *\t\tto the orbit center of mass (local planet) with additional\n *\t\tmarkers that indicate the outcome of applying thrust in the\n *\t\tgiven direction:\n *\n *\t\t+Pe or -Pe\t\tchange only Pe, leave Ap (apoapsis) constant\n *\t\t+Ap or -Ap\t\tchange only Ap, leave Pe (periapsis) constant\n *\t\t+a or -a\t\tchange only a, leave e (eccentricity) constant\n *\t\t+e or -e\t\tchange only e, leave a (semi-major axis) constant\n *\t\t+h or -h\t\tchange obital inclination\n *\n *\t\t---\t  ---\t\ta pair of dashed lines (when they appear) indicate the\n *\t\t\t\t\t\tpitch angle at which the current engine thrust will\n *\t\t\t\t\t\texactly counter gravity\n *\n *\tGeneral overlay symbology:\n *\n *\t\tleft group\t\tspeed in m\/s, mach number (M), dyn. pressure in bars (Q)\n *\t\tright group\t\taltitude in meters and vertical speed in m\/s\n *\t\tbottom group\theading in degrees and vertical acc. in g units (G)\n *\n *\t\tpitch ladder\tmajor ticks every 10\u00b0, minor ticks every 5\u00b0\n *\t\t\t\t\t\tsurface only: one tick at -3\u00b0 for landing\n *\t\t_\t _\n *\t\t \\\/\\\/\t\t\tWater line\n *\t\t\t\t\t\t(direction of the body-fixed x axis)\n *\t\t  .\n *\t\t--O--\t\t\tFlight path marker\n *\t\t\t\t\t\t(direction of the velocity vector)\n *\n *\t\t\\  \/\n *\t\t \\\/\t\t\t\tWaypoint (if set)\n *\n *\n * Menu: Aero modes\n * ----------------\n *\tOperating modes for the aerodynamic control surfaces (elevator, aileron and\n *\trudder) can be selected from menu item 3.\n *\n *\tAero off:\n *\t\tAero control is disabled, but manual trim setting is preserved.\n *\n *\tDirect manual control:\n *\t\tPitch, roll and yaw inputs are directly connected to elevator, aileron\n *\t\tand rudder.\n *\n *\tFly by wire control (experimental):\n *\t\tAutomatic controller where pitch input commands a desired g-load (-3..9)\n *\t\tand roll input commands roll rate. Yaw input is still manual.\n *\n *\n * Menu: RCS modes\n * ----------------\n *\tOperating modes for the reaction control system (RCS) can be selected from\n *\tmenu item 4.\n *\n *\tRCS off:\n *\t\tRCS control is disabled.\n *\n *\tDirect manual control:\n *\t\tPitch, roll and yaw inputs are directly connected to the corresponding\n *\t\tthrusters.\n *\n *\tRotation rate control:\n *\t\tPitch, roll and yaw inputs command rotation rates in the inertial\n *\t\treference frame.\n *\n *\tRotation rate control + LVLH:\n *\t\tPitch, roll and yaw inputs command rotation rates relative to\n *\t\tthe LVLH reference frame (local vertical, local horizon).\n *\n *\n * Menu: Engine modes\n * ------------------\n *\tEngine modes can be selected from menu item 5.\n *\n *\tEngine off:\n *\t\tAll engines are disabled.\n *\n *\tDrive engine:\n *\t\tAn electical motor connected to the wheels.\n *\t\tProvides passive wheel braking.\n *\n *\tImpulse engine:\n *\t\tA hypothetical propellant-less propulsion engine.\n *\n *\tNova engine:\n *\t\tNot yet implemented.\n *\n *\n * How to fly\n * ----------\n *\n *\tThe simulated plane is a blend between an F16 and a Space Shuttle.\n *\tFull throttle gives a thrust-to-weight ratio of 130%.\n *\n *\tReference speeds:\n *\n *\t\tSpeed is shown in the HMD in m\/s relative the selected frame of reference.\n *\t\tThis is either true ground speed (in surface mode) or inertial speed\n *\t\t(in orbit mode). The following reference speeds (at sea level) can be\n *\t\tgiven for atmospheric flight.\n *\n *\t\t\tstall speed\t\t\t\t40 m\/s\n *\t\t\tlanding speed\t\t\t60 m\/s .. 70 m\/s\n *\t\t\tbest glide speed\t\t89 m\/s\n *\n *\t\tAirspeed as measured by a pitot tube is a function of dynamic pressure.\n *\t\tBelow is a table to compare Q (in bars) to EAS (in knots).\n *\n *\t\t\tQ\t   knots\tQ\t   knots\tQ\t   knots\tQ\t   knots\n *\t\t\t------------\t------------\t------------\t------------\n *\t\t\t0.01\t  80\t0.06\t 190\t0.20\t 350\t0.58\t 600\n *\t\t\t0.02\t 110\t0.08\t 220\t0.26\t 400\t0.68\t 650\n *\t\t\t0.03\t 140\t0.10\t 250\t0.33\t 450\t0.79\t 700\n *\t\t\t0.04\t 160\t0.12\t 270\t0.41\t 500\t0.91\t 750\n *\t\t\t0.05\t 175\t0.15\t 300\t0.49\t 550\t1.04\t 800\n *\n *\tTake off:\n *\n *\t\tGentle (like an airliner)\t\t\tScramble (like a fighter)\n *\n *\t\t- Trim 2.5%, flaps 2 notches\t\t- Trim neutral, flaps 1 notch\n *\t\t- Throttle to 35%\t\t\t\t\t- Throttle to 70%\n *\n *\t\tFor all cases\n *\n *\t\t- Accelerate to 75 m\/s\n *\t\t- Bring the nose up *gently* (repeated tap on keyboard is enough)\n *\t\t- Retract gears immediately\n *\t\t- Retract flaps when climb is stable\n *\t\t- Manually adjust trim as you go, or select the fly-by-wire controller\n *\n *\tCruise:\n *\n *\t\tDuring cruise it is recommended to select the fly-by-wire controller,\n *\t\tas this will relief you from the workload of manual trim management.\n *\t\tBelow are some examples of kind of settings to expect.\n *\n *\t\t\t\t\t\tspeed\talt\t\t(=Q)\tthrottle\ttrim\n *\n *\t\t\tAirliner\t250\t\t11.5 k\t0.11\t\t14\t\t 1.7\n *\t\t\tConcorde\t600\t\t18 k\t0.24\t\t47\t\t-0.5\n *\t\t\tSR-71\t\t1000\t24 k\t0.25\t\t49\t\t-0.7\n *\n *\t\tThe exact settings depend on local air density which varies with\n *\t\ttemperature. Also, at very high speed come coriolis effects that\n *\t\tdepend on latitude and direction.\n *\n *\tLanding:\n *\n *\t\tThe goal is to come in on a 5% glide slope, or about 3 degrees.\n *\t\tThere is a tick on the pitch ladder at this postition for convenience.\n *\t\tThe safe limit to deploy gears should be Q < 0.1, but this is not\n *\t\tchecked yet. Below is a table with suggested settings, assuming gears\n *\t\tdown and full flaps.\n *\n *\t\t\tlanding\n *\t\t\tspeed\t\tthrottle\ttrim\t(= alpha)\n *\n *\t\t\t\t55\t\t12.0\t\t21.0\t12.9\n *\t\t\t\t60\t\t 9.5\t\t15.0\t 9.7\n *\t\t\t\t65\t\t 9.0\t\t12.0\t 7.9\n *\t\t\t\t70\t\t 8.5\t\t 8.5\t 5.6\n *\n *\t\tThe ground effect will help you cushion the impact a bit, but for the\n *\t\tbest landings you need to intervene manually to flare out. The vertical\n *\t\tspeed at touchdown then determines your rating:\n *\n *\t\t\t0 .. 2 m\/s\t\texcellent\n *\t\t\t2 .. 4 m\/s\t\tnormal\n *\t\t\t4 .. 6 m\/s\t\thard landing\n *\t\t\t6 and above\t\tcrash landing\n *\n *\tGliding with maximum range:\n *\n *\t\tThe maximum L\/D ratio for this aircraft is about 8.5 (in subsonic flight).\n *\t\tSo you can make 8.5 km ground distance with 1 km of height, etc.\n *\t\tThis is achieved in the following condition:\n *\n *\t\t\trequired trim setting\t\t\t\t\t6.4 %\n *\t\t\t = angle of attack (alpha)\t\t\t\t4.1\u00b0\n *\t\t\t = dyn pressure (Q)\t\t\t\t\t\t0.05 bars (174 knots)\n *\t\t\t = speed at sea level\t\t\t\t\t89 m\/s\n *\n *\tThrust vectoring:\n *\n *\t\tThe thrust vector can be rotated on a ladder of fixed positions from\n *\t\t0 degrees (prograde), via 36, 60, 75, 84, 90 (downward), 105, 120, 144\n *\t\tto 180 degrees (retrograde). This allows VTOL maneuvers, hovering or\n *\t\tflying like a helicopter, and also rapid decelerations.\n *\t\tThe control key for thrust vector rotation depends on the browser.\n *\n *\t\t\tFirefox\t\t'key-next-to-the-left-shift-key'\t` or <\n *\t\t\tChrome\t\t'key-below-the-esc-key'\t\t\t\t~ or \u00b0\n *\n *\t\tPressing this key alone the ladder backwards towards 0 degrees, and\n *\t\ttogether with shift moves the ladder forwards towards 180 degrees.\n *\t\tThe throttle for hovering is around 76% (depending on latitude).\n *\n *\n *\tGoing into orbit:\n *\n *\t\tThe safe altitude for a stable orbit in this simulation is 140 km.\n *\t\tBelow this altitude (more precisely, when Q > 1 \u00b5bar) the atmospheric\n *\t\tdrag is taken into account and the orbit will slowly decay.\n *\t\tThe required orbital speed at 140 km altitude is 2875 m\/s.\n *\t\tIf timed well, the entire ascent procedure can be done in 7.5 minutes.\n *\t\tFor example, when taking off eastward from startpoint B, orbital\n *\t\tinsertion can be achieved before crossing over water.\n *\n *\t\t(1) Accelerate upward\n *\n *\t\tAt the surface:\n *\t\t- Turn eastwards\n *\t\t- Full throttle\n *\t\t- Maintain a recommended climb angle around 75\u00b0\n *\n *\t\tAt 30 km altitude:\n *\t\t- If fly-by-wire control was active, return to manual\n *\t\t- Enable RCS with rate control\n *\t\t- Switch info page to orbit info\n *\t\t- Switch HMD to orbit mode\n *\t\t- Keep an eye on the vertical velocity on the HMD\n *\n *\t\t(2) Gravity Turn\n *\n *\t\tApproaching 700 m\/s vertical velocity:\n *\t\t- Gently pitch down and follow the the dashed 'hover line'\n *\t\t- Hold vertical velocity approximately constant at 700 m\/s\n *\t\t- You can make small corrections by aiming above and below the line\n *\t\t- Keep an eye on the apoapsis ('Ap') value on the orbit info page\n *\n *\t\t(3) Accelerate forward\n *\n *\t\tApproaching 140 km apoapsis ('Ap'):\n *\t\t- Gently pitch down below the horizon and follow the '+Pe' symbol\n *\t\t- Hold apoapsis ('Ap') constant at 140 km\n *\t\t- You can make small corrections by aiming above and below the symbol\n *\t\t- Keep an eye on the 'theta' value on the orbit info page\n *\n *\t\tWhen 'theta' crosses 180\u00b0:\n *\t\t- (this happens when vertical velocity crosses zero)\n *\t\t- Hold vertical velocity at zero by pitching up to the hover line again\n *\n *\t\tWhen 'theta' is no longer increasing:\n *\t\t- (this happens when there wasn't enough upward momentum)\n *\t\t- Throttle down until theta is increasing again, then throttle up\n *\n *\t\t(4) Orbital insertion:\n *\n *\t\tWhen 'Pe' and 'Ap' are equal:\n *\t\t- Press space for engine cut off\n *\t\t- Switch RCS to LVLH mode to keep aligned with the orbital rotation\n *\t\t- Congratulations, and enjoy the view!\n *\n *\n *\tUnpowered return from orbit:\n *\n *\t\tThis procedure mimics a procedure similar to the Space Shuttle re-entry\n *\t\tand requires 5\/12 orbits to complete (a bit less than half an orbit) so\n *\t\tyou will end up on the opposite side of the planet from where the procedure\n *\t\tis started.\n *\n *\t\t(1) Preparation\n *\n *\t\t- Align with the flight path\n *\t\t- Select aero direct manual control\n *\t\t- Trim up to 100%\n *\t\t- Deploy spoilers\n *\t\t- Switch to waypoint info\n *\t\t- Wait until distance to target is about 2500 km\n *\n *\t\t(2) De-orbit\n *\n *\t\t- Switch to orbit info\n *\t\t- Reverse thrust to lower the Pe altitude down to 5 km\n *\t\t- Pitch up to 20 degrees\n *\t\t- Wait until contact with atmosphere at about 80 km altitude\n *\n *\t\t(3) Re-entry\n *\n *\t\t- Switch to HMD to surface mode\n *\t\t- Bank sideways to maintain negative vertical speed of -100 m\/s\n *\t\t- Perform roll reversals from time to time to stay on course\n *\n *\t\tThe following schedule is an example of applying the procedure\n *\t\tif the target is initially on course:\n *\n *\t\t- When vertical speed crosses -100 m\/s, roll to the side towards\n *\t\t\tthe target, trim down to 70%\n *\t\t- At mach 7.5, roll to the other side, trim 50%\n *\t\t- At mach 5.5, roll to the other side, trim 20%\n *\t\t- At mach 3.5, or whenever back on course, roll upright,\n *\t\t  disable RCS and trim for glide, or enable fly-by-wire.\n *\n *\t\tYou should then be in atmospheric flight, flying Mach 3 in 30 km\n *\t\taltitude right over your target.\n *\/\n\n\/\/ ----------------------------------------------------------------------------\n\n\/*\n\nchanges v42:\n\n\t- add Naka-Rushton tone mapping model and made it the default\n\t- fix NaN bug on Mac caused by ground effect calculation\n\t- fix workaround 04 (vec initializer) for Chrome browser\n\t- fix formula for sigma in variance-based surface color antialiasing\n\t- fix every usage of iTimeDelta to use the global filtered dtime instead\n\t- fix surface lighting for case when light is behind shperical normal\n\t- fix sun glare interaction with canopy tint color\n\t- minor tweaks (colors, optical densities, phase functions, ocean reflection, dyngamma)\n\nchanges v41:\n\n\t- add shot noise simulation in low light levels\n\t- add color preservation logic to tone mapper\n\t- add canopy color filter (aids comparison with real world images taken from inside a cockpit)\n\t- add numpad keys for viewing\n\t- fix NaN terrain normals when height reaches limit exactly (happens on seafloor)\n\t- fix shadow contact angle from hardcoded constant to actual apparent sun size\n\t- minor change of cockpit\/HUD\n\nchanges v40:\n\n\tFlight dynamics model\n\t- add ground effect\n\t- add Cnb90, Clb90 coeffs, gives wing rocking effect at high AoA\n\t- add rarefaction effects based on Knudsen number\n\t- correct induced drag computation, this changes max L\/D ratio, moved gliding challenge accordingly\n\t- revise fly-by-wire control law to also be somewhat useful underwater\n\n\tRefactorings in preparation for multiple celestial bodies\n\t- remove hardcoded terrain sampler locations\n\t- move hardcoded terrain colors into data tables\n\t- move hardcoded cloud parameters into data tables\n\n\tOthers\n\t- fix oversteering tendency in input handler for low FPS\n\t- add TRN_SAFE_SLOPE config\n\t- minor change to gamut remapping\n\t- remove 'zoom' text when magnification is active\n\t- remove KIOSK mode\n\t- remove IMG_BLACKLEVEL\n\nTODOs:\n\n\tmultiple celestial bodies\n\t-\t(1) check missed ray against other celestial bodies (only sphere impact)\n\t-\t(2) render terrains of multiple planets in buffer B\n\t-\t(3) update localplanetindex and orbitplanetindex in gamestate at transition distances\n\n\tbugs\n\t-\tlight adaptation is lost after map view\n\t-\tmarker position is not initialized properly (garbage value)\n\n\tatmosphere\n\t-\tmove AMTL_CORRECTION into data\n\t-\twater vapor content dependent on local temperature\n\t-\tseasonal variation of cloud patterns\n\n\tocean\n\t-\tocean color (chlorophyll content) dependent on local temperature (and depth)\n\n\tvehicle controls\n\t-\tadd automatic flaps mode\n\t-\tadd autothrottle modes\n\t-\tadd tracking targets to RCS modes\n\t\t-\tadd nws control\n\n\tflight dynamics\n\t-\tadd ability to do spinning\n\t\t\t= aoa-dependent loss of directional and lateral stability\n\t-\tadd more mach effects\n\t\t\t- delayed onset of mach drag divergence due to wing sweep\n\t\t\t- mach tuck\n\t-\tcalculate vehicle thermal load at high speed\n\n\tmap mode\n\t-\treorganize menus\n\t-\tadd mode for surface temperature\n\t-\tadd switches for trajectory and apparent horizon outline\n\n\tachievement detector\n\n\t- circular orbit detector\n\t- extreme slow flying detector\n\t- reverse flying detector\n\t- hovering in orbit\n*\/\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ IMAGE OPTIONS\n\/\/ ----------------------------------------------------------------------------\n\n#define WITH_IMG_DIRECT\t\t\t\t0\t\t\t\t\t\/\/ bypass all image processing\n\n\/\/ flags\n#define WITH_IMG_BALANCE\t\t\t1\t\t\t\t\t\/\/ enable white balance\n#define WITH_IMG_COLPRESERVE\t\t1\t\t\t\t\t\/\/ try to preserve colors during tone mapping\n#define WITH_IMG_DITHER\t\t\t\t1\t\t\t\t\t\/\/ enable output dithering\n#define WITH_IMG_DYNGAMMA\t\t\t1\t\t\t\t\t\/\/ adapation dependent gamma in response to absolute scene luminance\n#define WITH_IMG_EXPOSURE\t\t\t1\t\t\t\t\t\/\/ enable auto exposure\n#define WITH_IMG_GLARE\t\t\t\t1\t\t\t\t\t\/\/ mip-map based glare effect, simulating aperture diffraction\n#define WITH_IMG_LENS\t\t\t\t1\t\t\t\t\t\/\/ mip-map based lens flare effect, simulating internal reflections\n#define WITH_IMG_PRIMARIES\t\t\t1\t\t\t\t\t\/\/ enable conversion from monochromatic color primaries to sRGB (or P3)\n#define WITH_IMG_RODVISION\t\t\t1\t\t\t\t\t\/\/ simulate scotopic vision at low light levels\n#define WITH_IMG_SHOTNOISE\t\t\t1\t\t\t\t\t\/\/ simulate discrete photon counts for low light levels\n#define WITH_IMG_SRGB_EOTF\t\t\t1\t\t\t\t\t\/\/ use the exact piecewise sRGB curve, otherwise a simple gamma curve\n#define WITH_IMG_SUNGLARE\t\t\t1\t\t\t\t\t\/\/ enable the special-case glare effect centered on the sun\n#define WITH_IMG_THRESHOLD\t\t\t1\t\t\t\t\t\/\/ cut off at absolute threshold of vision\n#define WITH_IMG_VIGNETTE\t\t\t1\t\t\t\t\t\/\/ enable photographic vignette\n\n\/\/ modes\n#define WITH_IMG_GAMUT_RESOLVE\t\t1\t\t\t\t\t\/\/ handle of gamut colors: 0 = clip, 1 = desaturate, 2 = convex proj,\n#define WITH_IMG_SOFT_SATURATE\t\t1\t\t\t\t\t\/\/ tone mapping function: 0 = none, 1 = Naka-Rushton, 2 = exp, 3 = tanh, 4 = sin,\n\n\/\/ debug\n#define WITH_IMG_GAMUTWARN\t\t\t0\t\t\t\t\t\/\/ show out of gamut colors (overrides GAMUTPROJ)\n\n\/\/ mac display workaround\n#define WITH_IMG_DCI_P3\t\t\t\t0\t\t\t\t\t\/\/ for MacBook with P3 display when browser does not color manage\n\nconst float IMG_BALANCE = .5;\t\t\t\t\t\t\t\/\/ 0 = absolute colorimetric, 1 = relative colorimetric\nconst float IMG_COLPRESERVE = .5;\t\t\t\t\t\t\/\/ 0 = no effect, 1 = full effect (restores original color)\nconst float IMG_GAMMA = 2.2;\nconst float IMG_GAMMA_VR = 2.4;\t\t\t\t\t\t\t\/\/ measured for the HTC vive\nconst float IMG_GLARE_SIZE = .00018;\nconst float IMG_LENS_STRENGTH = .012;\nconst float IMG_QUANTIZE = 1. \/ 255.;\nconst float IMG_VIGNETTE = 1.;\n\n\/\/ Conversion matrices from monochromatic color\n\/\/ primaries (615, 535, 445) to display color space\n\/\/ including a white point change from illuminant E to D65\n#if WITH_IMG_DCI_P3\nconst mat3\tIMG_PRIMARIES = transpose( mat3(  1.3278, -0.1815,\t0.0136,\n\t\t\t\t\t\t\t\t\t\t\t  0.0177,  1.0095, -0.0706,\n\t\t\t\t\t\t\t\t\t\t\t -0.0008, -0.0328,\t0.9511 ) );\n\n\n#else \/\/ sRGB\nconst mat3\tIMG_PRIMARIES = transpose( mat3(  1.6228, -0.4496,\t0.0325,\n\t\t\t\t\t\t\t\t\t\t\t -0.0374,  1.0595, -0.0741,\n\t\t\t\t\t\t\t\t\t\t\t -0.0283, -0.1120,\t1.0500 ) );\n#endif\n\nconst vec4\tVIS_DYNGAMMA_PARAMS =\t vec4( 1.15, .15, 2.15, .27 );\nconst vec4\tVIS_DYNGAMMA_PARAMS_VR = vec4( 1.10, .10, 2.15, .27 );\nconst float\tVIS_EXPONENT =\t  -.60;\nconst float\tVIS_EXPONENT_VR = -.30;\nconst vec3\tVIS_LIMITS = vec3( WITH_IMG_RODVISION != 0 ? .0013 : .00001, .65e-6, .00015 );\nconst vec3\tVIS_SCOTOPIC_Y = vec3( .02, .63, .35 ) * 1700. \/ 683.;\nconst float VIS_POST_EXPOSURE = 1.;\n\n\/\/ ----------------------------------------------------------------------------\n\nGameState GS;\nVehicleState VS;\nPlanetState PS;\nLocalEnv LE;\nPlanetData PD;\n\nfloat g_subsample = SCN_SUBSAMPLE;\nfloat g_subsample_inv = 1. \/ SCN_SUBSAMPLE;\nfloat g_pixelscale = 0.;\nvec4 g_exposure = vec4(0);\nvec3 g_hudcolor = ZERO;\nvec3 g_raydir = ZERO;\nmat2x3 g_Kr = mat2x3(0);\nfloat g_textlodbias = 0.;\nvec2 g_textscale = vec2(1);\nvec4 g_overlayframe = vec4(0);\nbool g_vrmode = false;\nmat3 g_vrframe = mat3(0);\nvec4 g_vrfocus = vec4(0);\nvec2 g_vrcoord = vec2(0);\nvec3 g_vrdir = ZERO;\n\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\nvec2 project3d( vec3 r, float z )\n{\n\treturn g_vrmode ?\n\t\tunViewport.zw * ( g_vrfocus.xy + .5 * z * g_vrfocus.zw * r.yz \/ r.x * vec2( 1, -1 ) ) :\n\t\tiResolution.xy * ( .5 + .5 * z * barrel_distort_inv( CAM_FOCUS * r.yz \/ r.x, CAM_DISTORT ) * vec2( 1, -iResolution.x \/ iResolution.y ) );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ HMD PRIMITIVES\n\/\/ ----------------------------------------------------------------------------\n\nfloat hmd_chrout_inner( vec2 coord, float size, float chr )\n{\n\tfloat result = 0.;\n\tif( coord.x >= 0. && coord.x < size && coord.y >= 0. && coord.y < size )\n\t{\n\t\tvec2 cell = vec2( mod( chr, 16. ), 15. - floor( chr \/ 16. ) );\n\t\tfloat lod = 5. - log2( size ) + g_textlodbias;\n\t\tresult += textureLod( iChannel2, cell \/ 16. + coord * 64. \/ ( size * iChannelResolution[2].xy ), lod ).x;\n\t}\n\treturn result;\n}\n\nfloat hmd_chrout( vec2 coord, float size, float chr )\n{\n\tcoord.x += TXT_FONT_BACKSLANT * coord.y;\n\treturn hmd_chrout_inner( coord, size, chr );\n}\n\nfloat hmd_txtout( vec2 coord, vec3 cc, int index )\n{\n\tfloat result = 0.;\n\tivec2 addr = ivec2( ( index \/ 2 ) << 4, int( iResolution.y - 2. ) + ( index & 1 ) );\n\tvec4 params = IMG_MIPMAP_HIDE * texelFetch( iChannel1, addr, 0 );\n\tbool underline = params.z < 0.;\n\tbool vector = params.w < 0.;\n\tparams.zw = abs( params.zw );\n\tfloat n = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( addr.x + 1, addr.y ), 0 ).x;\n\tbool hudclip = n < 0.;\n\tn = abs(n);\n\tif( vector )\n\t{\n\t\tvec3 v = vec3( floor( params.x ), fract( params.x ) * 4096., params.y ) \/ 2047.5 - 1.;\n\t\tif( g_vrmode )\n\t\t\tv *= g_vrframe;\n\t\tif( v.x > 0. )\n\t\t\tparams.xy = ( project3d( v, GS.camzoom ) - g_overlayframe.xy ) * g_textscale\n\t\t\t\t\t\t- params.w * vec2( n * TXT_FONT_SPACING, 1 ) \/ 2.;\n\t\telse\n\t\t\tn = 0.;\n\t}\n\tcoord -= params.xy;\n\tcoord.x += TXT_FONT_BACKSLANT * coord.y;\n\tfloat i = floor( coord.x \/ ( params.w * TXT_FONT_SPACING ) );\n\tfloat w = params.w * n * TXT_FONT_SPACING;\n\tif( n != 0. &&\n\t\tcoord.x >= 0. && coord.x < w && coord.y >= -1. && coord.y < params.w &&\n\t\t( !hudclip || ( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x ) ) )\n\t{\n\t\tfloat chr = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( addr.x + ( int( i + 5. ) >> 2 ), addr.y ), 0 )[ int( i + 5. ) & 3 ];\n\t\tresult += params.z * hmd_chrout_inner( coord - vec2( params.w * ( i * TXT_FONT_SPACING - TXT_FONT_HOFFSET ), 0. ), params.w, chr );\n\t\tif( underline )\n\t\t{\n\t\t\tfloat q = min( max( 0., 1. - abs( coord.y + 0. ) ), min( 1. + coord.x, w + 1. - coord.x ) );\n\t\t\tresult += params.z * q;\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat hmd_center_dot( vec2 coord )\n{\n\tfloat result = 0.;\n\tvec2 p = g_vrmode ? unViewport.zw * g_vrfocus.xy : iResolution.xy \/ 2.;\n\tif( coord.x >= p.x - 1. && coord.x < p.x &&\n\t\tcoord.y >= p.y - 1. && coord.y < p.y )\n\t{\n\t\tresult += .7;\n\t}\n\treturn result;\n}\n\nfloat hmd_symbol_border( inout vec3 v, vec2 limits )\n{\n\tfloat result = 1.;\n\tif( v.x < 0. )\n\t\tv = UNIT_X + normalize(v);\n\tv.yz \/= v.x;\n\tv.x = 1.;\n\tif( abs( v.y ) >= limits.x )\n\t{\n\t\tv.z *= limits.x \/ abs( v.y );\n\t\tv.y = limits.x * sign( v.y );\n\t\tresult = .5;\n\t}\n\tif( abs( v.z ) >= limits.y )\n\t{\n\t\tv.y *= .35 \/ abs( v.z );\n\t\tv.z = .35 * sign( v.z );\n\t\tresult = .5;\n\t}\n\treturn result;\n}\n\nfloat hmd_waterline( vec2 coord )\n{\n\tfloat result = 0.;\n\tvec3 v = VS.localB[0] * GS.camframe;\n\tif( g_vrmode )\n\t\tv *= g_vrframe;\n\tif( v.x * abs( v.x ) >= -FRACT_127_128 * dot( v, v ) )\n\t{\n\t\tfloat sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n\t\tmat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n\t\tvec2 p = ( coord - project3d( v, GS.camzoom ) ) * g_textscale;\n\t\tif( Linfinity( p ) < 10. )\n\t\t{\n\t\t\tvec2 a = sz * vec2( -3, -6 );\n\t\t\tvec2 b = sz * vec2( +3, -6 );\n\t\t\tvec2 c = sz * vec2( +6,\t 0 );\n\t\t\tvec2 d = sz * vec2( +9,\t 0 );\n\t\t\tfloat shape = 0.;\n\t\t\tshape = max( shape, aaa_line( I, p, a, vec2(0), 1. ) );\n\t\t\tshape = max( shape, aaa_line( I, p, b, vec2(0), 1. ) );\n\t\t\tshape = max( shape, aaa_line( I, p, a, -c, 1. ) );\n\t\t\tshape = max( shape, aaa_line( I, p, b, +c, 1. ) );\n\t\t\tshape = max( shape, aaa_hline( I, p, -d, sz * 3., 1. ) );\n\t\t\tshape = max( shape, aaa_hline( I, p, +c, sz * 3., 1. ) );\n\t\t\tresult += shape * sz;\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat hmd_flight_path_marker( vec2 coord )\n{\n\tfloat result = 0.;\n\tvec3 localv = VS.modes.x == VS_HMD_ORB ?\n\t\tVS.orbitv * PS.B * GS.camframe :\n\t\tVS.localv * GS.camframe;\n\tif( g_vrmode )\n\t\tlocalv *= g_vrframe;\n\tvec3 v = localv;\n\tif( dot( v, v ) >= .25e-6 && v.x * abs( v.x ) >= -FRACT_127_128 * dot( v, v ) )\n\t{\n\t\tfloat sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n\t\tmat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n\t\tvec2 p = ( coord - project3d( v, GS.camzoom ) ) * g_textscale;\n\t\tvec2 a = vec2( +4, 0 );\n\t\tvec2 b = vec2( +9, 0 );\n\t\tvec2 c = vec2( 0, +4 );\n\t\tfloat shape = 0.;\n\t\tif( Linfinity( p ) < 10. )\n\t\t{\n\t\t\tshape = max( shape, aaa_ring( I, p, sz * 8., 1. ) );\n\t\t\tshape = max( shape, aaa_hline( I, p, -sz * b, sz * 5., 1. ) );\n\t\t\tshape = max( shape, aaa_hline( I, p, +sz * a, sz * 5., 1. ) );\n\t\t\tshape = max( shape, aaa_vline( I, p, +sz * c, sz * 4., 1. ) );\n\t\t}\n\t\tif( localv.x < 0. &&\n\t\t\tabs( localv.y ) < -HMD_BORDER_SYM.x * localv.x &&\n\t\t\tabs( localv.z ) < -HMD_BORDER_SYM.y * localv.x )\n\t\t{\n\t\t\tp = ( coord - project3d( localv, GS.camzoom ) ) * g_textscale;\n\t\t\tif( Linfinity( p ) < 10. )\n\t\t\t{\n\t\t\t\tshape = max( shape, aaa_ring( I, p, 8., 1. ) );\n\t\t\t\tshape = max( shape, aaa_hline( I, p, -a, 8., 1. ) );\n\t\t\t\tshape = max( shape, aaa_vline( I, p, -c, 8., 1. ) );\n\t\t\t}\n\t\t}\n\t\tresult += shape * sz;\n\t}\n\treturn result;\n}\n\nfloat hmd_waypoint( vec2 coord )\n{\n\tfloat result = 0.;\n\tvec3 v = ( GS.waypoint - GS.campos ) * GS.camframe;\n\tif( g_vrmode )\n\t\tv *= g_vrframe;\n\tif( v.x * abs( v.x ) >= -FRACT_127_128 * dot( v, v ) )\n\t{\n\t\tfloat sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n\t\tmat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n\t\tvec2 p = ( coord - project3d( v, GS.camzoom ) ) * g_textscale;\n\t\tif( Linfinity( p ) < 13. )\n\t\t{\n\t\t\tfloat shape = 0.;\n\t\t\tshape = max( shape, aaa_line( I, p, vec2(0), +sz * vec2( -6, 12 ), 1. ) );\n\t\t\tshape = max( shape, aaa_line( I, p, vec2(0), +sz * vec2( +6, 12 ), 1. ) );\n\t\t\tresult += shape * sz;\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat hmd_pitch_ladder( vec2 coord, vec3 cc )\n{\n\tfloat result = 0.;\n\tvec3 localv = VS.modes.x == VS_HMD_ORB ?\n\t\tVS.orbitv * PS.B :\n\t\tVS.localv;\n\tif( dot( localv, localv ) >= .25e-6 )\n\t{\n\t\tvec3 down = normalize( -VS.localr );\n\t\tvec3 horz = normalize( reject( localv, down ) );\n\t\tvec3 left = cross( down, horz );\n\t\tmat3 M = mat3( horz, left, down );\n\t\tvec3 dir = g_raydir * M;\n\t\tfloat Kp = degrees( Linfinity( ( down * dir.x - horz * dir.z ) * g_Kr ) ) \/ dot( dir.xz, dir.xz );\n\t\tfloat Ks = degrees( Linfinity( left * g_Kr ) ) * inversesqrt( 1. - dir.y * dir.y );\n\n\t\tif( abs( cc.y ) < HMD_BORDER_LAD.x * cc.x && abs( cc.z ) < HMD_BORDER_LAD.y * cc.x )\n\t\t{\n\t\t\t\/\/ pitch ladder lines\n\t\t\tfloat pitch = degrees( atan( -dir.z, dir.x ) );\n\t\t\tfloat side = degrees( atan( dir.y, length( dir.zx ) ) );\n\t\t\tfloat twist = max( 0., .5 * dir.z );\n\t\t\tfloat p = pitch + twist * ( abs( side ) - 5. );\n\t\t\tbool tick = mod( abs(p) + 2.5, 10. ) < 5.;\n\t\t\tfloat shape = 0.;\n\t\t\tif( VS.modes.x == VS_HMD_SFCE )\n\t\t\t\tshape = aaa_interval( Kp, pitch + 2.8624, Kp \/ g_textscale.y );\n\t\t\tshape = ( tick ? 1. : .5 ) * max( shape,\n\t\t\t\taaa_stipple( Kp, p + 2.5, 5., Kp \/ ( 5. * g_textscale.y ) ) ) *\n\t\t\t\taaa_interval( Ks, abs( side ) - ( tick ? 7.5 : 5.5 ), tick ? 5. : 1. );\n\t\t\tshape = max( shape,\n\t\t\t\taaa_interval( Kp, pitch, Kp ) * aaa_interval( Ks, abs( side ) - 45., 80. ) );\n\t\t\tshape = max( shape,\n\t\t\t\taaa_stipple( Kp, pitch + 5. + sign( pitch ) * 0.625, 10., .125 ) *\n\t\t\t\taaa_interval( Ks, abs( side ) - 7.5 - 2.5 * sign( pitch ), Ks \/ g_textscale.y ) );\n\t\t\tfloat bright = .5;\n\t\t\tresult += shape * bright;\n\n\t\t\t\/\/ pitch ladder numbers\n\t\t\tconst float s15 = sin( radians( 12. ) );\n\t\t\tconst float c15 = cos( radians( 12. ) );\n\t\t\tfor( float i = -3.; i < 4.; ++i )\n\t\t\tif( i != 0. )\n\t\t\t{\n\t\t\t\tfloat a = 30. * i;\n\t\t\t\tfloat b = a + 6. * max( 0., .5 * sin( radians(a) ) );\n\t\t\t\tfor( float side = -1.; side < 3.; side += 2. )\n\t\t\t\t{\n\t\t\t\t\tvec2 sc = sincospi( b \/ 180. );\n\t\t\t\t\tvec3 v = M * vec3( sc.y * c15, side * s15, sc.x * c15 ) * GS.camframe;\n\t\t\t\t\tif( g_vrmode )\n\t\t\t\t\t\tv *= g_vrframe;\n\t\t\t\t\tif( v.x > 0. )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 p = ( coord - project3d( v, GS.camzoom ) ) * g_textscale;\n\t\t\t\t\t\tresult += .5 * hmd_chrout( p + 12. * vec2( TXT_FONT_SPACING, .5 ), 12., 48. + round( abs(a) \/ 10. ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ neutral-g indicator for orbit HMD\n\t\t\tif( VS.modes.z == VS_ENG_IMP &&\n\t\t\t\tVS.modes.x == VS_HMD_ORB )\n\t\t\t{\n\t\t\t\tvec3 r = VS.orbitr;\n\t\t\t\tfloat r2 = dot( r, r );\n\t\t\t\tvec3 gr = r2 < square( PD.radius ) ?\n\t\t\t\t\t- PD.GM \/ cube( PD.radius ) * r :\n\t\t\t\t\t- PD.GM \/ ( r2 * sqrt( r2 ) ) * r;\n\t\t\t\tvec3 movement_omega = cross( VS.orbitr, VS.orbitv ) \/ dot( VS.orbitr, VS.orbitr );\n\t\t\t\tgr -= cross( movement_omega, cross( movement_omega, VS.orbitr ) );\n\n\t\t\t\tfloat a_max = FDM_MASS_SCALE * 136000. \/ 10630.;\n\t\t\t\tfloat a = 0.001 * VS.throttle * a_max;\n\t\t\t\tvec3 rn = normalize( VS.orbitr );\n\t\t\t\tfloat f = sin( radians( VS.tvec ) ) * dot( rn, VS.B[1] );\n\t\t\t\tfloat sinpitch = -dot( gr, rn ) \/ ( a * sqrt( max( 0., 1. - f * f ) ) );\n\t\t\t\tif( sinpitch < 1. )\n\t\t\t\t{\n\t\t\t\t\tfloat line1 = degrees( asin( sinpitch ) ) - VS.tvec;\n\t\t\t\t\tfloat line2 = 180. - degrees( asin( sinpitch ) ) - VS.tvec;\n\t\t\t\t\tfloat shape =\n\t\t\t\t\t\tmax( aaa_stipple( Kp, pitch + 180. - line1, 360., Kp \/ ( 360. * g_textscale.y ) ),\n\t\t\t\t\t\t\t aaa_stipple( Kp, pitch + 180. - line2, 360., Kp \/ ( 360. * g_textscale.y ) ) ) *\n\t\t\t\t\t\taaa_interval( Ks, abs( side ) - 5., 5. ) *\n\t\t\t\t\t\taaa_stipple( Ks, side, 2., .5 );\n\t\t\t\t\tresult += .25 * shape;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid hmd_terrain_radar( inout vec3 col, vec2 coord, vec3 cc )\n{\n\tvec2 uv = ( g_vrmode ? coord + unViewport.xy : coord ) * g_subsample_inv \/ iResolution.xy;\n\tif( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x )\n\t{\n\t\tfloat center = textureLod( iChannel1, uv, 0. ).w;\n\t\tvec4 sides = vec4(\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2( -1,\t 0 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2( +1,\t 0 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2(\t 0, -1 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2(\t 0, +1 ) ).w );\n\t\tfloat mu = dot( sides, vec4(.25) );\n\t\tfloat laplace = ( center - mu ) * GS.camzoom * g_subsample_inv * g_subsample_inv;\n\t\tfloat sigma = dot( ( sides - mu ) * ( sides - mu ), vec4(.25) );\n\t\tfloat range = 2. * sqrt( sigma );\n\t\tfloat shape = .1 \/ ( .4 + mu * exp2pp( 32. * laplace \/ ( 0.0003 + range ) ) );\n\t\tcol += g_hudcolor * shape;\n\t}\n}\n\nvoid map_position( inout vec3 col, vec2 coord )\n{\n\tfloat shape = 0.;\n\tmat2 I = mat2(1);\n\tvec2 s0 = mc2sc( gs_map_project( GS, VS.localr ) );\n\tfloat sr = dot( VS.localB[0], normalize( VS.localr ) );\n\n\tif( abs( sr ) < .9995 )\n\t{\n\t\t\/\/ arrow if heading is defined\n\t\tvec2 s1 = mc2sc( gs_map_project( GS, VS.localr + VS.localB[0] ) );\n\t\tvec2 ds = normalize( s1 - s0 );\n\t\tmat2 M = mat2( ds, perp( ds ) );\n\t\tvec2 a = s0 + M * vec2( +6, 0 );\n\t\tvec2 b = s0 + M * vec2( -6, -4 );\n\t\tvec2 c = s0 + M * vec2( -6, +4 );\n\t\tshape = max( shape, aaa_line( I, coord, a, b, 1. ) );\n\t\tshape = max( shape, aaa_line( I, coord, b, c, 1. ) );\n\t\tshape = max( shape, aaa_line( I, coord, c, a, 1. ) );\n\t}\n\telse\n\tif( sr < 0. )\n\t\t\/\/ cross if downwards\n\t\tshape = max( aaa_line( I, coord, s0 - 5., s0 + 5., 1. ),\n\t\t\t\t\t aaa_line( I, coord, s0 + vec2( +5, -5 ), s0 + vec2( -5, +5 ), 1. ) );\n\telse\n\t\t\/\/ ring if upwards\n\t\tshape = aaa_ring( I, coord - s0, 10., 1. );\n\n\tfloat phase = .25 + .75 * step( .5, fract( iTime ) );\n\tcol += vec3( 1, .5, .0 ) * shape * phase;\n}\n\nvoid map_marker( inout vec3 col, vec2 coord )\n{\n\tmat2 I = mat2(1);\n\tfloat shape = 0.;\n\tvec2 s = mc2sc( gs_map_project( GS, GS.mapmarker ) );\n\tshape = max( shape, aaa_hline( I, coord, s - vec2( 6, 0 ), 12., 1. ) );\n\tshape = max( shape, aaa_vline( I, coord, s - vec2( 0, 6 ), 12., 1. ) );\n\tcol += vec3( 1, .5, .0 ) * shape;\n}\n\nvoid map_waypoint( inout vec3 col, vec2 coord )\n{\n\tmat2 I = mat2(1);\n\tfloat shape = 0.;\n\tvec2 s = mc2sc( gs_map_project( GS, GS.waypoint ) );\n\tshape = max( shape, aaa_line( I, coord, s, s + vec2( -6, 12 ), 1. ) );\n\tshape = max( shape, aaa_line( I, coord, s, s + vec2( +6, 12 ), 1. ) );\n\tcol += vec3( 1, .5, .0 ) * shape;\n}\n\nvoid map_orbit_track( inout vec3 col, vec2 sc )\n{\n\tvec3 dpdx = ZERO, dpdy = ZERO;\n\tvec4 p = gs_map_unproject_d( GS, sc, iResolution.xy, dpdx, dpdy );\n\tvec4 px = vec4( dpdx.x, dpdy.x, 0, p.x );\n\tvec4 py = vec4( dpdx.y, dpdy.y, 0, p.y );\n\tvec4 pz = vec4( dpdx.z, dpdy.z, 0, p.z );\n\tvec4 plng = atan2_d( py, px );\n\n\tvec3 r = VS.localr;\n\tvec3 v = VS.orbitv * PS.B; \/\/ not: localv!\n\tKepler K = Kepler( 0., 0., 0., 0., 0. );\n\tfloat nu = kp_init( K, r, v, PD.GM );\n\tfloat M = kp_E2M( kp_nu2E( nu, K.e ), K.e );\n\tvec3 h = cross( r, v );\n\tfloat invsin_i = length(h) \/ length( h.xy );\n\tfloat invtan_i = h.z \/ length( h.xy );\n\tif( K.e < .00005 )\n\t{\n\t\tK.w = asin( clamp( normalize(r).z * invsin_i, -1., 1. ) );\n\t\tif( v.z < 0. )\n\t\t\tK.w = PI - K.w;\n\t}\n\n\tvec4 dlng = asin_d( clamp_d( div_d( pz, hypot_d( px, py ) ) * invtan_i, -ONE_D, ONE_D ) );\n\tvec4 dnu = asin_d( clamp_d( pz * invsin_i, -ONE_D, ONE_D ) );\n\tfloat dMdt = sqrt( PD.GM * cube( abs( 1. - K.e * K.e ) \/ K.p ) );\n\tfloat dphidM = PS.omega \/ dMdt;\n\tmat2x4 ll = mat2x4( const_d( K.O ) + dlng, const_d( K.O ) - dlng - const_d(PI) );\n\tmat2x4 nn = mat2x4( const_d( -K.w ) + dnu, const_d( -K.w ) - dnu - const_d(PI) );\n\tmat2x4 MM = mat2x4( kp_E2M_d( kp_nu2E_d( nn[0], K.e ), K.e ), kp_E2M_d( kp_nu2E_d( nn[1], K.e ), K.e ) );\n\tmat2x4 aa = MM - mat2x4( const_d(M), const_d(M) );\n\tvec2 KK = vec2( length( ll[0].xy - plng.xy - aa[0].xy * dphidM ), length( ll[1].xy - plng.xy - aa[1].xy * dphidM ) );\n\tvec2 JJ = vec2( length( aa[0].xy ), length( aa[1].xy ) );\n\n\tvec3[3] colors = vec3[3](\n\t\tvec3( 1, .5, 0 ),\n\t\tvec3( .4, .4, .4 ),\n\t\tvec3( .1, .1, .1 ) );\n\n\tfloat stipple = 15. * dMdt;\n\tfloat mask = aaa_interval( dFdy(p.w), p.w, 2. );\n\tfloat revlimit = 3. * TAU;\n\n#define w2vec2( _a ) vec2( _a[0].w, _a[1].w )\n\n\tif( mask >= FRACT_1_64 )\n\tfor( int i = 0; i < ( K.e < .99995 ? 3 : 1 ); ++i )\n\t{\n\t\tfloat shape = 0.;\n\t\tfloat k = float(i) * TAU;\n\t\tvec2 d = ( K.e < .99995 ? ( mod( w2vec2( aa ), TAU ) + k ) : w2vec2( aa ) ) * dphidM;\n\t\tvec2 u = mod( w2vec2( ll ) - plng.w - d + PI, TAU ) - PI;\n\t\tvec2 s = aaa_interval2( KK, u, KK ) * aaa_stipple2( JJ, w2vec2( aa ), vec2( stipple ), vec2(.5) ) *\n\t\t\taaa_step2( JJ, revlimit - d ) * ( K.e < 1. ? vec2(1.) : aaa_step2( KK, w2vec2( aa ) ) );\n\t\tcol += mask * hmax(s) * colors[ min( i, 3 ) ];\n\t}\n\n#undef w2vec2\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ POST PROCESSING\n\/\/ ----------------------------------------------------------------------------\n\nvec3 lens_lookup( vec2 uv, float k, float lod )\n{\n\tuv = .5 * g_subsample_inv + k * ( .5 * g_subsample_inv - uv );\n\treturn textureLod( iChannel1, uv, lod ).xyz *\n\t\t16. * saturate( uv.x * g_subsample ) * saturate( uv.y * g_subsample ) *\n\t\t\t  saturate( 1. - uv.x * g_subsample ) * saturate( 1. - uv.y * g_subsample );\n}\n\nvec3 post_get_image( vec2 uv )\n{\n\tfloat k = min( 2.3, sqrt( sqrt( g_pixelscale ) \/ IMG_GLARE_SIZE ) );\n\tfloat sharpen = .182;\n\n\tuv *= g_subsample_inv;\n\tif( g_vrmode && uv.x >= .5 * g_subsample_inv )\n\t\tuv.x += .5 - .5 * g_subsample_inv;\n\n\tvec3 col = ZERO;\n#if WITH_IMG_GLARE && !WITH_IMG_DIRECT\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t{\n\t\tvec3 wsum = ZERO;\n\t\tfor( float i = 0.; i < 10.; ++i )\n\t\t{\n\t\t\tvec3 img = textureLod( iChannel1, uv, i ).xyz;\n\t\t\tfloat w = 1. \/ ( 1. + exp2( k * i ) );\n\t\t\tif( i == 1. )\n\t\t\t\tw -= sharpen;\n\t\t\tcol += w * img;\n\t\t\twsum += w;\n\t\t}\n\t\tcol = clamp( col \/ wsum, 0., 16. );\n\t}\n\telse\n#endif\n\t\tcol = textureLod( iChannel1, uv, 0. ).xyz;\n\n#if WITH_IMG_LENS && !WITH_IMG_DIRECT\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t{\n\t\tfloat bias = .5 * log2( g_pixelscale );\n\t\tcol += .25 * IMG_LENS_STRENGTH * lens_lookup( uv,-.5, -5. - bias );\n\t\tcol += .25 * IMG_LENS_STRENGTH * lens_lookup( uv, .5, -4. - bias );\n\t\tcol += .25 * IMG_LENS_STRENGTH * lens_lookup( uv, 1., -5.5 - bias );\n\t\tcol += .25 * IMG_LENS_STRENGTH * lens_lookup( uv, 2., -7. - bias );\n\t}\n#endif\n\n\treturn col;\n}\n\nvoid post_sun_glare( inout vec3 col, vec3 raydir, float v )\n{\n#if WITH_IMG_SUNGLARE\n\tvec3 sunshadow = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( ADDR_D_SUN_VISIBILITY, 0 ), 0 ).xyz;\n\tmat3 frame = GS.camframe;\n\tif( g_vrmode )\n\t\tframe *= g_vrframe;\n\tfloat b = 1. - square( .81 \/ GS.camzoom );\n\tfloat c = 1. - square( .71 \/ GS.camzoom );\n\tfloat d = dot( normalize( reject( cross( LE.L, raydir ), frame[0] ) ),\n\t\t\t\t   normalize( reject( cross( LE.L, frame[2] ), frame[0] ) ) );\n\tfloat cosbeta = sqrt( max( 0., 1. - LE.sundisk ) );\n\tfloat shape = 1. \/ ( 1. + 0.985 * chebychev6(d) );\n\tfloat offimage = parabolstep( b, c, dot( frame[0], LE.L ) );\n\tfloat e = exp2( -24. * sqrt( max( 0., 1. - square( dot( raydir, LE.L ) ) ) ) );\n\tvec3 tmp = offimage * LE.sunlight * e * sunshadow * ( 1. - cosbeta ) * shape \/\n\t\tmax( vec3( ( 1. - cosbeta ) * shape \/ IMG_EXPOSURE_MAX ), cosbeta - dot( raydir, LE.L ) );\n\tif( v >= 1. - VS.canopy )\n\t\ttmp *= irselect( COL_CANOPY_TINT, ( GS.switches & GS_IRCAM ) == GS_IRCAM );\n\tcol += tmp;\n#endif\n}\n\nvoid console_throttle_graphics( inout vec3 col, vec2 coord )\n{\n\tmat2 I = mat2(1);\n\tfloat t = VS.throttle;\n\tvec2 size = vec2( 15, 60. * abs(t) );\n\tif( Linfinity( coord ) < 61. )\n\t{\n\t\tfloat shape = aaa_rect( I, coord - size \/ 2., size, vec2(1) );\n\t\tif( t >= 0. )\n\t\t\tshape = max( shape, aaa_box( I, coord - size \/ 2., size, vec2(1) ) * .25 );\n\t\tcol += g_hudcolor * shape;\n\t}\n}\n\nvoid post_console_overlay( inout vec3 col, vec2 coord )\n{\n\tvec2 uv = mix( vec2( iResolution.x, 0 ), coord, g_textscale ) \/ iResolution.xy;\n\tcoord = ( coord - g_overlayframe.xy ) * g_textscale;\n\tif( !g_vrmode )\n\t{\n\t\tfloat consolemask = uv.y * iResolution.y - 24.;\n\t\tif( ( GS.switches & GS_IPAGE_MASK ) != 0u )\n\t\t{\n\t\t\tvec2 b = ( uv.xy * iResolution.xy - vec2( iResolution.x - 136., 80 ) ) * vec2( -1, 1 );\n\t\t\tfloat c = max( b.x + b.y, hmax( b ) );\n\t\t\tconsolemask = clamp( consolemask, 0., 16. ) + clamp( c, 0., 16. ) - 16.;\n\t\t}\n\t\tcol *= mix( .5, 1., saturate( consolemask \/ 16. ) );\n\t}\n\tconsole_throttle_graphics( col, coord - vec2( 16, 12 ) );\n}\n\nvoid post_hmd_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n\tcol += g_hudcolor * hmd_center_dot( coord );\n\tcol += g_hudcolor * hmd_waterline( coord );\n\tcol += g_hudcolor * hmd_flight_path_marker( coord );\n\tcol += g_hudcolor * hmd_pitch_ladder( coord, cc );\n\tif( dot( GS.waypoint, GS.waypoint ) > 0. )\n\t\tcol += g_hudcolor * hmd_waypoint( coord );\n}\n\nvoid post_map_overlay( inout vec3 col, vec2 coord )\n{\n\tcoord = ( coord - g_overlayframe.xy ) * iResolution.xy \/ g_overlayframe.zw;\n\tmap_position( col, coord );\n\tif( dot( GS.mapmarker, GS.mapmarker ) > 0. )\n\t\tmap_marker( col, coord );\n\tif( dot( GS.waypoint, GS.waypoint ) > 0. )\n\t\tmap_waypoint( col, coord );\n\tif( LE.H == 0. )\n\t\tmap_orbit_track( col, coord );\n}\n\nvoid post_text_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n\tcoord = ( coord - g_overlayframe.xy ) * g_textscale;\n#if WORKAROUND_10_NOUNROLL\n\tfor( int i = 0; i < NOUNROLL( TXT_FMT_MAX_COUNT ); ++i )\n#else\n\tfor( int i = 0; i < TXT_FMT_MAX_COUNT; ++i )\n#endif\n\t\tcol += g_hudcolor * hmd_txtout( coord, cc, i );\n}\n\nvoid post_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n\tbool mapmode = ( GS.switches & GS_TRMAP ) == GS_TRMAP;\n\tif( GS.stage == GS_RUNNING )\n\t{\n\t\tif( !mapmode )\n\t\t{\n\t\t\tif( ( GS.switches & GS_TRDAR ) == GS_TRDAR )\n\t\t\t\thmd_terrain_radar( col, coord, cc );\n\t\t\tif( VS.modes.x > 0 )\n\t\t\t\tpost_hmd_overlay( col, coord, cc );\n\t\t\tpost_console_overlay( col, coord );\n\t\t}\n\t\telse\n\t\t\tpost_map_overlay( col, coord );\n\t}\n\tpost_text_overlay( col, coord, cc );\n}\n\nvoid post_vignette( inout vec3 col, vec3 cc )\n{\n#if WITH_IMG_VIGNETTE\n\tcol *= pow( cc.x, IMG_VIGNETTE );\n#endif\n}\n\nvec2 irwin_hall_noise_2D( uvec2 coord, uint seed, int N )\n{\n\tuvec2 rand = uvec2( 131071u * coord.x + 31u * coord.y, 127u * coord.x + 8191u * coord.y );\n\trand = rand * 524187u + seed * 7u;\n\trand = rand * 2147483647u + seed * 3u;\n\tvec2 result = vec2(0.);\n\tfor( int i = 0; i < N; ++i )\n\t\t{ rand = rand * rand | 1u; result.xy += vec2( rand ); }\n\tfloat n = float(N);\n\tfloat s = sqrt( 12. \/ n );\n\treturn s * ( result * 2.32830644e-10 - n \/ 2. );\n}\n\nvec4 irwin_hall_noise_4D( uvec2 coord, uint seed, int N )\n\t{ return vec4( irwin_hall_noise_2D( coord, 2u * seed, N ), irwin_hall_noise_2D( coord, 2u * seed + 1u, N ) ); }\n\nvec4 poisson_4d( vec4 lambda, vec4 noise )\n{\n\tconst float magic = .395078569;\n\tvec4 urnd = vec4( floatBitsToUint( noise ) * RNG32 ) * 2.32830644e-10;\n\tvec4 p0 = exp( -lambda );\n\treturn mix(\n\t\tstep( p0, urnd ) + step( p0 * ( 1. + lambda ), urnd ),\n\t\tfloor( max( vec4(0), magic + lambda + sqrt( lambda ) * noise ) ),\n\t\tstep( .25, lambda ) );\n}\n\nvoid post_exposure( inout vec3 col, vec2 fcoord )\n{\n#if WITH_IMG_SHOTNOISE\n\tvec4 k = COL_THRESHOLD * COL_THRESHOLD_AREA * COL_THRESHOLD_TIME \/ ( g_pixelscale * iTimeDelta );\n\tvec4 noise = irwin_hall_noise_4D( uvec2( fcoord ), uint( iFrame ), 4 );\n#endif\n#if WITH_IMG_EXPOSURE\n  #if WITH_IMG_RODVISION\n\tfloat y = dot( col, VIS_SCOTOPIC_Y );\n\tfloat rod = y * VIS_LIMITS.z \/ ( y + VIS_LIMITS.z );\n   #if WITH_IMG_SHOTNOISE\n\tvec4 result = k * poisson_4d( vec4( col, rod ) \/ k, noise );\n\tcol = result.xyz;\n\trod = result.w;\n   #endif\n\tcol = g_exposure.z * col + .25 * COL_RODVISION * g_exposure.w * rod;\n  #else\n   #if WITH_IMG_SHOTNOISE\n\tcol = k.xyz * poisson_4d( vec4( col, 0 ) \/ k, noise ).xyz;\n   #endif\n\tcol = g_exposure.z * col;\n  #endif\n#endif\n}\n\nvec3 saturate_func( vec3 col )\n{\n#if WITH_IMG_SOFT_SATURATE == 1\n\treturn col * inversesqrt( col * col + .9526 );\n#elif WITH_IMG_SOFT_SATURATE == 2\n\treturn 1. - exp( -1.1277 * col );\n#elif WITH_IMG_SOFT_SATURATE == 3\n\treturn tanh( 1.0163 * col );\n#elif WITH_IMG_SOFT_SATURATE == 4\n\treturn sin( min( col * 1.0081, PI \/ 2. ) );\n#else\n\treturn saturate( col );\n#endif\n}\n\nvoid post_saturate( inout vec3 col )\n{\n\tvec3 orig = col;\n\tcol = saturate_func( col );\n#if WITH_IMG_COLPRESERVE\n\torig = saturate_func( orig * max( FRACT_1_4096, 1. - IMG_COLPRESERVE ) );\n\tcol = orig * hmax( col ) \/ hmax( orig );\n#endif\n}\n\nvec3 nnlsproj( const mat3 A, const vec3 x, const vec3 b )\n{\n\tmat3x3 At = transpose(A);\n\tvec3 invcolsq = 1. \/ vec3( lensq( At[0] ), lensq( At[1] ), lensq( At[2] ) );\n\tvec3 lambda = ZERO;\n\tvec3 tau = ZERO;\n\tfor( int k = 0; k < 5; ++k )\n\t{\n\t\tfor( int i = 0; i < 3; ++i )\n\t\t{\n\t\t\tfloat dist = dot( At[i], tau ) + x[i];\n\t\t\tfloat theta = max( -lambda[i], -dist * invcolsq[i] );\n\t\t\tlambda[i] += theta;\n\t\t\ttau += theta * At[i];\n\t\t}\n\t}\n\treturn x + A * tau;\n}\n\nvoid post_primaries( inout vec3 col )\n{\n#if WITH_IMG_PRIMARIES\n  #if WITH_IMG_BALANCE\n\tvec3 balance = pow( COL_D65 \/ COL_SUNLIGHT.xyz, vec3( IMG_BALANCE ) );\n  #else\n\t vec3 balance = ONE;\n  #endif\n\tvec3 tmp = IMG_PRIMARIES * ( col * balance ) \/ hmax( IMG_PRIMARIES * balance );\n  #if WITH_IMG_GAMUTWARN\n\tif( hmin( tmp ) < 0. )\n\t\ttmp = vec3(1,0,1) * dot( tmp, vec3( .2, .7, .1 ) );\n  #elif WITH_IMG_GAMUT_RESOLVE == 1\n\ttmp = mix( ONE * dot( col, COL_YWEIGHTS ), tmp, 1. \/ ( 1. + max( 0., hmax( -tmp ) ) ) );\n  #elif WITH_IMG_GAMUT_RESOLVE == 2\n\ttmp = nnlsproj( IMG_PRIMARIES, tmp, col );\n  #endif\n\tcol = max( ZERO, tmp );\n#endif\n}\n\nvoid post_dyngamma( inout vec3 col )\n{\n#if WITH_IMG_DYNGAMMA\n\tvec4 params = g_vrmode ? VIS_DYNGAMMA_PARAMS_VR : VIS_DYNGAMMA_PARAMS;\n\tfloat gamma = tanh( log2( g_exposure.y ) * params.w + params.z ) * params.y + params.x;\n\tcol = pow( col * 2. + 0.03, vec3( gamma ) ) * .5 - pow( 0.03, gamma ) * .5;\n#endif\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAIN\n\/\/ ----------------------------------------------------------------------------\n\nvec3 eotf( vec3 arg )\n{\n\treturn g_vrmode ?\n\t\tpow( arg, vec3( IMG_GAMMA_VR ) ) :\n#if WITH_IMG_SRGB_EOTF\n\t\tmix( arg \/ 12.92, pow( ( arg + .055 ) \/ 1.055, vec3( 2.4 ) ), lessThan( vec3( .04045 ), arg ) );\n#else\n\t\tpow( arg, vec3( IMG_GAMMA ) );\n#endif\n}\n\nvec3 oetf( vec3 arg )\n{\n\treturn g_vrmode ?\n\t\tpow( arg, vec3( 1. \/ IMG_GAMMA_VR ) ) :\n#if WITH_IMG_SRGB_EOTF\n\t\tmix( 12.92 * arg, 1.055 * pow( arg, vec3( .416667 ) ) - .055, lessThan( vec3( .0031308 ), arg ) );\n#else\n\t\tpow( arg, vec3( 1. \/ IMG_GAMMA ) );\n#endif\n}\n\nvec3 quantize_and_dither( vec3 col, float quant, vec2 fcoord )\n{\n\tvec3 noise = .5\/65536. +\n\t\t\t\t texelFetch( iChannel3, ivec2( fcoord \/ 8. ) & ( int( iChannelResolution[3] ) - 1 ), 0 ).xyz * 255.\/65536. +\n\t\t\t\t texelFetch( iChannel3, ivec2( fcoord )\t\t & ( int( iChannelResolution[3] ) - 1 ), 0 ).xyz * 255.\/256.;\n#if WITH_IMG_DITHER\n\tvec3 c0 = floor( oetf( col ) \/ quant ) * quant;\n\tvec3 c1 = c0 + quant;\n\tvec3 discr = mix( eotf( c0 ), eotf( c1 ), noise );\n\treturn mix( c0, c1, lessThan( discr, col ) );\n#else\n\treturn oetf( col );\n#endif\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n\tfcolor = vec4( ZERO, 1 );\n\n#if BUFFER_RUNLEVEL >= 5\n\n\tGS = gs_load( iChannel0, ADDR_GAME_STATE );\n\tPD = pd_load( iChannel0, pd_addr(1) );\n\n\tbool mapmode = ( GS.switches & GS_TRMAP ) == GS_TRMAP;\n\tg_subsample = mapmode ? 1. : gs_get_subsample( GS );\n\tg_subsample_inv = safediv( 1., g_subsample );\n\n\tif( fcoord.y >= 2. * g_subsample_inv && fcoord.y < iResolution.y - 2. * g_subsample_inv )\n\t{\n\t\tVS = vs_load( iChannel0, ADDR_VEHICLE_STATE );\n\t\tPS = ps_load( iChannel0, ps_addr(1) );\n\t\tLE = le_load( iChannel0, ADDR_LOCAL_ENV );\n\t\tg_exposure.xy = GS.exposure;\n\t\tg_exposure.zw = pow( GS.exposure + VIS_LIMITS.xy, vec2( g_vrmode ? VIS_EXPONENT_VR : VIS_EXPONENT ) );\n\t\tg_hudcolor = ( mapmode ? 1. : GS.hudbright ) * COL_P43PHOSPHOR;\n\t\tif( !mapmode && g_vrmode )\n\t\t\tg_hudcolor \/= GS.camzoom;\n\n\t\tvec2 uv = fcoord \/ iResolution.xy;\n\t\tvec2 sc = 2. * uv - 1.;\n\t\tvec2 ec = sc * vec2( 1, iResolution.y \/ iResolution.x );\n\t\tvec3 cc = ZERO;\n\t\tif( g_vrmode )\n\t\t{\n\t\t\tcc = g_vrdir * g_vrframe;\n\t\t\tif( !mapmode && dot( cc.yz, cc.yz ) >= 1.5 \/ GS.camzoom * cc.x * cc.x )\n\t\t\t\treturn;\n\t\t\tcc.yz \/= GS.camzoom;\n\t\t\tcc = normalize( cc );\n\t\t\tg_raydir = GS.camframe * g_vrframe * cc;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) \/ GS.camzoom, CAM_DISTORT ) ) );\n\t\t\tg_raydir = GS.camframe * cc;\n\t\t}\n\t\tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y \/ cc.x ) * dFdy( cc.z \/ cc.x ) );\n\t\tg_Kr = mat2x3( dFdx( g_raydir ), dFdy( g_raydir ) );\n\n\t\tvec3 col = post_get_image( uv );\n\n\t#if WITH_IMG_DIRECT\n\t\tfcolor.xyz = VIS_POST_EXPOSURE * col;\n\t\treturn;\n\t#endif\n\n\t\t\/\/*\n\t\tif( ( GS.switches & GS_CHEES ) == 0u )\n\t\t{\n\t\t\tg_overlayframe = vec4( 0, 0, iResolution.xy );\n\t\t\tif( g_vrmode )\n\t\t\t{\n\t\t\t\tfloat z = mapmode ? 1. : GS.camzoom;\n\t\t\t\tg_overlayframe.xy = project3d( vec3( 1.35, -1, +iResolution.y \/ iResolution.x ), z );\n\t\t\t\tg_overlayframe.zw = project3d( vec3( 1.35, +1, -iResolution.y \/ iResolution.x ), z ) - g_overlayframe.xy;\n\t\t\t}\n\t\t\tg_textscale = texelFetch( iChannel1, ivec2( ADDR_D_TEXTSCALE, 0 ), 0 ).xy * IMG_MIPMAP_HIDE \/ g_overlayframe.zw;\n\t\t\tg_textlodbias = log2( max( g_textscale.x, g_textscale.y ) );\n\t\t\tpost_overlay( col, g_vrmode ? fcoord - unViewport.xy : fcoord, cc );\n\t\t}\n\n\t\tif( !mapmode )\n\t\t{\n\t\t\tpost_sun_glare( col, g_raydir, uv.y );\n\t\t\tpost_vignette( col, cc );\n\t\t\tpost_exposure( col, fcoord );\n\t\t\tpost_dyngamma( col );\n\t\t\tcol *= VIS_POST_EXPOSURE;\n\t\t}\n\n\t\tpost_saturate( col );\n\t\tpost_primaries( col );\n\t\t\/\/*\/\n\n\t\tfcolor.xyz = quantize_and_dither( col, IMG_QUANTIZE, fcoord );\n\t}\n#endif \/\/ RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n\t{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n\tg_vrmode = true;\n\tvec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tg_vrframe[1] = normalize( horz );\n\tg_vrframe[2] = normalize( down );\n\tg_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n\tvec3 cent = g_vrframe[0] * dot( forw, g_vrframe[0] ) - 2. * ( unCorners[0] - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tg_vrfocus.xy = vec2( dot( cent, g_vrframe[1] ) \/ dot( horz, g_vrframe[1] ), dot( cent, g_vrframe[2] ) \/ dot( -down, g_vrframe[2] ) );\n\tg_vrfocus.zw = dot( forw, g_vrframe[0] ) \/ vec2( dot( horz, g_vrframe[1] ), dot( down, g_vrframe[2] ) );\n\tg_vrcoord = ( gl_FragCoord.xy - unViewport.xy ) \/ unViewport.zw;\n\tg_vrdir = normalize( mix( mix( unCorners[0], unCorners[1], g_vrcoord.x ),\n\t\t\t\t\t\t\t  mix( unCorners[3], unCorners[2], g_vrcoord.x ), g_vrcoord.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tmain_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 1 of 6: Common definitions\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\/\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ OPTIONS\n\/\/ ----------------------------------------------------------------------------\n\n\/\/ Set the overall quality level\n\n#define QUALITY_LEVEL\t\t\t\t3\n\n\t\/*\n\tQUALITY_LEVEL\t\t\t\t\t0\t\t1\t\t2\t\t3\t\t4\n\n\tWITH_ATM_BILATERAL_UPSAMPLE\t\t-\t\t-\t\t-\t\tx\t\tx\n\tWITH_ATM_TRAPEZ_QUADRATURE\t\t-\t\t-\t\t-\t\tx\t\tx\n\tWITH_ATM_TWEAKS\t\t\t\t\t-\t\t-\t\t-\t\t-\t\tx\n\tWITH_TRN_REFINE\t\t\t\t\t-\t\tx\t\tx\t\tx\t\tx\n\tWITH_TRN_CENTRAL_DIFF\t\t\t-\t\t-\t\tx\t\tx\t\tx\n\tWITH_TRN_HIGHP_RAYCAST\t\t\t-\t\t-\t\tx\t\tx\t\tx\n\tWITH_TRN_SURFACE_AA\t\t\t\t-\t\t-\t\t-\t\tx\t\tx\n\n\tATM_CLOUD_MAX_ITER\t\t\t\t20\t\t25\t\t30\t\t35\t\t40\n\tATM_CLOUD_TAU50_CUTOFF\t\t\t8\t\t9\t\t10\t\t11\t\t12\n\tATM_SCATTER_MAX_ITER\t\t\t30\t\t45\t\t60\t\t75\t\t90\n\tSCN_RAYCAST_MAX_ITER\t\t\t250\t\t300\t\t350\t\t400\t\t450\n\tSCN_SUBSAMPLE (starting value)\t2\t\t3\/2\t\t1\t\t1\t\t1\n\tTRN_MAX_REFINE_LEVELS\t\t\t-\t\t1\t\t2\t\t3\t\t4\n\tTRN_SAFE_SLOPE\t\t\t\t\t40\t\t45\t\t50\t\t55\t\t60\n\t*\/\n\n\/\/ Enables workarounds against driver bugs\n\n#define WORKAROUND_01_EXP2\t\t\t1\t\t\/\/ Ubuntu Studio 18 (bionic) GTX 760\n#define WORKAROUND_02_FOR_IF\t\t1\t\t\/\/ Ubuntu Studio 18 (bionic) GTX 760\n#define WORKAROUND_03_SWITCH\t\t1\t\t\/\/ Windows 7 ANGLE\/D3D backend\n#define WORKAROUND_04_VEC4\t\t\t1\t\t\/\/ Windows 10 ANGLE\/D3D backend \/ Edge Browser\n#define WORKAROUND_05_UVEC4\t\t\t1\t\t\/\/ Windows 7 ANGLE\/D3D backend\n#define WORKAROUND_07_KEYPRESS\t\t1\t\t\/\/ iMac 2010 27 inch Radeon 5670 M\n#define WORKAROUND_08_UINT2FLOAT\t1\t\t\/\/ Windows 7 ANGLE\/D3D wants uint -> int -> float in some cases?\n#define WORKAROUND_09_INT_EXP2\t\t1\t\t\/\/ Windows 10 ANGLE\/D3D does not like float( 1 << i )\n#define WORKAROUND_10_NOUNROLL\t\t1\t\t\/\/ iMac 2010 27 inch Radeon 5670 M\n#define WORKAROUND_11_MAP_CRASH\t\t0\t\t\/\/ Windows 10 ANGLE\/D3D crash when activating map mode (nvidia only?)\n#define WORKAROUND_12_TANH\t\t\t1\t\t\/\/ MacBook Pro 15' 2017 tanh goes inf for arg > 88\n\n\/\/ Restrict compilation up to a certain buffer from 1..5\n\/\/ (in the order A,B,C,D,Image)\n\n#define BUFFER_RUNLEVEL\t\t\t\t5\n\n\/\/ Other compile time options\n\n#define WITH_ATMOSPHERE\t\t\t\t1\n#define WITH_ATM_AMTL_CORRECTION\t1\n#define WITH_ATM_BILATERAL_UPSAMPLE ( QUALITY_LEVEL >= 3 )\n#define WITH_ATM_LAYER_A\t\t\t1\t\t\/\/ absorbtion layer (used for ozone)\n#define WITH_ATM_LAYER_E\t\t\t1\t\t\/\/ emission layer (used for airglow)\n#define WITH_ATM_LAYER_G\t\t\t1\t\t\/\/ ground layer (used for aerosols and water vapor)\n#define WITH_ATM_TRAPEZ_QUADRATURE\t( QUALITY_LEVEL >= 3 )\n#define WITH_ATM_TWEAKS\t\t\t\t( QUALITY_LEVEL >= 4 )\n\n#define WITH_CLOUDS\t\t\t\t\t1\n\n#define WITH_TERRAIN\t\t\t\t1\n#define WITH_TRN_AUX\t\t\t\t0\n#define WITH_TRN_CENTRAL_DIFF\t\t( QUALITY_LEVEL >= 2 )\n#define WITH_TRN_SHADOW\t\t\t\t1\n#define WITH_TRN_REFINE\t\t\t\t( QUALITY_LEVEL >= 1 )\n#define WITH_TRN_HIGHP_RAYCAST\t\t( QUALITY_LEVEL >= 2 )\n#define WITH_TRN_SURFACE_AA\t\t\t( QUALITY_LEVEL >= 3 )\n\n#define WITH_STARS\t\t\t\t\t1\n\n#define WITH_ILLUM_TEST\t\t\t\t0\t\t\/\/ illumination only, exposure measurements\n\nconst float SECONDS_PER_MINUTE\t\t= 10.;\nconst float ATM_SCALE\t\t\t\t= SECONDS_PER_MINUTE \/ 10.;\nconst float SCN_SCALE\t\t\t\t= SECONDS_PER_MINUTE \/ 10.;\nconst float TRN_SCALE\t\t\t\t= SECONDS_PER_MINUTE \/ 10.;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ CONSTANTS\n\/\/ ----------------------------------------------------------------------------\n\nconst float EULER = 2.71828183;\nconst float FRACT_1_16 = .0625;\nconst float FRACT_1_64 = .015625;\nconst float FRACT_1_256 = .000390625;\nconst float FRACT_1_4096 = 2.44140625e-4;\nconst float FRACT_1_65536 = 1.52587891e-5;\nconst float FRACT_1_1048576 = 9.53674316e-7;\nconst float FRACT_1_16777216 = 5.96046448e-8;\nconst float FRACT_15_16 = .9375;\nconst float FRACT_63_64 = .984375;\nconst float FRACT_127_128 = .9921875;\nconst float FRACT_4095_4096 = .999755859;\nconst float FRACT_2_TO_M_63 = 1.08420217e-19;\nconst vec3\tHALF = vec3(.5);\nconst mat3\tIDENTITY = mat3(1);\nconst float LN2 = .693147181;\nconst float LN10 = 2.30258509;\nconst float LOG2E = 1.44269504;\nconst vec3\tONE = vec3(1);\nconst float ONEOVERSQRTPI = .564189584;\nconst float ONEOVERSQRTTWOPI = .398942280;\nconst float PI = 3.14159265;\nconst float PIHALF = 1.57079632;\nconst uint\tRNG32 = 3934873077u;\nconst float TAU = 6.28318531;\nconst float SQRDEG = radians( radians( 1. ) );\nconst float SQRTHALF = .707106781;\nconst float SQRTTWO = 1.41421356;\nconst float SQRTPILN2HALF = 1.04345246;\nconst float\tSHR32 = 1. \/ 4294967296.;\nconst vec3\tUNIT_X = vec3(1,0,0);\nconst vec3\tUNIT_Y = vec3(0,1,0);\nconst vec3\tUNIT_Z = vec3(0,0,1);\nconst vec3\tZERO = vec3(0);\n\nconst float ATM_AMTL_CORRECTION = 2.605;\nconst int\tATM_CLOUD_MAX_ITER = 20 + 5 * QUALITY_LEVEL;\nconst float ATM_CLOUD_SHADOW_MIN_TAU = 350.;\nconst float ATM_CLOUD_SHADOW_MAX_TAU = 750.;\nconst float ATM_CLOUD_TAU50_CUTOFF = 15. + float( QUALITY_LEVEL );\nconst float ATM_CLOUD_T_CUTOFF = exp2( -ATM_CLOUD_TAU50_CUTOFF );\nconst int\tATM_SCATTER_MAX_ITER = 30 + 15 * QUALITY_LEVEL;\nconst int\tATM_SCATTER_MIN_ITER = 25;\n\nconst float CAM_FOV = 96.;\nconst float CAM_FOV_INNER = 94.;\nconst float CAM_FOCUS = 1. \/ tan( radians( CAM_FOV ) \/ 2. );\nconst float CAM_FOCUS_INNER = 1. \/ tan( radians( CAM_FOV_INNER ) \/ 2. );\nconst float CAM_DISTORT = max( 0.01, CAM_FOCUS_INNER \/ CAM_FOCUS - 1. );\n\nconst vec4\tCOL_AIRGLOW = 1.0154e-6 * vec4( .8670, 1.0899, .4332, 15. );\t\/\/ mixture of mostly 558 + some 589 and 630 nm emission lines\nconst vec4\tCOL_CANOPY_TINT = vec4( 0.8469, 0.9216, 0.8270, 0.7239 );\t\t\/\/ canopy tint color\nconst vec3\tCOL_D65 = vec3( 0.8857, 1.0512, 1.0884 );\nconst vec4\tCOL_NVISNSENS = vec4( .6, .3, .1, 1.3 );\t\t\t\t\t\t\/\/ night vision sensitivities\nconst float COL_NVISNSAT = 0.023;\t\t\t\t\t\t\t\t\t\t\t\/\/ night vision saturation luminance\nconst float COL_NVISNGAIN = 215.;\t\t\t\t\t\t\t\t\t\t\t\/\/ night vision amplification factor\nconst vec3\tCOL_RODVISION = vec3( 0.4856, 0.4856, 0.9713 );\t\t\t\t\t\/\/ color of 2 parts S-cone over 1 part L + M cones\nconst vec3\tCOL_P20PHOSPHOR = vec3( 0.8975, 1.0930, 0.0934 );\t\t\t\t\/\/ color of P20 phosphor emission spectrum\nconst vec3\tCOL_P43PHOSPHOR = vec3( 0.5335, 1.2621, 0.1874 );\t\t\t\t\/\/ color of P43 phosphor emission spectrum\nconst vec3\tCOL_PRIMARYRED = vec3( 0.4411, 0.0000, 0.0000 );\t\t\t\t\/\/ brightest physically realizable in-gamut red material color\nconst vec4\tCOL_STARLIGHT = 0.9178e-6 * vec4( 0.9714, 1.0123, 1.0341, .3 );\t\/\/ luminance and color of total starlight\nconst float COL_STARLIGHT_ISL = 0.7875;\t\t\t\t\t\t\t\t\t\t\/\/ fraction of integrated starlight\nconst vec4\tCOL_SUNLIGHT = vec4( 0.9420, 1.0269, 1.0242, .3 );\t\t\t\t\/\/ color of sunlight emission spectrum\nconst vec4\tCOL_THRESHOLD = vec4( 0.8699, 1.0000, 1.2022, 0.4239 ) * 3.462e-8;\t\/\/ threshold of vision (here w is for rods, not for IR)\nconst float COL_THRESHOLD_AREA = .25 * SQRDEG;\t\t\t\t\t\t\t\t\/\/ reference integration area for threshold\nconst float COL_THRESHOLD_TIME = 1. \/ 60.;\t\t\t\t\t\t\t\t\t\/\/ reference integration time for threshold\nconst vec4\tCOL_XENONARC = vec4( 0.8203, 1.0856, 1.0254, 0.25 );\t\t\t\/\/ color of xenon arc emission light spectrum\nconst vec3\tCOL_YWEIGHTS = vec3( 0.3161, 0.6543, 0.0296 );\t\t\t\t\t\/\/ luminance weights of the 615,535,445 primaries\n\nconst float\tFDM_MASS_SCALE = 1.00307805 \/ SCN_SCALE;\nconst int\tFDM_MIN_ITER = 4;\nconst int\tFDM_MAX_ITER = 30;\nconst float FDM_STD_G = 9.83683536 \/ SCN_SCALE;\n\nconst vec2\tHMD_BORDER = vec2( .80, .40 );\nconst vec2\tHMD_BORDER_LAD = vec2( .40, .30 );\nconst vec2\tHMD_BORDER_SYM = vec2( .65, .35 );\n\nconst float IMG_EXPOSURE_MAX = 8.;\nconst int\tIMG_EXPOSURE_SAMPLES = 1024;\nconst float IMG_MIPMAP_HIDE = 16777216.;\n\nconst float\tSCN_ATM_SUBSAMPLE_RATIO = 2.;\nconst int\tSCN_MAX_PRIMITIVES = 40;\nconst int\tSCN_RAYCAST_MAX_ITER = 250 + 50 * QUALITY_LEVEL;\nconst float SCN_RAYCAST_MIN_ADVANCE = .002;\nconst float SCN_RAYCAST_MIN_ADVANCE_SCALE = 8. \/ float( SCN_RAYCAST_MAX_ITER );\nconst int\tSCN_RAYCAST_SHADOW_MAX_ITER = SCN_RAYCAST_MAX_ITER * 3 \/ 4;\nconst float SCN_RAYCAST_SHADOW_MIN_ADVANCE = .006;\nconst float SCN_RAYCAST_SHADOW_MIN_ADVANCE_SCALE = 8. \/ float( SCN_RAYCAST_SHADOW_MAX_ITER );\nconst float SCN_RAYCAST_SHADOW_HBIAS = .002;\nconst float SCN_RAYCAST_SHADOW_HSCALE = .005;\nconst float SCN_RAYCAST_SHADOW_TBIAS = .001;\nconst float SCN_SUBSAMPLE = max( 1., 2. - float( QUALITY_LEVEL ) \/ 2. );\nconst float SCN_ZNEAR = 0.001;\nconst float SCN_ZFAR = 99999.;\n\nconst float TRN_AO_LOD_OFFSET = 2.;\nconst float TRN_LOD_BIAS = 1.;\nconst float TRN_MAX_LEVELS = 16.;\nconst float TRN_MAX_REFINE_LEVELS = float( QUALITY_LEVEL );\nconst float TRN_SAFE_SLOPE = 40. + 5. * float( QUALITY_LEVEL );\nconst float TRN_SAFE_SLOPE_FACTOR = tan( radians( 90. - TRN_SAFE_SLOPE ) );\nconst float TRN_UPDATE_THRESHOLD = 9.;\nconst float TRN_UV_RANGE = SQRTTWO;\nconst float TRN_UV_RANGE_INV = 1. \/ TRN_UV_RANGE;\n\nconst float TXT_FONT_SPACING = .50;\nconst float TXT_FONT_HOFFSET = .27;\nconst float TXT_FONT_BACKSLANT = .15;\nconst int\tTXT_FMT_MAX_LEN = 59;\nconst int\tTXT_FMT_MAX_COUNT = 52;\nconst uint\tTXT_FMT_FLAG_CENTER = 0x10u;\nconst uint\tTXT_FMT_FLAG_RIGHT = 0x20u;\nconst uint\tTXT_FMT_FLAG_HUDCLIP = 0x80u;\nconst uint\tTXT_FMT_LENGTH_MASK = 0x0fu;\nconst int\tTXT_MSG_MAX_PHRASES = 7;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MEMORY MAP\n\/\/ ----------------------------------------------------------------------------\n\nbool in_addr_range( ivec2 sc, ivec2 addr, int size, int count )\n\t{ return sc.y >= addr.x && sc.y < addr.x + count &&\n\t\t\t sc.x >= addr.y && sc.x < addr.y + size; }\n\nvec4 memload( sampler2D ch, ivec2 addr, int offs )\n\t{ return texelFetch( ch, addr.yx + ivec2( offs, 0 ), 0 ); }\n\nmat2x3 memload_mat2x3( sampler2D ch, ivec2 addr, int offs )\n\t{ return mat2x3( memload( ch, addr, offs ).xyz, memload( ch, addr, offs + 1 ).xyz ); }\n\nmat3 memload_mat3( sampler2D ch, ivec2 addr, int offs )\n\t{ return mat3( memload( ch, addr, offs ).xyz, memload( ch, addr, offs + 1 ).xyz, memload( ch, addr, offs + 2 ).xyz ); }\n\nvec3 memload_www( sampler2D ch, ivec2 addr, int offs )\n\t{ return vec3( memload( ch, addr, offs ).w, memload( ch, addr, offs + 1 ).w, memload( ch, addr, offs + 2 ).w ); }\n\nvoid memstore( vec4 value, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = value; }\n\nvoid memstore( vec3 value1, float value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = vec4( value1, value2 ); }\n\nvoid memstore( vec2 value1, vec2 value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = vec4( value1, value2 ); }\n\nvoid memstore( mat3 value1, vec3 value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n{\n\tif( sc.y == addr.x && sc.x == addr.y + offs )\n\t\tfc = vec4( value1[0], value2.x );\n\tif( sc.y == addr.x && sc.x == addr.y + offs + 1 )\n\t\tfc = vec4( value1[1], value2.y );\n\tif( sc.y == addr.x && sc.x == addr.y + offs + 2 )\n\t\tfc = vec4( value1[2], value2.z );\n}\n\nvoid memstore( mat3 value, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ memstore( value, ZERO, addr, offs, sc, fc ); }\n\n\/\/ A buffer addresses\n\n\/*\n\t.\t\t\t\t  .\t\t\t\t\t.\t\t\t\t  .\n\t.\t\t\t\t  .\t\t\t\t\t.\t\t\t\t  .\n\t.\t\t\t\t  .\t\t\t\t\t.\t\t\t\t  .\n\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\tppppppp. ........ TTT..... TTT..... aaaaaaaa aaaa.... ssssss.. ........\n\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ AA...... ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ssssss.. ........\n\tEEEEEEEE ........ MMMMMMMM MMMMMMM. ........ ........ ssssss.. ........\n\n\t........ ........ ........ ........ ........ ........ ssssss.. ........\n\t........ ........ EEEE.... ........ ........ ........ ssssss.. ........\n\t........ ........ ........ ........ ........ ........ ssssss.. ........\n\tsizes... ........ TTT..... TTT..... ........ ........ ssssss.. ........\n\t........ ........ ........ ........ ........ ........ ssssss.. ........ .\n\tD....... ........ VVVVVVVV VVVVVVVV VVV..... ........ ssssss.. ........ .\n\t........ ........ ........ ........ ........ ........ ssssss.. ........ .\n\tR....... ........ GGGGGGGG GGG..... ........ ........ ssssss.. ........ const data ...\n*\/\n\nconst ivec2\tADDR_RESOLUTION =\t\tivec2( 0, 0 );\nconst ivec2\tADDR_DTIME =\t\t\tivec2( 2, 0 );\nconst ivec2\tADDR_DATASIZES =\t\tivec2( 4, 0 );\nconst ivec2\tADDR_EXPOSURE =\t\t\tivec2( 8, 0 );\n\nconst ivec2\tADDR_GAME_STATE =\t\tivec2( 0, 16 );\nconst ivec2\tADDR_VEHICLE_STATE =\tivec2( 2, 16 );\nconst ivec2\tADDR_LOCAL_TS =\t\t\tivec2( 4, 16 );\nconst ivec2\tADDR_LOCAL_TS_LAST =\tivec2( 4, 24 );\nconst ivec2\tADDR_LOCAL_ENV =\t\tivec2( 6, 16 );\n\nconst ivec2\tADDR_MSG_QUEUE =\t\tivec2( 8, 16 );\nconst ivec2 ADDR_ACHIEVEMENTS =\t\tivec2( 12, 16 );\n\nconst ivec2\tADDR_PLANET_STATES =\tivec2( 16, 0 );\nconst ivec2 ADDR_TRN_SAMPLERS =\t\tivec2( 16, 16 );\nconst ivec2 ADDR_TRN_SAMPLERS_LAST =ivec2( 16, 24 );\nconst ivec2\tADDR_ATM_CONTEXTS =\t\tivec2( 16, 32 );\nconst ivec2 ADDR_PLANET_DATA =\t\tivec2( 16, 88 );\n\nconst ivec2\tADDR_SCENE_OBJECTS =\tivec2( 0, 48 );\nconst ivec2 ADDR_SCENE_DATA =\t\tivec2( 0, 64 );\nconst ivec2 ADDR_MENU_DATA =\t\tivec2( 0, 72 );\nconst ivec2 ADDR_START_DATA =\t\tivec2( 0, 80 );\n\n\/\/ B buffer lower letterbox addresses\n\nconst int ADDR_B_CAMPOS_SAMPLE = 0;\nconst int ADDR_B_WAYPOINT_SAMPLE = 8;\nconst int ADDR_B_LOC_DATA = 16;\nconst int ADDR_B_SCENE_DATA = 48;\n\n\/\/ D buffer lower letterbox addresses\n\nconst int ADDR_D_SUN_VISIBILITY = 0;\nconst int ADDR_D_TEXTSCALE = 8;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ UTILITIES\n\/\/ ----------------------------------------------------------------------------\n\n#define FORCE_EVAL( x ) clamp( x, -1e12, 1e12 )\n#define NOUNROLL( x ) max( -iFrame, x )\n\n\/\/ screen coordinate utils\n\n#define sc2uv( _sc ) ( (_sc) \/ iResolution.xy )\n#define uv2sc( _uv ) ( (_uv) * iResolution.xy )\n#define sc2ec( _sc ) ( ( 2. * (_sc) - iResolution.xy ) \/ iResolution.x )\n#define ec2sc( _ec ) ( .5 * ( (_ec) * iResolution.x + iResolution.xy ) )\n#define sc2mc( _sc ) ( ( 2. * (_sc) - iResolution.xy ) \/ iResolution.y )\n#define mc2sc( _ec ) ( .5 * ( (_ec) * iResolution.y + iResolution.xy ) )\n\n\/\/ type-generic utils\n\n#define cosasin(x) sqrt( ( 1. - (x) ) * ( 1. + (x) ) )\n#define cosatan(x) inversesqrt( (x) * (x) + 1. )\n#define cube(x) ( (x) * (x) * (x) )\n#define expm1(x) ( exp(x) - 1. )\n#define log1p(x) log( (x) + 1. )\t  \/\/ - ( FORCE_EVAL( FORCE_EVAL( (x) + 1. ) - 1. ) - (x) ) \/ ( (x) + 1. ) )\n#define lensq(x) dot( x, x )\n#define project(a,b) ( (b) * dot( a, b ) )\n#define project_n(a,b) ( (b) * dot( a, b ) \/ lensq(b) )\n#define reject(a,b) ( (a) - project(a,b) )\n#define reject_max(a,b) ( (a) - (b) * max( 0., dot( a, b ) ) )\n#define reject_min(a,b) ( (a) - (b) * min( 0., dot( a, b ) ) )\n#define reject_n(a,b) ( (a) - project_n( a, b ) )\n#define sinacos(x) sqrt( ( 1. - (x) ) * ( 1. + (x) ) )\n#define sinatan(x) ( (x) \/ sqrt( (x) * (x) + 1. ) )\n#define softadd(a,b) ( (a) + (b) - (a) * (b) )\n#define softdiv( a, b, scale ) ( (a) * (b) \/ ( (scale) * (scale) + (b) * (b) ) )\n#define softnormalize( a, scale ) ( softdiv( a, length(a), scale ) )\n#define safediv( a, b ) softdiv( a, b, FRACT_1_16777216 )\n#define safenormalize( a ) softnormalize( a, FRACT_1_16777216 )\n#define saturate(a) clamp( a, 0., 1. )\n#define smin1(a,S) ( 1. - log( 1. + exp( ( 1. - (a) ) \/ (S) ) ) * S )\n#define sqdiff(a,b) ( ( (a) - (b) ) * ( (a) + (b) ) )\n#define square(x) ( (x) * (x) )\n\n\/\/ type-specific utils\n\nvec2 barrel_distort( vec2 ec, float a ) { return ec \/ max( 0., 1. + a * ( 1. - dot( ec, ec ) ) ); }\nvec2 barrel_distort_inv( vec2 ec, float a ) { float ec2 = dot( ec, ec ); float u = a * ( a + 1. ) * ec2; return u < 1. \/ 4096. ? ec * ( a + 1. ) : ec \/ ( 2. * a * ec2 ) * ( sqrt( 4. * u + 1. ) - 1. ); }\nfloat barrel_distort_rate( float ec2, float a ) { return ( a + 1. + a * ec2 ) \/ square( a + 1. - a * ec2 ); }\nfloat chebychev6( float x ) { float x2 = x * x; return ( ( 32. * x2 - 48. ) * x2 + 18. ) * x2 - 1.; }\nfloat fresnel_schlick( float r0, float mu ) { mu = 1. - mu; return mix( r0, 1., mu * mu * mu * mu * mu ); }\nfloat hmax( vec2 arg ) { return max( arg.x, arg.y ); }\nfloat hmax( vec3 arg ) { return max( arg.x, max( arg.y, arg.z ) ); }\nfloat hmax( vec4 arg ) { return max( arg.x, max( arg.y, max( arg.z, arg.w ) ) ); }\nfloat hmin( vec2 arg ) { return min( arg.x, arg.y ); }\nfloat hmin( vec3 arg ) { return min( arg.x, min( arg.y, arg.z ) ); }\nfloat hmin( vec4 arg ) { return min( arg.x, min( arg.y, min( arg.z, arg.w ) ) ); }\nfloat ldexp( float a, int e ) { return a * intBitsToFloat( ( e + 127 ) << 23 ); }\nvec3 length_normalize( vec2 x ) { float p = dot( x, x ); float q = inversesqrt( max( FRACT_1_16777216 * FRACT_1_16777216, p ) ); return vec3( x, p ) * q; }\nvec4 length_normalize( vec3 x ) { float p = dot( x, x ); float q = inversesqrt( max( FRACT_1_16777216 * FRACT_1_16777216, p ) ); return vec4( x, p ) * q; }\nvec4 length_normalize_r( vec3 x, vec3 r ) { vec3 s = x + r; float p = dot( x, x ); float q = inversesqrt( max( FRACT_1_16777216 * FRACT_1_16777216, p ) ); return vec4( x, p ) * q; }\nfloat pack_normal( vec3 a ) { uvec3 b = uvec3( round( 511. * a ) + 512. ) & 1023u; return uintBitsToFloat( ( b.x << 20u ) | ( b.y << 10u ) | b.z ); }\nvec4 pack_uvec4( uvec4 a ) { return vec4( uintBitsToFloat( a.x ), uintBitsToFloat( a.y ), uintBitsToFloat( a.z ), uintBitsToFloat( a.w ) ); }\nfloat parabolstep( float a, float b, float x ) { float t = clamp( ( x - a ) \/ ( b - a ), 0., 1. ) - .5; return .5 - 2. * ( abs( t ) * t - t ); }\nvec2 perp( vec2 arg ) { return vec2( -arg.y, arg.x ); }\nvoid rot90( inout vec3 a, inout vec3 b ) { vec3 tmp = a; a = b; b = -tmp; }\nvec3 simple_refract( vec3 I, vec3 N ) { return\tI - .8 * ( 1.5 - dot( N, I ) ) * N; }\nvec3 simple_refract_inv( vec3 I, vec3 R, vec3 Z ) { vec3 result = normalize( I - R * length( simple_refract( I, Z ) ) ); return I - R * length( simple_refract( I, result ) ); }\nmat3 skew( vec3 n ) { return mat3( 0, n.z, -n.y, -n.z, 0, n.x, n.y, -n.x, 0 ); }\nvec3 unpack_normal( float a ) { uint b = floatBitsToUint( a ); return ( vec3( uvec3( b >> 20u, b >> 10u, b ) & 1023u ) - 512. ) \/ 511.; }\nuvec4 unpack_uvec4( vec4 a ) { return uvec4( floatBitsToUint( a.x ), floatBitsToUint( a.y ), floatBitsToUint( a.z ), floatBitsToUint( a.w ) ); }\n\n#if WORKAROUND_01_EXP2\nfloat exp2pp( float x ) { return exp2( max( x, -126. ) ); }\nvec2 exp2pp( vec2 x ) { return exp2( max( x, -126. ) ); }\nvec3 exp2pp( vec3 x ) { return exp2( max( x, -126. ) ); }\nvec4 exp2pp( vec4 x ) { return exp2( max( x, -126. ) ); }\n#else\nfloat exp2pp( float x ) { return exp2(x); }\nvec2 exp2pp( vec2 x ) { return exp2(x); }\nvec3 exp2pp( vec3 x ) { return exp2(x); }\nvec4 exp2pp( vec4 x ) { return exp2(x); }\n#endif\n\n\/\/ ray utils\n\nstruct Ray { vec3 o; vec3 d; };\n\nvec2 sphere_impact( vec3 o, vec3 d )\n{\n\tfloat q = dot( o, d );\n\t\/*\n\treturn vec2( dot( o, o ) - q * q, q );\n\t\/*\/\n\tvec3 h = o - d * q \/ dot( d, d );\n\treturn vec2( dot( h, h ), q );\n\t\/\/*\/\n}\n\nvec2 sphere_limits( float R, vec2 impact )\n{\n\tfloat D = R * R - impact.x;\n\treturn sqrt(D) * vec2( -1, 1 ) - impact.y;\n}\n\n\/\/ utils for automatic partial derivatives\n\nconst vec4 HALF_D = vec4( ZERO, .5 );\nconst vec4 ONE_D = vec4( ZERO, 1 );\nconst vec4 TWO_D = vec4( ZERO, 2 );\nconst vec4 ZERO_D = vec4(0);\n\nvec4 abs_d( vec4 a ) { return a * sign( a.w ); }\nvec4 asin_d( vec4 a ) { return vec4( a.xyz * inversesqrt( 1. - a.w * a.w ), asin( a.w ) ); }\nvec4 atan_d( vec4 a ) { return vec4( a.xyz \/ ( 1. + a.w * a.w ), atan( a.w ) ); }\nvec4 atan2_d( vec4 a, vec4 b ) { return vec4( ( a.xyz * b.w - b.xyz * a.w ) \/ ( square( b.w ) * ( 1. + square( a.w \/ b.w ) ) ), atan( a.w, b.w ) ); }\nvec4 atanh_d( vec4 a ) { return vec4( a.xyz \/ ( 1. - a.w * a.w ), atanh( a.w ) ); }\nvec4 clamp_d( vec4 x, vec4 a, vec4 b ) { return x.w < a.w ? a : x.w < b.w ? x : b; }\nvec4 const_d( float x ) { return vec2( 0, x ).xxxy; }\nvec4 cos_d( vec4 a ) { return vec4( -a.xyz * sin( a.w ), cos( a.w ) ); }\nvec4 cosh_d( vec4 a ) { return vec4( a.xyz * sinh( a.w ), cosh( a.w ) ); }\nvec4 div_d( vec4 a, vec4 b ) { return vec4( ( a.xyz * b.w - a.w * b.xyz ) \/ square( b.w ), a.w \/ b.w ); }\nvec4 exp_d( vec4 a ) { return exp( a.w ) * vec4( a.xyz, 1 ); }\nvec4 hypot_d( vec4 a, vec4 b ) { float h = sqrt( a.w * a.w + b.w * b.w ); return vec4( ( a.xyz * a.w + b.xyz * b.w ) \/ h, h ); }\nvec4 log_d( vec4 a ) { return vec4( a.xyz \/ a.w, log( a.w ) ); }\nvec4 max_d( vec4 a, vec4 b ) { return b.w < a.w ? a : b; }\nvec4 min_d( vec4 a, vec4 b ) { return a.w < b.w ? a : b; }\nvec4 mix_d( vec4 a, vec4 b, vec4 t ) { return mix( a, b, t.w ) + vec4( t.xyz, 0 ) * ( b.w - a.w ); }\nvec4 mul_d( vec4 a, vec4 b ) { return a * b.w + vec4( a.w * b.xyz, 0 ); }\nvec4 pow_d( vec4 a, float b ) { return a * pow( a.w, b - 1. ) * vec2( b, 1 ).xxxy; }\nvec4 saturate_d( vec4 a ) { return a.w < 0. ? ZERO_D : a.w < 1. ? a : ONE_D; }\nvec4 sin_d( vec4 a ) { return vec4( a.xyz * cos( a.w ), sin( a.w ) ); }\nvec4 sinh_d( vec4 a ) { return vec4( a.xyz * cosh( a.w ), sinh( a.w ) ); }\nvec4 smin1_d( vec4 a, float S ) { vec4 arg = ( ONE_D - a ) \/ S; return arg.w < 16. ? ONE_D - log_d( ONE_D + exp_d( arg ) ) * S : a; }\nvec4 sqrt_d( vec4 a ) { return a * inversesqrt( a.w ) * vec2( .5, 1 ).xxxy; }\nvec4 square_d( vec4 a ) { return a * a.w * vec2( 2, 1 ).xxxy; }\nvec4 tan_d( vec4 a ) { float t = tan( a.w ); return vec4( a.xyz * ( 1. + t * t ), t ); }\nvec4 tanh_d( vec4 a ) { float t = tanh( a.w ); return vec4( a.xyz * ( 1. - t * t ), t ); }\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ GEODESY\n\/\/ ----------------------------------------------------------------------------\n\nvec2 sincospi( float a )\n{\n\t\/\/ see my other shadertoy:\n\t\/\/ https:\/\/www.shadertoy.com\/view\/WlXczs\n\tvec2 b = vec2( a - .5, a );\n\tvec2 x = .5 - abs( b - 2. * round( .5 * b ) );\n\tvec2 x2 = x * x;\n\treturn ( ( ( ( .0864348859 * x2 - .603019178 ) * x2 + 2.55088973 ) * x2 - 5.1677556 ) * x2 + 3.14159298 ) * x;\n}\n\nvec3 nav2r( vec3 nav )\n{\n\tvec2 sclat = sincospi( nav.x \/ 180. );\n\tvec2 sclong = sincospi( nav.y \/ 180. );\n\treturn nav.z * vec3( sclat.y * sclong.y, sclat.y * sclong.x, sclat.x );\n}\n\nvec3 r2nav( vec3 r )\n{\n\treturn vec3(\n\t\tdegrees( atan( r.z, length( r.xy ) ) ),\n\t\tdegrees( atan( r.y, r.x ) ),\n\t\tlength(r) );\n}\n\nmat3 bearing2B( vec3 r, float bearing )\n{\n\tif( dot( r.xy, r.xy ) > 0. )\n\t{\n\t\tvec3 east = normalize( cross( UNIT_Z, r ) );\n\t\tvec3 north = normalize( cross( r, east ) );\n\t\tvec2 scb = sincospi( bearing \/ 180. );\n\t\tvec3 dir = scb.y * north + scb.x * east;\n\t\treturn mat3( dir, -normalize( cross( r, dir ) ), -normalize(r) );\n\t}\n\telse\n\t{\n\t\tvec3 dir = vec3( cos( radians( bearing ) ), sin( radians( bearing ) ), 0 );\n\t\treturn mat3( dir, -normalize( cross( r, dir ) ), -normalize(r) );\n\t}\n}\n\nfloat B2bearing( vec3 r, vec3 B )\n{\n\tvec3 east = normalize( cross( UNIT_Z, r ) );\n\tvec3 north = normalize( cross( r, east ) );\n\treturn mod( degrees( atan( dot( B, east ), dot( B, north ) ) ), 360. );\n}\n\nvec4 navb( vec3 r, vec3 B )\n\t{ return vec4( r2nav(r), B2bearing( r, B ) ); }\n\nvec2 arc_distance( vec3 a, vec3 b )\n{\n\tvec4 an = length_normalize(a);\n\tvec4 bn = length_normalize(b);\n\tvec4 dn = an - bn;\n\tfloat arclen = atan( length( reject( dn.xyz, an.xyz ) ), dot( bn.xyz, an.xyz ) );\n\treturn vec2( length( vec2( .5 * ( an.w + bn.w ) * arclen, dn.w ) ), an.w - bn.w );\n}\n\nvec2 rot2d( vec2 r, float angle )\n{\n\tangle = radians( angle );\n\tfloat s = sin( angle );\n\tfloat c = cos( angle );\n\treturn r * mat2( c, s, -s, c );\n}\n\nmat3 spin( mat3 B, vec3 omega )\n{\n\tB[0] = normalize( B[0] + cross( omega, B[0] ) );\n\tB[1] = normalize( B[1] + cross( omega, B[1] ) );\n\tB[2] = normalize( cross( B[0], B[1] ) );\n\tB[1] = cross( B[2], B[0] );\n\treturn B;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ START POSITIONS\n\/\/ ----------------------------------------------------------------------------\n\nstruct StartData\n{\n\tuvec4 name;\n\tivec4 iparams;\n\tvec4 params;\n};\n\nconst int START_DATA_SIZE = 3;\nconst int START_DATA_COUNT = 22;\n\nivec2 st_addr( int index )\n\t{ return ADDR_START_DATA + ivec2( index, 0 ); }\n\nbool in_st_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_START_DATA, START_DATA_SIZE, START_DATA_COUNT ); }\n\nStartData st_load( sampler2D ch, ivec2 addr )\n{\n\treturn StartData(\n\t\tunpack_uvec4( memload( ch, addr, 0 ) ),\n\t\tivec4( memload( ch, addr, 1 ) ),\n\t\tmemload( ch, addr, 2 ) );\n}\n\nvoid st_store( StartData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( pack_uvec4( self.name ), addr, 0, sc, fc );\n\tmemstore( vec4( self.iparams ), addr, 1, sc, fc );\n\tmemstore( self.params, addr, 2, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ LOCATION DATA\n\/\/ ----------------------------------------------------------------------------\n\nstruct LocData\n{\n\tvec4 zone;\t\t\t\/\/ xy = lat\/long, z = size, w = bearing of local grid\n\tuvec4 name;\t\t\t\/\/ phrase of location name\n};\n\nconst int LOC_DATA_SIZE = 2;\nconst int LOC_DATA_COUNT = ( ADDR_B_SCENE_DATA - ADDR_B_LOC_DATA ) \/ LOC_DATA_SIZE;\n\nivec2 ld_addr_b( int index )\n\t{ return ivec2( 0, ADDR_B_LOC_DATA + LOC_DATA_SIZE * index ); }\n\nLocData ld_load( sampler2D ch, ivec2 addr )\n{\n\treturn LocData(\n\t\tmemload( ch, addr, 0 ),\n\t\tunpack_uvec4( memload( ch, addr, 1 ) ) );\n}\n\nvoid ld_store( LocData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.zone, addr, 0, sc, fc );\n\tmemstore( pack_uvec4( self.name ), addr, 1, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE DATA\n\/\/ ----------------------------------------------------------------------------\n\nstruct SceneData\n{\n\tvec4 tybr;\t\t\t\/\/ x = type, y = bounding radius\n\tvec4 navb;\t\t\t\/\/ x = lat, y = long, z = alt, w = heading\n\tvec4 paramsA;\n\tvec4 paramsB;\n};\n\nconst int SCENE_DATA_SIZE = 4;\nconst int SCENE_DATA_COUNT = 76;\n\nivec2 sd_addr_b( int index )\n\t{ return ivec2( 0, ADDR_B_SCENE_DATA + SCENE_DATA_SIZE * index ); }\n\nSceneData sd_load( sampler2D ch, ivec2 addr )\n{\n\treturn SceneData(\n\t\tmemload( ch, addr, 0 ),\n\t\tmemload( ch, addr, 1 ),\n\t\tmemload( ch, addr, 2 ),\n\t\tmemload( ch, addr, 3 ) );\n}\n\nvoid sd_store( SceneData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.tybr, addr, 0, sc, fc );\n\tmemstore( self.navb, addr, 1, sc, fc );\n\tmemstore( self.paramsA, addr, 2, sc, fc );\n\tmemstore( self.paramsB, addr, 3, sc, fc );\n}\n\nconst int SCNOBJ_TYPE_INVALID = 0;\nconst int SCNOBJ_TYPE_2D = 1000;\nconst int SCNOBJ_TYPE_RUNWAY = 1001;\nconst int SCNOBJ_TYPE_3D = 2000;\nconst int SCNOBJ_TYPE_PRIMITIVE = 2001;\nconst int SCNOBJ_TYPE_COMPOUND = 3000;\nconst int SCNOBJ_TYPE_TOWER = 3001;\nconst int SCNOBJ_TYPE_LIGHTHOUSE = 3002;\n\nconst int SCNOBJ_PRIMITIVE_SPHERE = 1;\nconst int SCNOBJ_PRIMITIVE_CUBE = 2;\nconst int SCNOBJ_PRIMITIVE_CYLINDER = 3;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE OBJECT\n\/\/ ----------------------------------------------------------------------------\n\nstruct SceneObj\n{\n\tmat3 B;\n\tvec3 r;\n\tvec4 tybr;\n\tvec4 paramsA;\n\tvec4 paramsB;\n};\n\nconst int SCENE_OBJECT_SIZE = 6;\n\nivec2 so_objaddr( int index )\n\t{ return ADDR_SCENE_OBJECTS + ivec2( index, 0 ); }\n\nivec2 so_dataaddr( int index )\n\t{ return ADDR_SCENE_DATA + ivec2( index, 0 ); }\n\nbool in_so_objrange( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_SCENE_OBJECTS, SCENE_OBJECT_SIZE, SCN_MAX_PRIMITIVES ); }\n\nbool in_so_datarange( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_SCENE_DATA, SCENE_OBJECT_SIZE, SCENE_DATA_COUNT ); }\n\nSceneObj so_load( sampler2D ch, ivec2 addr )\n{\n\treturn SceneObj(\n\t\tmemload_mat3( ch, addr, 0 ),\n\t\tmemload_www( ch, addr, 0 ),\n\t\tmemload( ch, addr, 3 ),\n\t\tmemload( ch, addr, 4 ),\n\t\tmemload( ch, addr, 5 ) );\n}\n\nvoid so_store( SceneObj self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.B, self.r, addr, 0, sc, fc );\n\tmemstore( self.tybr, addr, 3, sc, fc );\n\tmemstore( self.paramsA, addr, 4, sc, fc );\n\tmemstore( self.paramsB, addr, 5, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ KEPLER ORBITAL ELEMENTS\n\/\/ ----------------------------------------------------------------------------\n\nstruct Kepler\n{\n\tfloat p;\t\t\/\/ semi-latus rectum\n\tfloat e;\t\t\/\/ eccentricity\n\tfloat i;\t\t\/\/ inclination\n\tfloat O;\t\t\/\/ longitude of ascending node (Omega)\n\tfloat w;\t\t\/\/ argument of periapsis (omega)\n};\n\n#define KEPLERA( a, e, i, O, w ) Kepler( a * ( 1. - (e) ) * ( 1. + (e) ), e, i, O, w )\n\nfloat kp_semimajor( Kepler self )\n\t{ return self.p \/ ( 1. - self.e * self.e ); }\n\nfloat kp_init( inout Kepler self, vec3 r, vec3 v, float GM )\n{\n\tfloat nu = 0.;\n\tfloat r2 = dot( r, r );\n\tvec3 h = cross( r, v );\n\tfloat h2 = dot( h, h );\n\tfloat H = sqrt( h2 );\n\tfloat R = sqrt( r2 );\n\tvec3 e = cross( v, h ) \/ GM - r \/ R;\n\tfloat e2 = dot( e, e );\n\tself.e = sqrt( e2 );\n\tself.p = h2 \/ GM;\n\tfloat cosi = clamp( h.z \/ H, -1., 1. );\n\tself.i = atan( length( h.xy ), h.z );\n\tself.O = ( cosi == 1. ? 0. : cosi == -.1 ? PI : atan( h.x, -h.y ) );\n\tif( self.e >= .00005 )\n\t{\n\t\tfloat arglong =\n\t\t\tcosi == 1. ? atan( r.y, r.x ) :\n\t\t\tcosi == -1. ? atan( r.y, -r.x ) :\n\t\t\tatan( r.z * H, r.y * h.x - r.x * h.y );\n\t\tfloat u = self.p - R;\n\t\tfloat vH = dot( r, cross( h, e ) );\n\t\tnu = atan( vH, u * H );\n\t\tself.w = arglong - nu;\n\t}\n\telse\n\t\tself.w = 0.;\n\treturn nu;\n}\n\nvoid kp_get_vectors( Kepler self, float nu, float dnudt90,\n\t\t\t\t\t\t inout vec3 out_r, inout vec3 out_v )\n{\n\tfloat opecn = 1. + self.e * cos(nu);\n\tfloat R = self.p \/ opecn;\n\tfloat u = R * cos( self.w + nu );\n\tfloat v = R * sin( self.w + nu );\n\tfloat sini = sin( self.i );\n\tfloat cosi = cos( self.i );\n\tfloat sinO = sin( self.O );\n\tfloat cosO = cos( self.O );\n\n\tout_r = vec3( u * cosO - v * sinO * cosi,\n\t\t\t\t  u * sinO + v * cosO * cosi,\n\t\t\t\t  v * sini );\n\n\tfloat dRdnu = self.p * self.e * sin(nu) \/* \/ ( opecn * opecn ) *\/;\n\tfloat dudnu = dRdnu * cos( self.w + nu ) - self.p * opecn * sin( self.w + nu ) \/* \/ ( opecn * opecn ) *\/;\n\tfloat dvdnu = dRdnu * sin( self.w + nu ) + self.p * opecn * cos( self.w + nu ) \/* \/ ( opecn * opecn ) *\/;\n\tfloat dnudt = dnudt90 \/* * opecn * opecn *\/;\n\n\tout_v = dnudt * vec3( dudnu * cosO - dvdnu * sinO * cosi,\n\t\t\t\t\t\t  dudnu * sinO + dvdnu * cosO * cosi,\n\t\t\t\t\t\t  dvdnu * sini );\n}\n\nfloat kp_M2E( float M, float e )\n{\n\tif( e < 1. )\n\t{\n\t\tM = mod( M, TAU );\n\t\tfloat E_min = 0.;\n\t\tfloat E_max = TAU;\n\t\tfor( int i = 0, n = 24; i < n; ++i )\n\t\t{\n\t\t\tfloat E = ( E_min + E_max ) \/ 2.;\n\t\t\tfloat M_test = E - e * sin(E);\n\t\t\tif( M_test < M )\n\t\t\t\tE_min = E;\n\t\t\telse\n\t\t\t\tE_max = E;\n\t\t}\n\t\treturn ( E_min + E_max ) \/ 2.;\n\t}\n\telse\n\t{\n\t\tfloat E_min = -44.;\n\t\tfloat E_max = 44.;\n\t\tfor( int i = 0, n = 30; i < n; ++i )\n\t\t{\n\t\t\tfloat E = ( E_min + E_max ) \/ 2.;\n\t\t\tfloat M_test = e * sinh( E ) - E;\n\t\t\tif( M_test < M )\n\t\t\t\tE_min = E;\n\t\t\telse\n\t\t\t\tE_max = E;\n\t\t}\n\t\treturn ( E_min + E_max ) \/ 2.;\n\t}\n}\n\nfloat kp_E2nu( float E, float e )\n{\n\treturn e < 1. ?\n\t\t2. * atan( sqrt( 1. + e ) * sin( E \/ 2. ), sqrt( 1. - e ) * cos( E \/ 2. ) ) :\n\t\t2. * atan( sqrt( e + 1. ) * sinh( E \/ 2. ), sqrt( e - 1. ) * cosh( E \/ 2. ) );\n}\n\nvec4 kp_nu2E_d( vec4 nu, float e )\n{\n\treturn e < 1. ?\n\t\t2. * atan2_d( sqrt( 1. - e ) * sin_d( nu \/ 2. ), sqrt( 1. + e ) * cos_d( nu \/ 2. ) ) :\n\t\t2. * atanh_d( sqrt( ( e - 1. ) \/ ( e + 1. ) ) * tan_d( nu \/ 2. ) );\n}\n\nvec4 kp_E2M_d( vec4 E, float e )\n\t{ return e < 1. ? E - e * sin_d(E) : e * sinh_d(E) - E; }\n\nfloat kp_nu2E( float nu, float e )\n\t{ return kp_nu2E_d( const_d( nu ), e ).w; }\n\nfloat kp_E2M( float E, float e )\n\t{ return kp_E2M_d( const_d(E), e ).w; }\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE PROFILE\n\/\/ ----------------------------------------------------------------------------\n\nstruct AtmProfile\n{\n\tvec4 ref;\t\t\t\t\/\/ properties at reference altitude (temperature, pressure, density, scale height)\n\tvec3 exo;\t\t\t\t\/\/ exospheric temperature profile (exobase, T_infinity, scale height)\n\tfloat ssref;\t\t\t\/\/ speed of sound at reference altitude\n\tmat4x2 pointsA;\t\t\t\/\/ temperature profile points 1..4\n\tmat4x2 pointsB;\t\t\t\/\/ temperature profile points 5..8\n\tvec3 lvar;\t\t\t\t\/\/ params for latitudinal variation\n\tmat2x3 svar;\t\t\t\/\/ params for seasonal variation\n\tvec2 dvar;\t\t\t\t\/\/ params for diurnal variation\n\tfloat mfpref;\t\t\t\/\/ molecular mean free path at reference altitude (for Knudsen number)\n};\n\nconst int ATM_PROFILE_SIZE = 9;\n\nAtmProfile ap_load( sampler2D ch, ivec2 addr )\n{\n\treturn AtmProfile(\n\t\tmemload( ch, addr, 0 ),\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 1 ).w,\n\t\tmat4x2( memload( ch, addr, 2 ), memload( ch, addr, 3 ) ),\n\t\tmat4x2( memload( ch, addr, 4 ), memload( ch, addr, 5 ) ),\n\t\tmemload( ch, addr, 6 ).xyz,\n\t\tmat2x3( memload( ch, addr, 7 ).xyz, memload( ch, addr, 8 ).xyz ),\n\t\tmemload_www( ch, addr, 6 ).xy,\n\t\tmemload_www( ch, addr, 6 ).z );\n}\n\nvoid ap_store( AtmProfile self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.ref, addr, 0, sc, fc );\n\tmemstore( self.exo, self.ssref, addr, 1, sc, fc );\n\tmemstore( self.pointsA[0], self.pointsA[1], addr, 2, sc, fc );\n\tmemstore( self.pointsA[2], self.pointsA[3], addr, 3, sc, fc );\n\tmemstore( self.pointsB[0], self.pointsB[1], addr, 4, sc, fc );\n\tmemstore( self.pointsB[2], self.pointsB[3], addr, 5, sc, fc );\n\tmemstore( self.lvar, self.dvar.x, addr, 6, sc, fc );\n\tmemstore( self.svar[0], self.dvar.y, addr, 7, sc, fc );\n\tmemstore( self.svar[1], self.mfpref, addr, 8, sc, fc );\n}\n\nvec4 ap_eval( AtmProfile self, float r, float r0, vec2 lphase, vec2 sphase, vec2 dphase )\n{\n\t\/\/ get latitudinal, seasonal and diurnal variations\n\tvec3 lvar = self.lvar + self.svar * sphase;\n\tfloat dT_l = dot( lvar.xy, lphase ) + lvar.z;\n\tfloat dT_d = dot( normalize( lvar.xy ), lphase ) * dot( self.dvar.xy, dphase );\n\n\t\/\/ initial values\n\tfloat T0 = self.ref.x;\n\tfloat h = 0.;\n\tfloat z = 0.;\n\tfloat T = T0 + dT_l + dT_d;\n\tfloat profilescale = T \/ T0;\n\n\t\/\/ get the geopotential height H from radius r and reference radius r0\n\tfloat H = r >= r0 ?\n\t\t( r - r0 ) * r0 \/ r :\n\t\t( r - r0 ) * ( r + r0 ) \/ ( 2. * r0 );\n\n\t\/\/ climb the piecewise linear temperature profile until H\n\t\/\/ (allow for negative H in the first iteration)\n\tfor( int i = 0; i < 8 && H != h; ++i )\n\t{\n\t\tvec2 point = i < 4 ? self.pointsA[i] : self.pointsB[i-4];\n\t\tfloat h1 = point.x * profilescale;\n\t\tfloat T1 = point.y * profilescale;\n\t\tif( T1 == 0. || h1 == h )\n\t\t\tbreak;\n\t\tfloat hnext = min( H, h1 );\n\t\tif( T1 != T )\n\t\t{\n\t\t\tfloat lapse = ( T1 - T ) \/ ( h1 - h );\n\t\t\tfloat deltaT = lapse * ( hnext - h );\n\t\t\tz += log1p( deltaT \/ T ) * T0 \/ lapse;\n\t\t\tT = h1 != hnext ? T + deltaT : T1;\n\t\t}\n\t\telse\n\t\t\tz += ( hnext - h ) * T0 \/ T;\n\t\th = hnext;\n\t}\n\n\t\/\/ assume constant temperature above profile\n\tfloat exobase = self.exo.x;\n\tz += max( 0., min( exobase > 0. ? exobase : H, H ) - h ) * T0 \/ T;\n\n\t\/\/ apply Bates-Walker formula for exospheric altitudes\n\tfloat exotemp = self.exo.y;\n\tfloat exoscale = self.exo.z;\n\tif( exotemp > 0. && exoscale > 0. )\n\t{\n\t\tfloat a = max( 0., H - exobase ) \/ exoscale;\n\t\tfloat b = exoscale * T0 \/ exotemp;\n\t\tif( a < 17. )\n\t\t\tz += log1p( expm1( a ) * exotemp \/ T ) * b;\n\t\telse\n\t\t\tz += ( a + log( exotemp \/ T ) ) * b;\n\t\tT = mix( T, exotemp, -expm1( -a ) );\n\t}\n\n\t\/\/ final result\n\tfloat P = self.ref.y * exp( -z \/ self.ref.w );\n\tfloat rho = self.ref.z * self.ref.x * P \/ ( self.ref.y * T );\n\treturn vec4( T, P, rho, H );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE MODEL\n\/\/ ----------------------------------------------------------------------------\n\nstruct AtmModel\n{\n\tfloat scale;\t\t\t\/\/ effective optical scale height\n\tfloat g;\t\t\t\t\/\/ effective overall asymmetry parameter\n\tvec4  tau;\t\t\t\t\/\/ total optical depth\n\tvec4  tau_s;\t\t\t\/\/ total optical depth (scattering only)\n\tvec4  glayer_tau;\t\t\/\/ ground layer: optical depth,\n\tvec4  glayer_tau_s;\t\t\/\/ ground layer: optical depth (scattering only)\n\tfloat glayer_scale;\t\t\/\/ ground layer: scale height multiplier\n\tvec4  alayer_tau;\t\t\/\/ absorbtion layer: optical depth\n\tvec2  alayer_shape;\t\t\/\/ absorbtion layer: mu, sigma of altitude profile\n\tvec4  elayer_emiss;\t\t\/\/ emission layer: column emission\n\tvec2  elayer_shape;\t\t\/\/ emission layer: mu, sigma of altitude profile\n};\n\nconst int ATM_MODEL_SIZE = 8;\n\nAtmModel am_load( sampler2D ch, ivec2 addr )\n{\n\treturn AtmModel(\n\t\tmemload( ch, addr, 0 ).x,\n\t\tmemload( ch, addr, 0 ).y,\n\t\tmemload( ch, addr, 1 ),\n\t\tmemload( ch, addr, 2 ),\n\t\tmemload( ch, addr, 3 ),\n\t\tmemload( ch, addr, 4 ),\n\t\tmemload( ch, addr, 0 ).z,\n\t\tmemload( ch, addr, 5 ),\n\t\tmemload( ch, addr, 7 ).xy,\n\t\tmemload( ch, addr, 6 ),\n\t\tmemload( ch, addr, 7 ).zw );\n}\n\nvoid am_store( AtmModel self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( vec3( self.scale, self.g, self.glayer_scale ), 0., addr, 0, sc, fc );\n\tmemstore( self.tau, addr, 1, sc, fc );\n\tmemstore( self.tau_s, addr, 2, sc, fc );\n\tmemstore( self.glayer_tau, addr, 3, sc, fc );\n\tmemstore( self.glayer_tau_s, addr, 4, sc, fc );\n\tmemstore( self.alayer_tau, addr, 5, sc, fc );\n\tmemstore( self.elayer_emiss, addr, 6, sc, fc );\n\tmemstore( self.alayer_shape, self.elayer_shape, addr, 7, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ PLANET DATA\n\/\/ ----------------------------------------------------------------------------\n\nstruct TrnLayer\n{\n\tvec4 color;\n\tvec4 detail;\n\tvec4 weights;\n\tfloat offset;\n\tfloat lower;\n\tfloat upper;\n};\n\nconst int TRN_LAYER_SIZE = 4;\n\nTrnLayer tl_load( sampler2D ch, ivec2 addr )\n{\n\treturn TrnLayer(\n\t\tmemload( ch, addr, 0 ),\n\t\tmemload( ch, addr, 1 ),\n\t\tmemload( ch, addr, 2 ),\n\t\tmemload( ch, addr, 3 ).x,\n\t\tmemload( ch, addr, 3 ).y,\n\t\tmemload( ch, addr, 3 ).z );\n}\n\nvoid tl_store( TrnLayer self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.color, addr, 0, sc, fc );\n\tmemstore( self.detail, addr, 1, sc, fc );\n\tmemstore( self.weights, addr, 2, sc, fc );\n\tmemstore( vec3( self.offset, self.lower, self.upper ), 0., addr, 3, sc, fc );\n}\n\nstruct TrnData\n{\n\tvec3 seeds;\t\t\t\/\/ seed offsets x, y, z\n\tvec3 levels;\t\t\/\/ min level, max level, ocean level\n\tvec3 offcenter;\t\t\/\/ optional center displacement\n\tvec3 noise;\t\t\t\/\/ noise amplitude, log-normal-distribution: mu, sigma\n\tvec3 flatten;\t\t\/\/ flatten modifier: base level, range, reduction amount\n\tvec3 slope;\t\t\t\/\/ slope modifiers: slope scale, divergence, slip\n};\n\nconst int TRN_DATA_SIZE = 5;\n\nTrnData td_load( sampler2D ch, ivec2 addr )\n{\n\treturn TrnData(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 2 ).xyz,\n\t\tmemload_www( ch, addr, 0 ),\n\t\tmemload( ch, addr, 3 ).xyz,\n\t\tmemload( ch, addr, 4 ).xyz );\n}\n\nvoid td_store( TrnData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.seeds, self.noise.x, addr, 0, sc, fc );\n\tmemstore( self.levels, self.noise.y, addr, 1, sc, fc );\n\tmemstore( self.offcenter, self.noise.z, addr, 2, sc, fc );\n\tmemstore( self.flatten, 0., addr, 3, sc, fc );\n\tmemstore( self.slope, 0., addr, 4, sc, fc );\n}\n\nstruct OcnData\n{\n\tvec4 beta50;\t\t\/\/ ocean absorbtion coefficients (exp2 based)\n\tvec4 omega;\t\t\t\/\/ ocean optical albedo\n\tvec3 Tds2;\t\t\t\/\/ ocean temperature \/ density \/ optical roughness (slope variance)\n};\n\nconst int OCN_DATA_SIZE = 3;\n\nOcnData od_load( sampler2D ch, ivec2 addr )\n{\n\treturn OcnData(\n\t\tmemload( ch, addr, 0 ),\n\t\tmemload( ch, addr, 1 ),\n\t\tmemload( ch, addr, 2 ).xyz );\n}\n\nvoid od_store( OcnData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.beta50, addr, 0, sc, fc );\n\tmemstore( self.omega, addr, 1, sc, fc );\n\tmemstore( self.Tds2, 0., addr, 2, sc, fc );\n}\n\nstruct CldData\n{\n\tvec3 akg;\t\t\t\t\/\/ alt \/ k50max \/ g\n\tvec3 fluff;\t\t\t\t\/\/ bottom strength \/ top strength \/ fade range\n\tvec2 size;\t\t\t\t\/\/ noise size \/ fluff size\n\tvec4 noise;\t\t\t\t\/\/ influence of const \/ sin3lat2 \/ noise \/ vertical\n\tvec4 move;\t\t\t\t\/\/ phase offset \/ move speed \/ fluff move \/ fluff rotate\n};\n\nconst int CLD_DATA_SIZE = 4;\n\nCldData cd_load( sampler2D ch, ivec2 addr )\n{\n\treturn CldData(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload_www( ch, addr, 0 ).xy,\n\t\tmemload( ch, addr, 2 ),\n\t\tmemload( ch, addr, 3 ) );\n}\n\nvoid cd_store( CldData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.akg, self.size.x, addr, 0, sc, fc );\n\tmemstore( self.fluff, self.size.y, addr, 1, sc, fc );\n\tmemstore( self.noise, addr, 2, sc, fc );\n\tmemstore( self.move, addr, 3, sc, fc );\n}\n\nstruct PlanetData\n{\n\tfloat parent;\t\t\t\/\/ parent index\n\tfloat radius;\t\t\t\/\/ planet radius (datum)\n\tfloat GM;\t\t\t\t\/\/ standard gravitational parameter\n\tfloat orb_period;\t\t\/\/ orbital period (hours)\n\tfloat rot_period;\t\t\/\/ rotation period (hours)\n\tvec2 rot_northpole;\t\t\/\/ lat\/long of north pole in ecliptic coordinates\n\tKepler orbit;\t\t\t\/\/ orbital elements\n\tTrnData trn;\n\tTrnLayer lyr0;\n\tTrnLayer lyr1;\n\tTrnLayer lyr2;\n\tTrnLayer lyr3;\n\tTrnLayer lyr4;\n\tTrnLayer lyr5;\n\tOcnData ocn;\n\tAtmProfile ap;\n\tAtmModel am;\n\tCldData cld;\n};\n\nconst int PLANET_DATA_SIZE = 3 + TRN_DATA_SIZE + 6 * TRN_LAYER_SIZE + OCN_DATA_SIZE + ATM_PROFILE_SIZE + ATM_MODEL_SIZE + CLD_DATA_SIZE;\nconst int PLANET_DATA_COUNT = 3;\n\nivec2 pd_addr( int index )\n\t{ return ADDR_PLANET_DATA + ivec2( index, 0 ); }\n\nint pd_layer_addr( int index )\n\t{ return 3 + TRN_DATA_SIZE + TRN_LAYER_SIZE * index; }\n\nbool in_pd_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_PLANET_DATA, PLANET_DATA_SIZE, PLANET_DATA_COUNT ); }\n\nPlanetData pd_load( sampler2D ch, ivec2 addr )\n{\n\treturn PlanetData(\n\t\tmemload( ch, addr, 0 ).x, memload( ch, addr, 0 ).y,\n\t\tmemload( ch, addr, 0 ).z, memload( ch, addr, 0 ).w,\n\t\tmemload( ch, addr, 1 ).x, memload( ch, addr, 1 ).yz,\n\t\tKepler( memload( ch, addr, 1 ).w, memload( ch, addr, 2 ).x,\n\t\t\t\tmemload( ch, addr, 2 ).y, memload( ch, addr, 2 ).z,\n\t\t\t\tmemload( ch, addr, 2 ).w ),\n\t\ttd_load( ch, addr + ivec2( 0, 3 ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(0) ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(1) ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(2) ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(3) ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(4) ) ),\n\t\ttl_load( ch, addr + ivec2( 0, pd_layer_addr(5) ) ),\n\t\tod_load( ch, addr + ivec2( 0, pd_layer_addr(6) ) ),\n\t\tap_load( ch, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE ) ),\n\t\tam_load( ch, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE + ATM_PROFILE_SIZE ) ),\n\t\tcd_load( ch, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE + ATM_PROFILE_SIZE + ATM_MODEL_SIZE ) )\n\t);\n}\n\nvoid pd_store( PlanetData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( vec4( self.parent, self.radius, self.GM, self.orb_period ), addr, 0, sc, fc );\n\tmemstore( vec4( self.rot_period, self.rot_northpole, self.orbit.p ), addr, 1, sc, fc );\n\tmemstore( vec4( self.orbit.e, self.orbit.i, self.orbit.O, self.orbit.w ), addr, 2, sc, fc );\n\ttd_store( self.trn, addr + ivec2( 0, 3 ), sc, fc );\n\ttl_store( self.lyr0, addr + ivec2( 0, pd_layer_addr(0) ), sc, fc );\n\ttl_store( self.lyr1, addr + ivec2( 0, pd_layer_addr(1) ), sc, fc );\n\ttl_store( self.lyr2, addr + ivec2( 0, pd_layer_addr(2) ), sc, fc );\n\ttl_store( self.lyr3, addr + ivec2( 0, pd_layer_addr(3) ), sc, fc );\n\ttl_store( self.lyr4, addr + ivec2( 0, pd_layer_addr(4) ), sc, fc );\n\ttl_store( self.lyr5, addr + ivec2( 0, pd_layer_addr(5) ), sc, fc );\n\tod_store( self.ocn, addr + ivec2( 0, pd_layer_addr(6) ), sc, fc );\n\tap_store( self.ap, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE ), sc, fc );\n\tam_store( self.am, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE + ATM_PROFILE_SIZE ), sc, fc );\n\tcd_store( self.cld, addr + ivec2( 0, pd_layer_addr(6) + OCN_DATA_SIZE + ATM_PROFILE_SIZE + ATM_MODEL_SIZE ), sc, fc );\n}\n\nfloat pd_overarch( PlanetData planet )\n{\n\t\/\/ normalized distance to horizon observable from one scale-height altitude;\n\t\/\/ used as a measure of terminator 'over-arch'\n\treturn safediv(\n\t\tsqrt( planet.am.scale * ( 2. * planet.radius + planet.am.scale ) ),\n\t\tplanet.radius + planet.am.scale );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE UTILS\n\/\/ ----------------------------------------------------------------------------\n\nfloat atm_chapman50_h( float X, float h, float coschi )\n{\n\t\/\/ Approximation to the Chapman function (airmass integral)\n\t\/\/ cf. Sch\u00fcler, C. (2012) in GPU Pro 3\n\t\/\/ returns the equivalent of Ch(X+h,coschi) times exp2(-h)\n\n\tfloat x = X + h;\n\tfloat c = SQRTPILN2HALF * sqrt(x);\n\tif( coschi >= 0. )\n\t\treturn c \/ ( ( c - 1. ) * coschi + 1. ) * exp2pp( -h );\n\telse\n\t{\n\t\tfloat sinchi = sqrt( max( 0., 1. - coschi * coschi ) );\n\t\treturn c \/ ( ( c - 1. ) * coschi - 1. ) * exp2pp( -h ) +\n\t\t\t   2. * c * exp2pp( X - x * sinchi ) * sqrt( sinchi );\n\t}\n}\n\n\n#if WITH_ATM_AMTL_CORRECTION\nfloat atm_airmass_correction( float x, float coschi, float a )\n{\n\tcoschi = abs( coschi );\n\tfloat c = SQRTPILN2HALF * sqrt(x);\n\treturn a * ( ( c - 1. ) * coschi + a ) \/ ( ( a * c - 1. ) * coschi + a );\n}\n#endif\n\nfloat atm_planet_shadow( float coschi, float cosbeta, float sinalpha )\n{\n\treturn clamp( ( coschi + cosbeta ) \/ sinalpha + .5, 0., 1. );\n}\n\nfloat atm_delta_eddington_Fminus_direct( float g, float tau50, float mu )\n{\n\t\/\/ Simplified Eddington downwelling flux component\n\t\/\/ for direct light input at the top interface,\n\t\/\/ assuming conservative scattering (omega0 = 1),\n\t\/\/ and no bottom reflection.\n\tfloat f = g * g;\n\tg = g \/ ( g + 1. );\n\ttau50 = ( 1. - f ) * tau50;\n\treturn ( 2. + 3. * mu + ( 2. - 3. * mu ) * exp2pp( -tau50 ) ) \/ ( 4. + 3. * LN2 * tau50 * mu * ( 1. - g ) );\n}\n\nfloat atm_delta_eddington_Fminus_diffuse( float g, float tau50 )\n{\n\t\/\/ Simplified Eddington downwelling flux component\n\t\/\/ for diffuse light input at the top interface,\n\t\/\/ assuming conservative scattering (omega0 = 1),\n\t\/\/ and no bottom reflection.\n\tfloat f = g * g;\n\tg = g \/ ( g + 1. );\n\ttau50 = ( 1. - f ) * tau50;\n\treturn 4. \/ ( 4. + 3. * LN2 * tau50 * ( 1. - g ) );\n}\n\nfloat atm_dulimit( float invtau, float H50, float k50 )\n{\n\t\/\/ maximum allowed advance to stay within 1\/invtau mean free paths\n\t\/\/ used as step size control\n\tfloat s = invtau * k50;\n\treturn\n\t\tH50 * s < .25 ? -H50 * log2( H50 * s ) :\n\t\tH50 * s >= 4. ? 1. \/ s :\n\t\tH50 * log2( 1. + 1. \/ ( H50 * s ) );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE CONTEXT\n\/\/ ----------------------------------------------------------------------------\n\nstruct AtmContext\n{\n\tfloat r0;\n\tfloat g;\n\tfloat H;\n\tfloat invH50;\n\tvec3 omega0;\n\tfloat X50;\n\tvec3 mu_stretch;\n\tfloat htop;\n\tvec3 tau50;\n\tvec3 tau50s;\n\tvec3 k50;\n\tvec3 k50_s;\n\tfloat k50max;\n  #if WITH_ATM_LAYER_G\n\tvec3 glayer_k50;\n\tvec3 glayer_k50_s;\n\tfloat glayer_scale;\n  #endif\n  #if WITH_ATM_LAYER_A\n\tvec3 alayer_k50;\n\tvec3 alayer_shape;\n  #endif\n  #if WITH_ATM_LAYER_E\n\tvec3 elayer_emiss;\n\tvec3 elayer_shape;\n  #endif\n  #if WITH_CLOUDS\n\tvec3 ht0s50;\n  #endif\n};\n\nconst int ATM_CONTEXT_SIZE = 14;\n\nivec2 ac_addr( int index )\n\t{ return ADDR_ATM_CONTEXTS + ivec2( index, 0 ); }\n\nAtmContext ac_load( sampler2D ch, ivec2 addr )\n{\n\treturn AtmContext(\n\t\tmemload( ch, addr, 0 ).x,\n\t\tmemload( ch, addr, 0 ).y,\n\t\tmemload( ch, addr, 0 ).z,\n\t\tmemload( ch, addr, 0 ).w,\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 1 ).w,\n\t\tmemload( ch, addr, 2 ).xyz,\n\t\tmemload( ch, addr, 2 ).w,\n\t\tmemload( ch, addr, 3 ).xyz,\n\t\tmemload( ch, addr, 4 ).xyz,\n\t\tmemload( ch, addr, 5 ).xyz,\n\t\tmemload( ch, addr, 6 ).xyz,\n\t\tmemload( ch, addr, 6 ).w\n\t  #if WITH_ATM_LAYER_G\n\t\t,memload( ch, addr, 7 ).xyz\n\t\t,memload( ch, addr, 8 ).xyz\n\t\t,memload( ch, addr, 8 ).w\n\t  #endif\n\t  #if WITH_ATM_LAYER_A\n\t\t,memload( ch, addr, 9 ).xyz\n\t\t,memload( ch, addr, 10 ).xyz\n\t  #endif\n\t  #if WITH_ATM_LAYER_E\n\t\t,memload( ch, addr, 11 ).xyz\n\t\t,memload( ch, addr, 12 ).xyz\n\t  #endif\n\t  #if WITH_CLOUDS\n\t\t,memload( ch, addr, 13 ).xyz\n\t  #endif\n\t);\n}\n\nvoid ac_store( AtmContext self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( vec4( self.r0, self.g, self.H, self.invH50 ), addr, 0, sc, fc );\n\tmemstore( self.omega0, self.X50, addr, 1, sc, fc );\n\tmemstore( self.mu_stretch, self.htop, addr, 2, sc, fc );\n\tmemstore( self.tau50, 0., addr, 3, sc, fc );\n\tmemstore( self.tau50s, 0., addr, 4, sc, fc );\n\tmemstore( self.k50, 0., addr, 5, sc, fc );\n\tmemstore( self.k50_s, self.k50max, addr, 6, sc, fc );\n  #if WITH_ATM_LAYER_G\n\tmemstore( self.glayer_k50, 0., addr, 7, sc, fc );\n\tmemstore( self.glayer_k50_s, self.glayer_scale, addr, 8, sc, fc );\n  #endif\n  #if WITH_ATM_LAYER_A\n\tmemstore( self.alayer_k50, 0., addr, 9, sc, fc );\n\tmemstore( self.alayer_shape, 0., addr, 10, sc, fc );\n  #endif\n  #if WITH_ATM_LAYER_E\n\tmemstore( self.elayer_emiss, 0., addr, 11, sc, fc );\n\tmemstore( self.elayer_shape, 0., addr, 12, sc, fc );\n  #endif\n  #if WITH_CLOUDS\n\tmemstore( self.ht0s50, 0., addr, 13, sc, fc );\n  #endif\n}\n\nvec3 ac_eddington_diffusion_stretch_factor( vec3 omega0, float g, float k )\n{\n\t\/\/ stretch factor related to the backscatter coefficient or\n\t\/\/ the average diffusion length\n\treturn sqrt( 3. * ( 1. - omega0 * k ) * ( 1. - omega0 * g ) );\n}\n\nvec3 ac_cvt_layer_shape( vec2 shape, float invscale )\n{\n\tvec3 result;\n\tresult.x = shape.x * invscale;\n\tresult.y = safediv( ONEOVERSQRTTWOPI * LOG2E, shape.y * invscale );\n\tresult.z = safediv( .5 * LOG2E, square( shape.y * invscale ) );\n\treturn result;\n}\n\nvec3 irselect( vec4 a, bool b )\n\t{ return b ? a.www : a.xyz; }\n\nAtmContext ac_init( PlanetData data, bool ir )\n{\n\tAtmContext result;\n\tresult.r0 = data.radius;\n\tresult.g = data.am.g;\n\tresult.H = data.am.scale;\n\tresult.invH50 = safediv( LOG2E, data.am.scale );\n\tresult.omega0 = irselect( safediv( data.am.tau_s, data.am.tau ), ir );\n\tresult.X50 = data.radius * result.invH50;\n\tvec3 stretchhalf = ac_eddington_diffusion_stretch_factor( result.omega0, result.g, .5 );\n\tvec3 stretchfull = ac_eddington_diffusion_stretch_factor( result.omega0, result.g, 1. );\n\tresult.mu_stretch = result.X50 * stretchhalf * pd_overarch( data );\n\tresult.htop = ( hmax( result.tau50 ) + 15. ) * data.am.scale;\n\tresult.tau50 = irselect( data.am.tau, ir ) * LOG2E;\n\tresult.tau50s = result.tau50 * stretchfull;\n\tresult.k50 = irselect( data.am.tau, ir ) * result.invH50;\n\tresult.k50_s = irselect( data.am.tau_s, ir ) * result.invH50;\n\tresult.k50max = hmax( result.k50 );\n  #if WITH_ATM_LAYER_G\n\tresult.glayer_k50 = irselect( data.am.glayer_tau, ir ) * result.invH50;\n\tresult.glayer_k50_s = irselect( data.am.glayer_tau_s, ir ) * result.invH50;\n\tresult.glayer_scale = data.am.glayer_scale;\n  #endif\n  #if WITH_ATM_LAYER_A\n\tresult.alayer_k50 = irselect( data.am.alayer_tau, ir ) * result.invH50;\n\tresult.alayer_shape = ac_cvt_layer_shape( data.am.alayer_shape, result.invH50 );\n  #endif\n  #if WITH_ATM_LAYER_E\n\tresult.elayer_emiss = irselect( data.am.elayer_emiss, ir );\n\tresult.elayer_shape = ac_cvt_layer_shape( data.am.elayer_shape, result.invH50 );\n  #endif\n  #if WITH_CLOUDS\n\tresult.ht0s50 = SQRTPILN2HALF * sqrt( result.X50 ) * irselect( data.am.tau, ir );\n  #endif\n\treturn result;\n}\n\n#if WITH_ATM_LAYER_A\nfloat ac_tau_layer_a( AtmContext ac, vec3 x, vec3 dir )\n{\n\tfloat result = 0.;\n\tfloat mu = ac.alayer_shape.x + ac.X50;\n\tfloat hw = safediv( ONEOVERSQRTTWOPI, ac.alayer_shape.y );\n\tvec2 imp = sphere_impact( x, dir );\n\tif( imp.x < square( mu + hw ) ) \/\/ also catches dir == 0 via imp.x == NaN\n\t{\n\t\tvec2 limits = max( vec2(0), sphere_limits( mu + hw, imp ) );\n\t\tresult += .5 * ( limits.y - limits.x ) \/ hw;\n\t\tif( imp.x < square( mu - hw ) )\n\t\t{\n\t\t\tvec2 limits = max( vec2(0), sphere_limits( mu - hw, imp ) );\n\t\t\tresult -= .5 * ( limits.y - limits.x ) \/ hw;\n\t\t}\n\t}\n\treturn result;\n}\n#endif\n\nvec3 ac_tau50_params( AtmContext ac, vec3 x, vec3 dir )\n{\n\tfloat xsq = dot( x, x );\n\tfloat invxr = inversesqrt( xsq );\n\tfloat x50 = xsq * invxr;\n\tfloat h50 = x50 - ac.X50;\n\tfloat coschi = invxr * dot( x, dir );\n\treturn vec3( sqrt( max( 0., 1. - square( ac.X50 \/ x50 ) ) ), h50, coschi );\n}\n\nvec3 ac_tau50( AtmContext ac, vec3 x, vec3 dir, float h50, float coschi )\n{\n\t\/\/ Analytical approximation to the optical depth along a path\n\t\/\/ inside an exponentially decreasing, spherically symmetric\n\t\/\/ atmosphere as seen from point x into direction dir\n\tvec3 result = ZERO;\n#if WITH_ATMOSPHERE\n\tfloat airmass = atm_chapman50_h( ac.X50, h50, coschi );\n\tresult += ac.tau50 * airmass;\n  #if WITH_ATM_LAYER_G\n\tfloat airmass_g = atm_chapman50_h( ac.X50 * ac.glayer_scale, h50 * ac.glayer_scale, coschi );\n\tresult += ac.H * ac.glayer_k50 * ( airmass_g - airmass );\n  #endif\n  #if WITH_ATM_LAYER_A\n\tfloat airmass_a = ac_tau_layer_a( ac, x, dir );\n\tresult += ac.H * ac.alayer_k50 * ( airmass_a - airmass );\n  #endif\n#endif\n\treturn result;\n}\n\nvec3 ac_transmittance( AtmContext ac, vec3 pos, vec3 dir, bool amtl )\n{\n\tvec3 x = pos * ac.invH50;\n\tvec3 params = ac_tau50_params( ac, x, dir );\n\tvec3 tau50 = ac_tau50( ac, x, dir, params.y, params.z );\n#if WITH_ATM_AMTL_CORRECTION\n\tif( amtl )\n\t\ttau50 *= atm_airmass_correction( ac.X50, params.x + params.z, ATM_AMTL_CORRECTION );\n#endif\n\treturn exp2pp( -tau50 );\n}\n\nvec3 ac_transmittance_finite( AtmContext ac, vec3 pos0, vec3 pos1 )\n{\n\tvec3 dir = safenormalize( pos1 - pos0 );\n\tvec3 x0 = pos0 * ac.invH50;\n\tvec3 x1 = pos1 * ac.invH50;\n\tvec3 params0 = ac_tau50_params( ac, x0, dir );\n\tvec3 params1 = ac_tau50_params( ac, x1, dir );\n\tvec3 tau50 = dot( x0, dir ) < 0. ?\n\t\tac_tau50( ac, x1, -dir, params1.y, -params1.z ) - ac_tau50( ac, x0, -dir, params0.y, -params0.z ) :\n\t\tac_tau50( ac, x0,  dir, params0.y,\tparams0.z ) - ac_tau50( ac, x1,\t dir, params1.y,  params1.z );\n\treturn exp2( -tau50 );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ PLANET STATE\n\/\/ ----------------------------------------------------------------------------\n\nstruct PlanetState\n{\n\t\/\/ global coordinates\n\tvec3 r;\t\t\t\t\/\/ position\n\tvec3 v;\t\t\t\t\/\/ velocity\n\tfloat omega;\t\t\/\/ angular velocity\n\tmat3 B;\t\t\t\t\/\/ body frame\n\n\t\/\/ local coordinates\n\tvec3 orbitr;\n\tvec3 orbitv;\n\n\t\/\/ orbital parameters\n\tfloat M;\t\t\t\/\/ mean anomaly\n\tfloat E;\t\t\t\/\/ eccentric anomaly\n\tfloat nu;\t\t\t\/\/ true anomaly\n\tfloat dnudt90;\t\t\/\/ motion of true anomaly at latus rectum\n};\n\nconst int PLANET_STATE_SIZE = 7;\n\nivec2 ps_addr( int index )\n\t{ return ADDR_PLANET_STATES + ivec2( index, 0 ); }\n\nbool in_ps_atm_ts_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_PLANET_STATES, 48, PLANET_DATA_COUNT ); }\n\nPlanetState ps_load( sampler2D ch, ivec2 addr )\n{\n\treturn PlanetState(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 2 ).x,\n\t\tmemload_mat3( ch, addr, 3 ),\n\t\tmemload_www( ch, addr, 0 ),\n\t\tmemload_www( ch, addr, 3 ),\n\t\tmemload( ch, addr, 6 ).x, memload( ch, addr, 6 ).y,\n\t\tmemload( ch, addr, 6 ).z, memload( ch, addr, 6 ).w );\n}\n\nvoid ps_store( PlanetState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.r, self.orbitr.x, addr, 0, sc, fc );\n\tmemstore( self.v, self.orbitr.y, addr, 1, sc, fc );\n\tmemstore( vec3( self.omega, 0, 0 ), self.orbitr.z, addr, 2, sc, fc );\n\tmemstore( self.B, self.orbitv, addr, 3, sc, fc );\n\tmemstore( vec4( self.M, self.E, self.nu, self.dnudt90 ), addr, 6, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE DATA\n\/\/ ----------------------------------------------------------------------------\n\nstruct VehicleData\n{\n\tvec4 Sbcm;\t\t\t\t\t\/\/ area (S), span (b), chord (c) and mass (m)\n\tvec4 I;\t\t\t\t\t\t\/\/ moments of inertia (Ixx, Iyy, Izz, Ixz)\n\n\t\/\/ stability coefficients\n\tvec4 CD;\t\t\t\t\t\/\/ CD0, CDa2, CDb2, CDi\n\tvec4 CL;\t\t\t\t\t\/\/ CL0, CLa, CLq, CLde\n\tvec4 Cm;\t\t\t\t\t\/\/ Cm0, Cma, Cmq, Cmde\n\tvec4 CY;\t\t\t\t\t\/\/ CYb, CYp, CYr, CYdr\n\tvec4 Cn;\t\t\t\t\t\/\/ Cnb, Cnp, Cnr, Cndr\n\tvec4 Cl;\t\t\t\t\t\/\/ Clb, Clp, Clr, Clda\n\tvec2 Cadot;\t\t\t\t\t\/\/ CLadot, Cmadot\n\tvec4 C90;\t\t\t\t\t\/\/ Cm90, Cmq90, Cnb90, Clb90\n\tvec2 Cside;\t\t\t\t\t\/\/ Cnside, Cnrside\n\n\t\/\/ extra stuff\n\tvec3 misc;\t\t\t\t\t\/\/ kD, Clab, Cmi\n\tvec3 mach;\t\t\t\t\t\/\/ MDD, delta-CD at mach 1, delta-CD at mach infinity\n\tvec2 rare;\t\t\t\t\t\/\/ x = ref length, y = CD0\n\tvec4 greff;\t\t\t\t\t\/\/ xy = rel change CL and Cm, z = scale height in units of b, w = wake delay parameter\n\n\t\/\/ configuration changes\n\tmat3 config;\t\t\t\t\/\/ [0] = flaps, [1] = spoilers, [2] = gears; x = delta-CD, y = delta-CL, z = delta-Cm\n\tfloat gearClb;\t\t\t\t\/\/ extra Clb when gears down\n\n\t\/\/ parameters for stall curve\n\tvec4 etaCL;\t\t\t\t\t\/\/ xy = input range, zw = output range\n\n\t\/\/ other\n\tvec3 dx_max;\t\t\t\t\/\/ max control excursion, in radians (de, da, dr)\n\tfloat T_max;\t\t\t\t\/\/ maximum thrust\n\n};\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE STATE\n\/\/ ----------------------------------------------------------------------------\n\nstruct VehicleState\n{\n\t\/\/ global coordinates\n\tvec3 r;\t\t\t\t\/\/ position\n\tvec3 v;\t\t\t\t\/\/ velocity\n\tvec3 omega;\t\t\t\/\/ angular velocity vector\n\tmat3 B;\t\t\t\t\/\/ body frame\n\n\t\/\/ local orbit coordinates, non-rotating frame\n\tvec3 orbitr;\n\tvec3 orbitv;\n\n\t\/\/ local surface coordinates, rotating frame\n\tvec3 localr;\n\tvec3 localv;\n\tvec3 localomega;\n\tmat3 localB;\n\n\t\/\/ high precision accumulator for localr\n\tvec3 localr_base;\n\tvec3 localr_diff;\n\n\t\/\/ time-lagged vertical acceleration for flight dynamics\n\tvec3 acc;\n\tfloat wdelay;\n\n\t\/\/ vehicle configuration state\n\tvec3 FSG;\t\t\t\/\/ flaps\/spoilers\/gears\n\tfloat throttle;\n\tvec3 EAR;\t\t\t\/\/ elevator\/aileron\/rudder\n\tfloat trim;\n\tvec3 EAR_hold;\t\t\/\/ hold timers for EAR\n\tfloat thr_hold;\t\t\/\/ throttle hold timer\n\n\t\/\/ vehicle control state\n\tivec3 modes;\t\t\/\/ hud\/...\/engine\n\tuint switches;\t\t\/\/ bitfield\n\tivec3 modes2;\t\t\/\/ aero\/rcs\/throttle\n\tfloat tvec;\t\t\t\/\/ thrust vector\n\n\t\/\/ other states\n\tvec4 aerostuff;\t\t\/\/ state variables for aero control modes\n\tvec3 rcsstuff;\t\t\/\/ state variables for rcs control modes\n\tfloat canopy;\n\n\t\/\/ read only\n\tvec4 info;\t\t\t\/\/ CL, CD, alpha, contact\n};\n\nconst int VEHICLE_STATE_SIZE = 21;\n\nconst int VS_MAX_ITER = 100;\nconst float VS_MAX_PACE_LOCAL = 0.25;\nconst float VS_MAX_PACE = 1.66666667;\n\nconst uint VS_FLAPS_MASK = 3u;\nconst uint VS_FLAPS_SHIFT = 0u;\nconst uint VS_SPOIL = 4u;\nconst uint VS_GEARS = 8u;\nconst uint VS_LIGHT = 16u;\nconst uint VS_THROTTLE_EDGE = 32u;\nconst uint VS_TVEC_MASK = 960u;\nconst uint VS_TVEC_SHIFT = 6u;\nconst uint VS_CANOPY = 1024u;\nconst uint VS_STEER = 2048u;\n\nconst float VS_FLAPS_MAX = 3.;\nconst float VS_TVEC_MAX = 10.;\n\nfloat vs_flaps_notches( float n )\n\t{ return n * n \/ 9.; }\n\nfloat vs_tvec_notches( float n )\n\t{ return n * ( n * ( n * .5 - 7.5 ) + 43. ); }\n\nconst int VS_ENG_OFF = 0;\nconst int VS_ENG_DRV = 1;\nconst int VS_ENG_IMP = 2;\nconst int VS_ENG_NOVA = 3;\n\nconst int VS_HMD_OFF = 0;\nconst int VS_HMD_SFCE = 1;\nconst int VS_HMD_ORB = 2;\n\nconst int VS_AERO_OFF = 0;\nconst int VS_AERO_MAN = 1;\nconst int VS_AERO_FBW = 2;\n\nconst int VS_RCS_OFF = 0;\nconst int VS_RCS_MAN = 1;\nconst int VS_RCS_RATE = 2;\nconst int VS_RCS_LVLH = 3;\n\nconst int VS_THR_OFF = 0;\nconst int VS_THR_MAN = 1;\n\nbool in_vs_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_VEHICLE_STATE, VEHICLE_STATE_SIZE, 1 ); }\n\nVehicleState vs_init()\n{\n\treturn VehicleState( ZERO, ZERO, ZERO, IDENTITY, ZERO, ZERO,\n\t\t\t\t\t\t ZERO, ZERO, ZERO, IDENTITY, ZERO, ZERO,\n\t\t\t\t\t\t ZERO, 0., ZERO, 0., ZERO, 0.,\n\t\t\t\t\t\t ZERO, 0., ivec3(0), 0u, ivec3(0), 0.,\n\t\t\t\t\t\t vec4(0), ZERO, 0., vec4(0) );\n}\n\nVehicleState vs_load( sampler2D ch, ivec2 addr )\n{\n\treturn VehicleState(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 2 ).xyz,\n\t\tmemload_mat3( ch, addr, 3 ),\n\t\tmemload_www( ch, addr, 0 ),\n\t\tmemload_www( ch, addr, 3 ),\n\t\tmemload( ch, addr, 6 ).xyz,\n\t\tmemload( ch, addr, 7 ).xyz,\n\t\tmemload( ch, addr, 8 ).xyz,\n\t\tmemload_mat3( ch, addr, 9 ),\n\t\tmemload_www( ch, addr, 6 ),\n\t\tmemload_www( ch, addr, 9 ),\n\t\tmemload( ch, addr, 12 ).xyz,\n\t\tmemload( ch, addr, 12 ).w,\n\t\tmemload( ch, addr, 13 ).xyz,\n\t\tmemload( ch, addr, 13 ).w,\n\t\tmemload( ch, addr, 14 ).xyz,\n\t\tmemload( ch, addr, 14 ).w,\n\t\tmemload( ch, addr, 15 ).xyz,\n\t\tmemload( ch, addr, 15 ).w,\n\t\tivec3( memload( ch, addr, 16 ).xyz ),\n\t\tuint( memload( ch, addr, 16 ).w ),\n\t\tivec3( memload( ch, addr, 17 ).xyz ),\n\t\tmemload( ch, addr, 17 ).w,\n\t\tmemload( ch, addr, 18 ),\n\t\tmemload( ch, addr, 19 ).xyz,\n\t\tmemload( ch, addr, 19 ).w,\n\t\tmemload( ch, addr, 20 ) );\n}\n\nVehicleState vs_load_or_init( sampler2D ch, ivec2 addr, bool init )\n\t{ if( init ) return vs_init(); else return vs_load( ch, addr ); }\n\nvoid vs_store( VehicleState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.r, self.orbitr.x, addr, 0, sc, fc );\n\tmemstore( self.v, self.orbitr.y, addr, 1, sc, fc );\n\tmemstore( self.omega, self.orbitr.z, addr, 2, sc, fc );\n\tmemstore( self.B, self.orbitv, addr, 3, sc, fc );\n\tmemstore( self.localr, self.localr_base.x, addr, 6, sc, fc );\n\tmemstore( self.localv, self.localr_base.y, addr, 7, sc, fc );\n\tmemstore( self.localomega, self.localr_base.z, addr, 8, sc, fc );\n\tmemstore( self.localB, self.localr_diff, addr, 9, sc, fc );\n\tmemstore( self.acc, self.wdelay, addr, 12, sc, fc );\n\tmemstore( self.FSG, self.throttle, addr, 13, sc, fc );\n\tmemstore( self.EAR, self.trim, addr, 14, sc, fc );\n\tmemstore( self.EAR_hold, self.thr_hold, addr, 15, sc, fc );\n\tmemstore( vec3( self.modes ), float( self.switches ), addr, 16, sc, fc );\n\tmemstore( vec3( self.modes2 ), self.tvec, addr, 17, sc, fc );\n\tmemstore( self.aerostuff, addr, 18, sc, fc );\n\tmemstore( self.rcsstuff, self.canopy, addr, 19, sc, fc );\n\tmemstore( self.info, addr, 20, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MENU DATA\n\/\/ ----------------------------------------------------------------------------\n\nuvec4 md_load( sampler2D ch, int index )\n\t{ return unpack_uvec4( memload( ch, ADDR_MENU_DATA + ivec2( index, 0 ), 0 ) ); }\n\nconst int MENU_COMMAND = 1;\nconst int MENU_MAP = 2;\nconst int MENU_QUIT = 7;\nconst int MENU_INFO_BEGIN = 0x10;\nconst int MENU_INFO_SIZE = 8;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MESSAGE QUEUE\n\/\/ ----------------------------------------------------------------------------\n\nstruct MsgQueue\n{\n\tvec4 state;\n\tuvec4 phrase;\n\tvec4 argv;\n};\n\nconst int MSG_QUEUE_SIZE = 13;\n\nbool msg_empty( MsgQueue msg )\n\t{ return msg.state.x == -1.; }\n\nMsgQueue msg_load_and_pace( sampler2D ch, ivec2 addr, int index, float dt )\n{\n\tMsgQueue msg;\n\tmsg.state = memload( ch, addr, 0 );\n\n\tif( !msg_empty( msg ) )\n\t{\n\t\tif( msg.state.y > 0. )\n\t\t{\n\t\t\tdt -= msg.state.y;\n\t\t\tmsg.state.y = max( 0., -dt );\n\t\t}\n\n\t\tif( msg.state.y == 0. )\n\t\t{\n\t\t\tfloat p = ceil( msg.state.x ) - 1.;\n\t\t\tfloat q = msg.state.x - dt;\n\n\t\t\tif( q < p )\n\t\t\t{\n\t\t\t\tmsg.state.x = p;\n\t\t\t\tuint nextphraselen = unpack_uvec4( memload( ch, addr, 2 ) ).w & TXT_FMT_LENGTH_MASK;\n\t\t\t\tif( p >= 0. && nextphraselen > 0u )\n\t\t\t\t\tmsg.state.y = 1.5 + float( nextphraselen ) \/ 8. + q - p;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tmsg.state.x = max( -1., floor(q) ) + fract(q);\n\t\t}\n\t}\n\n\tif( index < 0 || index >= TXT_MSG_MAX_PHRASES )\n\t{\n\t\tmsg.phrase = uvec4(0);\n\t\tmsg.argv = vec4(0);\n\t}\n\telse\n\t{\n\t\tmsg.phrase = unpack_uvec4( memload( ch, addr, index + 1 ) );\n\t\tmsg.argv = memload( ch, addr, index + 1 + TXT_MSG_MAX_PHRASES );\n\t}\n\n\treturn msg;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ GAME STATE\n\/\/ ----------------------------------------------------------------------------\n\nstruct GameState\n{\n\tvec3 campos;\n\tfloat camzoom;\n\tmat3 camframe;\n\tvec3 mouselook;\n\tvec3 datetime;\n\tuint switches;\t\t\/\/ bitfield\n\tivec3 menustate;\t\/\/ current page, selection trigger, last selection persist\n\tint stage;\n\tvec3 mapmarker;\n\tfloat timer;\n\tvec3 waypoint;\n\tfloat hudbright;\n\tvec2 exposure;\n\tvec2 dragstate;\n\tvec3 campos_diff;\n\tvec3 vjoy;\t\t\t\/\/ virtual joystick from keyboard input\n\tvec3 vjoy_hold;\t\t\/\/ latch timers\n};\n\nconst int GAME_STATE_SIZE = 11;\n\nconst uint GS_IRCAM = 1u;\nconst uint GS_TRDAR = 2u;\nconst uint GS_NVISN = 4u;\nconst uint GS_TRMAP = 8u;\nconst uint GS_PAUSE = 16u;\nconst uint GS_FREEZ = 32u;\nconst uint GS_CHEES = 64u;\nconst uint GS_IPAGE_MASK = 0xf00u;\nconst uint GS_IPAGE_SHIFT = 8u;\nconst uint GS_MMODE_MASK = 0x3000u;\nconst uint GS_MMODE_SHIFT = 12u;\nconst uint GS_MPROJ_MASK = 0xc000u;\nconst uint GS_MPROJ_SHIFT = 14u;\nconst uint GS_HMD_BRIGHT_MASK = 0x30000u;\nconst uint GS_HMD_BRIGHT_SHIFT = 16u;\nconst uint GS_SUBSAMPLE_MASK = 0xc0000u;\nconst uint GS_SUBSAMPLE_SHIFT = 18u;\n\nconst int GS_INFO_LOCATION = 1;\nconst int GS_INFO_WAYPOINT = 2;\nconst int GS_INFO_ORBIT = 3;\nconst int GS_INFO_GLIDE = 4;\nconst int GS_INFO_CONTROLS = 5;\nconst int GS_INFO_AIR = 6;\nconst int GS_INFO_TIME = 7;\n\nconst int GS_MAP_PHYSICAL = 0;\nconst int GS_MAP_ELEVATION = 1;\nconst int GS_MAP_SLOPE = 2;\nconst int GS_MAP_EQ_AREA = 0;\nconst int GS_MAP_EQ_ANGLE = 1;\n\nconst int GS_INIT = 0;\nconst int GS_SPLASH = 1;\nconst int GS_SELECT_LOCATION = 2;\nconst int GS_TRANSITION = 3;\nconst int GS_RUNNING = 4;\n\nbool in_gs_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_GAME_STATE, GAME_STATE_SIZE, 1 ); }\n\nbool in_game_update_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_GAME_STATE, 24, 16 ); }\n\nGameState gs_init()\n{\n\treturn GameState( ZERO, 1., IDENTITY, UNIT_X, ZERO,\n\t\t\t\t\t  0x30000u | ( uint( SCN_SUBSAMPLE - 1. ) << GS_SUBSAMPLE_SHIFT ),\n\t\t\t\t\t  ivec3(0), GS_INIT, UNIT_X, 0., vec3(0), 1., vec2(1), vec2(0),\n\t\t\t\t\t  ZERO, ZERO, ZERO );\n}\n\nGameState gs_load( sampler2D ch, ivec2 addr )\n{\n\treturn GameState(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 0 ).w,\n\t\tmemload_mat3( ch, addr, 1 ),\n\t\tmemload_www( ch, addr, 1 ),\n\t\tmemload( ch, addr, 4 ).xyz,\n\t\tuint( memload( ch, addr, 4 ).w ),\n\t\tivec3( memload( ch, addr, 5 ).xyz ),\n\t\tint( memload( ch, addr, 5 ).w ),\n\t\tmemload( ch, addr, 6 ).xyz,\n\t\tmemload( ch, addr, 6 ).w,\n\t\tmemload( ch, addr, 7 ).xyz,\n\t\tmemload( ch, addr, 7 ).w,\n\t\tmemload( ch, addr, 8 ).xy,\n\t\tmemload( ch, addr, 8 ).zw,\n\t\tmemload( ch, addr, 9 ).xyz,\n\t\tmemload( ch, addr, 10 ).xyz,\n\t\tmemload( ch, addr, 11 ).xyz );\n}\n\nGameState gs_load_or_init( sampler2D ch, ivec2 addr, bool init )\n\t{ if( init ) return gs_init(); else return gs_load( ch, addr ); }\n\nvoid gs_store( GameState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.campos, self.camzoom, addr, 0, sc, fc );\n\tmemstore( self.camframe, self.mouselook, addr, 1, sc, fc );\n\tmemstore( self.datetime, float( self.switches ), addr, 4, sc, fc );\n\tmemstore( vec3( self.menustate ), float( self.stage ), addr, 5, sc, fc );\n\tmemstore( self.mapmarker, self.timer, addr, 6, sc, fc );\n\tmemstore( self.waypoint, self.hudbright, addr, 7, sc, fc );\n\tmemstore( vec4( self.exposure.xy, self.dragstate ), addr, 8, sc, fc );\n\tmemstore( self.campos_diff, 0., addr, 9, sc, fc );\n\tmemstore( self.vjoy, 0., addr, 10, sc, fc );\n\tmemstore( self.vjoy_hold, 0., addr, 11, sc, fc );\n}\n\nvec2 gs_map_project( GameState gs, vec3 r )\n{\n\tr = normalize(r) * gs.camframe;\n\tif( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )\n\t\tr.z = log( tan( atan( r.z, length( r.xy ) ) \/ 2. + PI \/ 4. ) );\n\tvec2 coord = vec2( atan( -r.y, -r.x ) , r.z );\n\treturn gs.camzoom * coord;\n}\n\nvec4 gs_map_unproject_d( GameState gs, vec2 sc, vec2 res, inout vec3 ddx, inout vec3 ddy )\n{\n\tvec4 coord_x = vec4( 2, 0, 0, 2. * sc.x - res.x ) \/ ( gs.camzoom * res.y );\n\tvec4 coord_y = vec4( 0, 2, 0, 2. * sc.y - res.y ) \/ ( gs.camzoom * res.y );\n\tvec4 c = coord_y;\n\tif( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )\n\t\tc = sin_d( 2. * atan_d( exp_d( coord_y ) ) - const_d( PIHALF ) );\n\n\tvec4 s = sqrt_d( max_d( const_d( 0. ), const_d( 1. ) - square_d( c ) ) );\n\tvec4 x = -mul_d( cos_d( coord_x ), s );\n\tvec4 y = -mul_d( sin_d( coord_x ), s );\n\tvec4 z = clamp_d( c, -ONE_D, ONE_D );\n\n\tddx = gs.camframe * vec3( x.x, y.x, z.x );\n\tddy = gs.camframe * vec3( x.y, y.y, z.y );\n\treturn vec4( gs.camframe * vec3( x.w, y.w, z.w ), c.w );\n}\n\nvec4 gs_map_unproject( GameState gs, vec2 sc, vec2 res )\n\t{ vec3 _; return gs_map_unproject_d( gs, sc, res, _, _ ); }\n\nfloat gs_get_subsample( GameState gs )\n{\n\treturn vec4( 1, 1.5, 2, 3 )[ ( gs.switches & GS_SUBSAMPLE_MASK ) >> GS_SUBSAMPLE_SHIFT ];\n}\n\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ACHIEVEMENT DETECTOR\n\/\/ ----------------------------------------------------------------------------\n\nstruct AchievementDetector\n{\n   \/\/ landing tracker\n   vec3 unused;\n   int LT_state;\n   vec3 LT_localv;\n   float LT_timer;\n};\n\nconst int ACHIEVEMENT_DETECTOR_SIZE = 2;\n\nconst int AD_LT_INIT = 0;\nconst int AD_LT_LANDED = 1;\nconst int AD_LT_AIRBORNE = 2;\nconst int AD_LT_TOUCHDOWN = 3;\nconst int AD_LT_BELLYDOWN = 4;\nconst int AD_LT_CRASH = 5;\n\nAchievementDetector ad_init()\n\t{ return AchievementDetector( ZERO, AD_LT_INIT, ZERO, 0. ); }\n\nAchievementDetector ad_load( sampler2D ch, ivec2 addr )\n{\n\treturn AchievementDetector(\n\t\tZERO,\n\t\tint( memload( ch, addr, 0 ).w ),\n\t\tmemload( ch, addr, 1 ).xyz,\n\t\tmemload( ch, addr, 1 ).w );\n}\n\nAchievementDetector ad_load_or_init( sampler2D ch, ivec2 addr, bool init )\n\t{ if( init ) return ad_init(); else return ad_load( ch, addr ); }\n\nvoid ad_store( AchievementDetector self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( ZERO, float( self.LT_state ), addr, 0, sc, fc );\n\tmemstore( self.LT_localv, self.LT_timer, addr, 1, sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ LOCAL ENVIRONMENT\n\/\/ ----------------------------------------------------------------------------\n\nstruct LocalEnv\n{\n\tvec4 atm;\t\t\t\/\/ local atmosphere state (T, P, rho, a)\n\tvec3 L;\t\t\t\t\/\/ local sunlight direction\n\tfloat H;\t\t\t\/\/ local geopotential altitude\n\tvec3 sunlight;\t\t\/\/ local sunlight flux (F over PI)\n\tfloat sundisk;\t\t\/\/ sun disk size: sin squared of half opening angle = (r_0\/r)^2\n\tvec2 phases;\t\t\/\/ local seasonal and diurnal phases\n\tvec2 atm2;\t\t\t\/\/ local atmospheric viscosity and molecular mean free path\n\tvec3 starlight;\t\t\/\/ local starlight flux\n\tfloat radius;\t\t\/\/ copy of local planet radius, if applicable\n};\n\nconst int LOCAL_ENV_SIZE = 5;\n\nbool in_le_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_LOCAL_ENV, LOCAL_ENV_SIZE, 1 ); }\n\nLocalEnv le_init()\n{\n\treturn LocalEnv( vec4(0), ZERO, 0., ZERO, 0., vec2(0), vec2(0), ZERO, 0. );\n}\n\nLocalEnv le_load( sampler2D ch, ivec2 addr )\n{\n\treturn LocalEnv(\n\t\tmemload( ch, addr, 0 ),\n\t\tmemload( ch, addr, 1 ).xyz, memload( ch, addr, 1 ).w,\n\t\tmemload( ch, addr, 2 ).xyz, memload( ch, addr, 2 ).w,\n\t\tmemload( ch, addr, 3 ).xy, memload( ch, addr, 3 ).zw,\n\t\tmemload( ch, addr, 4 ).xyz, memload( ch, addr, 4 ).w );\n}\n\nvoid le_store( LocalEnv self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.atm, addr, 0, sc, fc );\n\tmemstore( self.L, self.H, addr, 1, sc, fc );\n\tmemstore( self.sunlight, self.sundisk, addr, 2, sc, fc );\n\tmemstore( self.phases, self.atm2, addr, 3, sc, fc );\n\tmemstore( self.starlight, self.radius, addr, 4, sc, fc );\n}\n\nfloat mu_stretch( float mu, float stretch )\n{\n\t\/\/ overstretched version of max( 0., ... ) for lighting cosines\n\tfloat x = mu \/ stretch;\n\treturn x >= 24. ? mu : log2( 1. + exp2(x) ) * stretch;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ TERRAIN SAMPLER\n\/\/ ----------------------------------------------------------------------------\n\nstruct TrnSampler\n{\n\tvec3 rn;\t\t\t\/\/ normalized pivot position\n\tfloat r0;\t\t\t\/\/ hypocenter\n\tmat2x3 TB;\t\t\t\/\/ tangent frame\n\tfloat e;\t\t\t\/\/ radial distance over distance to hypocenter\n\tfloat invm;\t\t\t\/\/ 1 \/ ( asinh of distance to horizon over distance to hypocener )\n};\n\nconst int TRN_SAMPLER_SIZE = 3;\n\nbool in_ts_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_TRN_SAMPLERS, TRN_SAMPLER_SIZE, PLANET_DATA_COUNT ); }\n\nbool in_ts_last_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_TRN_SAMPLERS_LAST, TRN_SAMPLER_SIZE, PLANET_DATA_COUNT ); }\n\nbool in_terrain_samplers_range( ivec2 sc )\n\t{ return in_addr_range( sc, ADDR_TRN_SAMPLERS, 16, PLANET_DATA_COUNT ); }\n\nivec2 ts_addr( int index )\n\t{ return ADDR_TRN_SAMPLERS + ivec2( index, 0 ); }\n\nivec2 ts_last_addr( int index )\n\t{ return ADDR_TRN_SAMPLERS_LAST + ivec2( index, 0 ); }\n\nTrnSampler ts_init()\n\t{ return TrnSampler( ZERO, 0., mat2x3(0), 0., 0. ); }\n\nTrnSampler ts_load( sampler2D ch, ivec2 addr )\n{\n\treturn TrnSampler(\n\t\tmemload( ch, addr, 0 ).xyz,\n\t\tmemload( ch, addr, 0 ).w,\n\t\tmemload_mat2x3( ch, addr, 1 ),\n\t\tmemload( ch, addr, 1 ).w,\n\t\tmemload( ch, addr, 2 ).w );\n}\n\nTrnSampler ts_load_or_init( sampler2D ch, ivec2 addr, bool init )\n\t{ if( init ) return ts_init(); else return ts_load( ch, addr ); }\n\n\nvoid ts_store( TrnSampler self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.rn, self.r0, addr, 0, sc, fc );\n\tmemstore( self.TB[0], self.e, addr, 1, sc, fc );\n\tmemstore( self.TB[1], self.invm, addr, 2, sc, fc );\n}\n\nvec2 ts_params( float r0, float r )\n{\n\t\/\/ 12 levels: 1.002\n\t\/\/ 16 levels: 1.0005\n\tr = max( r0 * 1.0005, r );\n\treturn vec2(\n\t\tr0 \/ ( r - r0 ),\n\t\t1. \/ asinh( sqrt( ( r + r0 ) \/ ( r - r0 ) ) * r0 \/ r ) );\n}\n\nTrnSampler ts_init( vec3 r, float r0, vec3 up )\n{\n\tvec4 rn = length_normalize(r);\n\tvec2 params = ts_params( r0, rn.w );\n\tvec3 T = normalize( reject( up, rn.xyz ) );\n\tvec3 B = cross( rn.xyz, T );\n\treturn TrnSampler( rn.xyz, r0, mat2x3( T, B ), params.x, params.y );\n}\n\nbool ts_is_valid( TrnSampler ts )\n\t{ return ts.r0 > 0.; }\n\nvec2 ts_uv_centered( TrnSampler ts, vec3 rn )\n{\n\tvec3 drn = length_normalize( ( rn - ts.rn ) * ts.TB );\n\treturn drn.xy * asinh( ts.e * drn.z ) * ts.invm * TRN_UV_RANGE_INV;\n}\n\nvec2 ts_uv( TrnSampler ts, vec3 rn )\n\t{ return .5 + .5 * ts_uv_centered( ts, rn ); }\n\nfloat ts_lod( TrnSampler ts, float d )\n\t{ return ts.e * ts.invm \/ sqrt( ts.e * ts.e * d * d + 1. ); }\n\nfloat ts_lod( TrnSampler ts, vec3 rn )\n\t{ return ts_lod( ts, length( ( rn - ts.rn ) * ts.TB ) ); }\n\nbool ts_is_uv_safe( TrnSampler ts, vec3 rn )\n\t{  return lensq( ts_uv_centered( ts, rn ) ) < 1.; }\n\nvec4 ts_uv_inverse_lod( TrnSampler ts, vec2 uv )\n{\n\tvec3 uvn = length_normalize( ( 2. * uv - 1. ) * TRN_UV_RANGE );\n\tfloat d = sinh( uvn.z \/ ts.invm ) \/ ts.e;\n\tif( d < 1. && uvn.z < TRN_UV_RANGE )\n\t{\n\t\tvec3 x = ts.r0 * ( ts.TB * uvn.xy * d + ts.rn * cosasin(d) );\n\t\treturn vec4( x, ts_lod( ts, d ) );\n\t}\n\telse\n\t\treturn vec4(0);\n}\n\nfloat ts_scale( vec3 r, float r0 )\n{\n\tvec4 rn = length_normalize(r);\n\tvec2 params = ts_params( r0, rn.w );\n\treturn params.x * params.y;\n}\n\nvoid ts_update_stable( inout TrnSampler ts, vec3 r, float r0, float res, vec4 box )\n{\n\tbool mustupdate = true;\n\tif( ts_is_valid( ts ) )\n\t{\n\t\tif( ts_is_uv_safe( ts, normalize(r) ) )\n\t\t{\n\t\t\tvec2 uvnew = ts_uv( ts, normalize(r) );\n\t\t\tmustupdate = length( uvnew - .5 ) * res * TRN_SCALE >= TRN_UPDATE_THRESHOLD * SCN_SCALE;\n\n\t\t\tfloat scalenew = ts_scale( r, r0 );\n\t\t\tfloat scaleold = ts.e * ts.invm;\n\n\t\t\tmustupdate = mustupdate ||\n\t\t\t\tabs( scalenew - scaleold ) * res >= 4. * TRN_UPDATE_THRESHOLD * scaleold;\n\n\t\t\t\/*\n\t\t\tif( mustupdate )\n\t\t\t{\n\t\t\t\tvec3 r_from_uvnew = ts_uv_inverse_lod( ts, round( uvnew * res ) \/ res ).xyz;\n\t\t\t\t\/\/ if( r_from_uvnew != ZERO )\n\t\t\t\t\tr = length(r) \/ ts.r0 * r_from_uvnew;\n\t\t\t\t\/\/ else\n\t\t\t\t\/\/\tmustupdate = false;\n\t\t\t}\n\t\t\t\/\/*\/\n\t\t}\n\t}\n\tif( mustupdate )\n\t\tts = ts_init( r, r0, UNIT_Z );\n}\n\nvec4 ts_box_main( sampler2D ch )\n{\n\tvec2 res = vec2( textureSize( ch, 0 ) );\n\tfloat w = res.y - 4.;\n\treturn vec4( 0, 2, w, w );\n}\n\nvec4 ts_box_aux( sampler2D ch, float i )\n{\n\tvec2 res = vec2( textureSize( ch, 0 ) );\n\tfloat x = ts_box_main( ch ).z;\n\tfloat w = round( res.y * .35 );\n\treturn vec4( x + w * i, res.y - 2. - w, w, w );\n}\n\nvec4 ts_box_shadow( sampler2D ch )\n{\n\tvec2 res = vec2( textureSize( ch, 0 ) );\n\tvec4 aux = ts_box_aux( ch, 0. );\n\tfloat x = aux.x;\n\tfloat w = min( aux.y - 2., res.x - x );\n\treturn vec4( x, 2, w, w );\n}\n\nvec4 ts_box_skylight( sampler2D ch )\n{\n\tvec2 res = vec2( textureSize( ch, 0 ) );\n\tfloat w = res.y \/ 2. - 2.;\n\tfloat y = res.y \/ 2.;\n\treturn vec4( 0, y, w, w );\n}\n\nbool ts_box_inside( vec4 box, vec2 fc )\n\t{ return all( lessThan( ( fc.xxyy - box.xxyy ) * vec2( 1, -1 ).xyxy, vec3( box.zw, 0 ).xzyz ) ); }\n\nvec4 ts_unpack_normal( TrnSampler ts, vec4 tsmpl )\n{\n\tvec3 N = ts.TB * tsmpl.xy + ts.rn * sqrt( max( 0., 1. - dot( tsmpl.xy, tsmpl.xy ) ) );\n\treturn vec4( N, tsmpl.w );\n}\n\nvec4 ts_lookup_centered( TrnSampler ts, sampler2D ch, vec4 box, vec2 uv )\n{\n\tvec2 res = vec2( textureSize( ch, 0 ) );\n\tvec2 limit = box.zw - 1.;\n\treturn textureLod( ch, ( box.xy + .5 * ( box.zw + clamp( box.zw * uv, -limit, limit ) ) ) \/ res, 0. );\n}\nvec4 ts_lookup( TrnSampler ts, sampler2D ch, vec4 box, vec2 uv )\n\t{ return ts_lookup_centered( ts, ch, box, uv * 2. - 1. ); }\n\nvec4 ts_lookup( TrnSampler ts, sampler2D ch, vec4 box, vec3 rn )\n\t{ return ts_lookup_centered( ts, ch, box, ts_uv_centered( ts, rn ) ); }\n\nvec4 ts_sample( TrnSampler ts, sampler2D ch, vec3 rn )\n\t{ return ts_unpack_normal( ts, ts_lookup( ts, ch, ts_box_main( ch ), rn ) ); }\n\nvec2 ts_shadow_sample( TrnSampler ts, sampler2D ch, vec4 rn )\n{\n#if WITH_TRN_SHADOW\n\tvec4 lookup = ts_lookup( ts, ch, ts_box_shadow( ch ), rn.xyz );\n\treturn vec2( lookup.x != lookup.y ? parabolstep( lookup.x, lookup.y, rn.w ) : 1., lookup.z );\n#else\n\treturn vec2(1);\n#endif\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ TERRAIN GENERATOR\n\/\/ ----------------------------------------------------------------------------\n\nfloat trn_rand( ivec3 p )\n{\n\tivec3 q = sign(p) * abs(p) & 65535;\n\tint x = ( 3 + 4 * ( q.x + q.y * ( 1 + p.x ) + q.z * ( 1 + p.x + p.y ) ) );\n\tx = ( ( x  & 262143 ) * 47485 ) & 262143;\n\tfloat y = 2. * float(x) \/ 262144. - 1.;\n\treturn y;\n}\n\nvec4 trn_noise_d( vec3 x )\n{\n\tvec3 xf = fract(x);\n\tvec3 xi = floor(x);\n\tivec3 ix = ivec3( xi );\n\tvec4 p = vec4( trn_rand( ix + ivec3( 0, 0, 0 ) ), trn_rand( ix + ivec3( 1, 0, 0 ) ),\n\t\t\t\t   trn_rand( ix + ivec3( 0, 1, 0 ) ), trn_rand( ix + ivec3( 1, 1, 0 ) ) );\n\tvec4 q = vec4( trn_rand( ix + ivec3( 0, 0, 1 ) ), trn_rand( ix + ivec3( 1, 0, 1 ) ),\n\t\t\t\t   trn_rand( ix + ivec3( 0, 1, 1 ) ), trn_rand( ix + ivec3( 1, 1, 1 ) ) );\n\tvec3 t = xf - .5;\n\tvec3 u = .5 - 2. * ( abs(t) * t - t );\n\tvec3 v = 2. - 4. * abs(t);\n\tvec4 dpq = q - p;\n\tvec4 pqz = mix( p, q, u.z );\n\treturn vec4(\n\t\tmix( pqz.yz - pqz.xx, pqz.ww - pqz.zy, u.yx ) * v.xy,\n\t\tmix( mix( dpq.x, dpq.y, u.x ), mix( dpq.z, dpq.w, u.x ), u.y ) * v.z,\n\t\tmix( mix( pqz.x, pqz.y, u.x ), mix( pqz.z, pqz.w, u.x ), u.y ) );\n}\n\nstruct TrnContext\n{\n\t\/\/ accumulation variables\n\tvec4 h;\t\t\t\/\/ height with partial derivatives\n#if WITH_TRN_SURFACE_AA\n\tvec2 a;\t\t\t\/\/ residual height and slope variance\n#endif\n\t\/\/ read only precomputed\n\tfloat zl;\t\t\/\/ zone level\n\tfloat zw;\t\t\/\/ zone weight\n\tfloat fl;\t\t\/\/ flatten multiplier\n\tfloat is;\t\t\/\/ gaussian multiplier (inv sigma)\n\tfloat na;\t\t\/\/ noise amplitude\n};\n\nTrnContext trn_context_init( const TrnData trn, vec4 zone, vec3 rn )\n{\n\treturn TrnContext(\n\t\tvec4(0),\n\t#if WITH_TRN_SURFACE_AA\n\t\tvec2(0),\n\t#endif\n\t\t-log2( zone.w ),\n\t\t1. - exp2pp( -lensq( zone.xyz - rn ) \/ ( zone.w * zone.w ) ),\n\t\t1. \/ trn.flatten.y,\n\t\tSQRTHALF \/ trn.noise.z,\n\t\tONEOVERSQRTPI * trn.noise.x * ( SQRTHALF \/ trn.noise.z )\n\t);\n}\n\nvoid trn_context_iterate( inout TrnContext ctx, const TrnData trn, vec4 zone, vec3 rn,\n\t\t\t\t\t\t  float N0, float N1 )\n{\n\tint i0 = int( floor( N0 ) );\n\tint i1 = int( ceil( N1 ) );\n\tconst float S = .05 \/ EULER;\n\tfor( int i = i0; i < i1; ++i )\n\t{\n\t\tfloat j = float(i);\n\t\tfloat k = ldexp( 1., i );\n\t\tfloat u = ( j - trn.noise.y ) * ctx.is;\n\t\tfloat v = ctx.na * exp2( - u * u - j );\n\t\tfloat slip = 1. + trn.slope.z * dot( ctx.h.xyz, ctx.h.xyz );\n\t\tvec3 x = k * ( rn + trn.seeds );\n\t\tvec3 dx = trn.slope.y * ctx.h.xyz;\n\t\tvec4 n = trn_noise_d( x + dx ) * vec4( k, k, k, 1 );\n\t\tvec4 g = smin1_d( square_d( ( ctx.h - const_d( trn.flatten.x ) ) * ctx.fl ), S );\n\t\tvec4 f = mix_d( const_d( 1. - trn.flatten.z ), ONE_D, g );\n\t\tvec4 l = max_d( const_d( 0. ), min_d( ctx.h - const_d( trn.levels.x ), const_d( trn.levels.y ) - ctx.h ) );\n\t\tvec4 d = mul_d( l, smin1_d( div_d( f * v, l ), S ) ) \/ slip;\n\t\tfloat w1 = saturate( N1 - j );\n\t\tfloat w2 = saturate( j + 1. - N0 );\n\t\tfloat w3 = mix( 1., ctx.zw, saturate( j - ctx.zl ) );\n\t\tctx.h += min( w1, w2 ) * w3 * mul_d( d, n );\n\t#if WITH_TRN_SURFACE_AA\n\t\tctx.a += square( min( 1. - w1, w2 ) * w3 * d.w * vec2( 1, k ) );\n\t#endif\n\t}\n}\n\nvoid trn_context_iterate_finish( inout TrnContext ctx, const TrnData trn, vec4 zone, vec3 rn,\n\t\t\t\t\t\t\t\t float N1, float NMAX )\n{\n\tint i1 = int( ceil( N1 ) );\n\tint iend = int( ceil( NMAX ) );\n\tconst float S = .05 \/ EULER;\n#if WITH_TRN_SURFACE_AA\n\tfloat invslip = 1. \/ ( 1. + trn.slope.z * dot( ctx.h.xyz, ctx.h.xyz ) );\n\tfloat g = smin1( square( ( ctx.h.w - trn.flatten.x ) * ctx.fl ), S );\n\tfloat f = mix( 1. - trn.flatten.z, 1., g );\n\tfloat l = min( ctx.h.w - trn.levels.x, trn.levels.y - ctx.h.w );\n\tfor( int i = i1; i < iend; ++i )\n\t{\n\t\tfloat j = float(i);\n\t\tfloat k = ldexp( 1., i );\n\t\tfloat u = ( j - trn.noise.y ) * ctx.is;\n\t\tfloat v = ctx.na * exp2( - u * u - j );\n\t\tfloat d = min( f * v, l ) * invslip;\n\t\tfloat w3 = mix( 1., ctx.zw, saturate( j - ctx.zl ) );\n\t\tctx.a += square( w3 * d * vec2( 1, k ) );\n\t}\n#endif\n}\n\nfloat trn_elevation( vec3 _r, float detail, PlanetData data, vec4 zone )\n{\n\tvec3 rn = normalize(_r);\n\tTrnContext ctx = trn_context_init( data.trn, zone, rn );\n\ttrn_context_iterate( ctx, data.trn, zone, rn, 0., detail );\n\treturn data.radius * data.trn.slope.x * ( ctx.h.w - data.trn.levels.z - dot( rn, data.trn.offcenter ) );\n}\n\nvec4 trn_elevation_refine( vec3 rn, float detail, PlanetData data, vec4 zone,\n\t\t\t\t\t\t   float origdetail, vec4 tsmpl, inout vec2 sigmares )\n{\n\tTrnContext ctx = trn_context_init( data.trn, zone, rn );\n\tctx.h = vec4( ( rn - tsmpl.xyz \/ dot( tsmpl.xyz, rn ) ) * data.trn.slope.x,\n\t\t\t\t  tsmpl.w \/ ( data.radius * data.trn.slope.x ) + data.trn.levels.z + dot( rn, data.trn.offcenter ) );\n\ttrn_context_iterate( ctx, data.trn, zone, rn, origdetail, detail );\n#if WITH_TRN_SURFACE_AA\n\ttrn_context_iterate_finish( ctx, data.trn, zone, rn, detail, TRN_MAX_LEVELS + TRN_MAX_REFINE_LEVELS );\n\tsigmares = sqrt( ctx.a \/ 3. ) * data.trn.slope.x;\n#endif\n\treturn vec4( normalize( rn - reject( data.trn.slope.x * ctx.h.xyz, rn ) ), tsmpl.w );\n}\n\nvec4 ts_sample_fine( TrnSampler ts, sampler2D ch, vec3 rn,\n\t\t\t\t\t PlanetData data, float Kx, inout vec2 sigmares )\n{\n#if WITH_TRN_REFINE\n\tfloat res = float( textureSize( ch, 0 ).y );\n\tfloat lod = ts_lod( ts, rn );\n\tfloat detail = min( log2( res * lod ) - TRN_LOD_BIAS, TRN_MAX_LEVELS );\n\tvec4 lookup = ts_lookup( ts, ch, ts_box_main( ch ), rn );\n\tint zoneindex = int( lookup.z );\n\tvec4 tsmpl = ts_unpack_normal( ts, lookup );\n\tvec4 zone = ld_load( ch, ld_addr_b( zoneindex ) ).zone;\n\treturn trn_elevation_refine(\n\t\trn,\n\t\tmin( detail + TRN_MAX_REFINE_LEVELS, log2( data.radius \/ Kx ) ),\n\t\tdata,\n\t\tzone,\n\t\tdetail,\n\t\ttsmpl,\n\t\tsigmares\n\t\t);\n#else\n\treturn ts_sample( ts, ch, normalize(x) );\n#endif\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ANISOTROPICALLY ANTIALIASED ANALYTIC PRIMITIVES\n\/\/ ----------------------------------------------------------------------------\n\nfloat Linfinity( vec2 a )\n\t{ return max( abs( a.x ), abs( a.y ) ); }\n\nfloat aaa_cov( float a )\n\t{ return saturate( a ); }\n\nfloat aaa_step( float K, float u )\n\t{ return aaa_cov( .5 + u \/ K ); }\n\nvec2 aaa_step2( vec2 K, vec2 u )\n\t{ return vec2( aaa_step( K.x, u.x ), aaa_step( K.y, u.y ) ); }\n\nfloat aaa_interval( float K, float u, float size )\n\t{ return aaa_cov( K < size ? .5 + ( .5 * size - abs(u) ) \/ K : ( 1. - abs(u) \/ K ) * size \/ K ); }\n\nvec2 aaa_interval2( vec2 K, vec2 u, vec2 size )\n\t{ return vec2( aaa_interval( K.x, u.x, size.x ), aaa_interval( K.y, u.y, size.y ) ); }\n\nfloat aaa_stipple( float K, float u, float per, float x_duty )\n{\n\tfloat duty = fract( x_duty );\n\tfloat d = min( duty, 1. - duty );\n\tfloat s = d * per;\n\tu = abs( mod( u, per ) - per \/ 2. );\n\treturn floor( x_duty ) + aaa_cov( K < .5 * per ?\n\t\t( duty < .5 ? aaa_interval( K, u, s ) : 1. - aaa_interval( K, per \/ 2. - u, s ) ) :\n\t\tduty - ( u - per \/ 4. ) * d \/ K );\n}\n\nvec2 aaa_stipple2( vec2 K, vec2 u, vec2 per, vec2 x_duty )\n\t{ return vec2( aaa_stipple( K.x, u.x, per.x, x_duty.x ), aaa_stipple( K.y, u.y, per.y, x_duty.y ) ); }\n\nfloat aaa_box( mat2 K, vec2 uv, vec2 size, vec2 edge )\n{\n\treturn aaa_interval( max( edge.x, Linfinity( K[0] ) ), uv.x, size.x ) *\n\t\t   aaa_interval( max( edge.y, Linfinity( K[1] ) ), uv.y, size.y );\n}\n\nfloat aaa_rect( mat2 K, vec2 uv, vec2 size, vec2 d )\n{\n\treturn aaa_box( K, uv, size + d, vec2(0) ) * ( 1. - aaa_box( K, uv, size - d, vec2(0) ) );\n}\n\nfloat aaa_line( mat2 K, vec2 uv, vec2 dx, float width )\n{\n\tvec3 dxn = length_normalize( dx );\n\tmat2 M = mat2( dxn.xy, perp( dxn.xy ) );\n\tuv = ( uv - dx \/ 2. ) * M;\n\treturn aaa_box( K * M, uv, vec2( dxn.z, width ), vec2(0) );\n}\n\nfloat aaa_line( mat2 K, vec2 uv, vec2 x0, vec2 x1, float width )\n\t{ return aaa_line( K, uv - x0, x1 - x0, width ); }\n\nfloat aaa_hline( mat2 K, vec2 uv, vec2 x0, float w, float width )\n{\n\tuv = uv - vec2( w \/ 2., 0 );\n\treturn aaa_box( K, uv - x0, vec2( w, width ), vec2(0) );\n}\n\nfloat aaa_vline( mat2 K, vec2 uv, vec2 x0, float h, float width )\n{\n\tuv = uv - vec2( 0, h \/ 2. );\n\treturn aaa_box( mat2( perp( K[0] ), perp( K[1] ) ), uv - x0, vec2( width, h ), vec2(0) );\n}\n\nfloat aaa_disk( mat2 K, vec2 uv, float size )\n{\n\tvec3 uvn = length_normalize( uv );\n\treturn aaa_interval( Linfinity( K * uvn.xy ), uvn.z, size );\n}\n\nfloat aaa_ring( mat2 K, vec2 uv, float size, float d )\n{\n\tvec3 uvn = length_normalize( uv );\n\treturn aaa_interval( Linfinity( K * uvn.xy ), abs( uvn.z - size \/ 2. ), d );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 2 of 6: Buffer A shader (simulation and update logic)\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\/\n\nGameState GS;\nVehicleState VS;\nTrnSampler TS;\nPlanetData PD;\nvec4 DT;\n\nfloat g_subsample = SCN_SUBSAMPLE;\nint g_msgindex = 0;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ PLANET DATA\n\/\/ ----------------------------------------------------------------------------\n\n\/*\n\t\t\t\t\t\t\t\t\t615\t\t535\t\t445\t\t1250\n\n\tRayleigh optical depth [1]\t\t0.0573\t0.1001\t0.1971\t0.0034\n\tAerosol optical depth [2]\t\t0.0657\t0.0837\t0.1144\t0.0192\n\tOzone absorbtion [3]\t\t\t0.0346\t0.0215\t0.0019\t0.0000029\n\tWater vapor absorption [4]\t\t0.0157\t0.0051\t0.00026\t0.0372\n\n\t[1] Fr\u00f6hlich & Shaw 1980 (with Young's correction)\n\t[2] AOD 0.08, centered at 550 nm, with \u00c5ngstr\u00f6m exponent 1.75 (estimate of global average)\n\t[3] Optical depth of 300 Dobson units ozone (about 0.35 ppm)\n\t[4] Optical depth of 2.5 cm precipitable water vapor (estimate of global average, mid-latitude over land more like 1.0)\n\n*\/\n\nconst vec4 ATM_TAU_RAYLEIGH =\t\t\t\t\tvec4( 0.0572, 0.1003, 0.1977, 0.0034 );\nconst vec4 ATM_TAU_AEROSOL =\t  0.08 \/ 0.08 * vec4( 0.0657, 0.0837, 0.1144, 0.0192 );\nconst vec4 ATM_TAU_OZONE =\t\t  300. \/ 300. * vec4( 0.0346, 0.0215, 0.0019, 2.9e-6 );\nconst vec4 ATM_TAU_VAPOR =\t\t   1.5 \/  2.5 *\tvec4( 0.0160, 0.0052, 2.6e-4, 0.0372 );\n\nconst vec4 ATM_OMEGA_AEROSOL = vec4( .93, .94, .95, .8 );\n\nconst PlanetData[] g_planet_data = PlanetData[](\n\n\t\/\/ Solna\n\tPlanetData(\n\t\t0.,\n\t\t25509.5825 * ATM_SCALE,\n\t\t66355148.4 * SCN_SCALE,\n\t\t0.,\n\t\t0.,\n\t\tvec2(0),\n\t\tKEPLERA( 0., 0., 0., 0., 0. ),\n\t\tTrnData( ZERO, ZERO, ZERO, ZERO, ZERO, ZERO ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tOcnData( vec4(0), vec4(0), ZERO ),\n\t\tAtmProfile( vec4(0), ZERO, 0., mat4x2(0), mat4x2(0), ZERO, mat2x3( ZERO, ZERO ), vec2(0), 0. ),\n\t\tAtmModel( 0., 0., vec4(0), vec4(0), vec4(0), vec4(0), 0., vec4(0), vec2(0), vec4(0), vec2(0) ),\n\t\tCldData( ZERO, ZERO, vec2(0), vec4(0), vec4(0) )\n\t),\n\n\t\/\/ Miderra\n\tPlanetData(\n\t\t0.,\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ parent\n\t\t954.152114 * SCN_SCALE,\t\t\t\t\t\t\t\t\/\/ radius\n\t\t9040.92620 * SCN_SCALE,\t\t\t\t\t\t\t\t\/\/ GM\n\t\t245.292733 * SCN_SCALE,\t\t\t\t\t\t\t\t\/\/ orbital period\n\t\t3.93581843 * SCN_SCALE,\t\t\t\t\t\t\t\t\/\/ rotation period\n\t\tvec2( radians( 66.5608 ), radians( 90.0000 ) ),\t\t\/\/ north pole\n\t\tKEPLERA( 1094367.24 * SCN_SCALE, 0.011793800, 0., radians( 114.2 ), radians( 348.7 ) ),\n\n\t\tTrnData(\n\t\t\tvec3( 0.00, -1.05, -8.05 ),\t\t\t\t\t\t\/\/ seed\n\t\t\tvec3( -0.010, 0.0115, 0.00090 ),\t\t\t\t\/\/ levels\n\t\t\tvec3( 0.00020, 0.00010, 0.00011 ),\t\t\t\t\/\/ offcenter\n\t\t\tvec3( 2.40, 8.90, 5.6 ),\t\t\t\t\t\t\/\/ noise\n\t\t\tvec3( 0.00070, 0.0072, 0.96 ),\t\t\t\t\t\/\/ flatten\n\t\t\tvec3( TRN_SCALE \/ SCN_SCALE, -1.25, 2.50 ) ),\t\/\/ slope effects\n\n\t\tTrnLayer( vec4( .059, .066, .031, .45 ), vec4( 0, 0.7, 1.03, 1.09 ), vec4(0), 0., 0., 0. ), \/\/ trees\n\t\tTrnLayer( vec4( .167, .173, .055, .55 ), vec4( 5, 1.0, 0.95, 0.90 ), vec4( -0.50, -1.00,\t 1.00, -25.00 ), +1.50, 0.05, 0.95 ),\t \/\/ gras\n\t\tTrnLayer( vec4( .155, .124, .081, .25 ), vec4( 2, 0.8, 0.95, 0.90 ), vec4(\t 0.00,\t0.00, -500.00,\t 0.00 ), +0.00, 0.00, 1.00 ),\t \/\/ tide\n\t\tTrnLayer( vec4( .391, .260, .137, .40 ), vec4( 1, 1.0, 0.92, 0.88 ), vec4(\t 0.25, -2.00,\t-1.00,\t-5.00 ), +0.55, 0.05, 0.85 ),\t \/\/ sand\n\t\tTrnLayer( vec4( .815, .801, .788, .15 ), vec4( 5, 1.0, 1.10, 1.15 ), vec4( -3.30,\t0.00,\t 1.30,\t-1.00 ), +0.80, 0.00, 1.00 ),\t \/\/ snow\n\t\tTrnLayer( vec4( .200, .191, .181, .35 ), vec4( 5, 1.5, 1.02, 1.06 ), vec4( -0.25, -0.50,\t 0.25,\t 1.00 ), -0.35, 0.00, 1.00 ),\t \/\/ rock\n\n\t\tOcnData(\n\t\t\tvec4( .1760, .0567, .0355, 25 ),\n\t\t\tvec4( .0050, .0188, .0441, 0 ),\t\t\t\t\t\/\/ color for about 0.5 mg\/m\u00b3 chlorophyll concentration\n\t\t\t\/\/ vec4( .0020, .0105, .0295, 0 ),\t\t\t\t\/\/ color for about 0.1 mg\/m\u00b3 chlorophyll concentration\n\t\t\tvec3( 277.16, 1025, 0.1628 )\t\t\t\t\t\/\/ temp \/ dens \/ roughness for avg wind speed of 7.5 m\/s\n\t\t),\n\n\t\tAtmProfile(\n\t\t\tvec4( 288.15, 1.01325, 1.225, 8.4086 * ATM_SCALE ),\n\t\t\tvec3( 102.94 * ATM_SCALE, 1000., 56.81 * ATM_SCALE ),\n\t\t\t.340293991,\n\t\t\tmat4x2( vec2( 10.9662 * ATM_SCALE, 216.65 ), vec2( 14.7740 * ATM_SCALE, 206.58 ),\n\t\t\t\t\tvec2( 19.9385 * ATM_SCALE, 216.65 ), vec2( 31.9016 * ATM_SCALE, 228.65 ) ),\n\t\t\tmat4x2( vec2( 46.8556 * ATM_SCALE, 270.65 ), vec2( 50.8432 * ATM_SCALE, 270.65 ),\n\t\t\t\t\tvec2( 70.7818 * ATM_SCALE, 214.65 ), vec2( 84.5913 * ATM_SCALE, 186.87 ) ),\n\t\t\tvec3( 43.118, 0.0761, -32.6285 ),\n\t\t\tmat2x3( vec3( 3.8533, -4.7020, -3.9716 ), vec3( -4.9857, 4.9801, 5.1333 ) ),\n\t\t\tvec2( 6, 12 ),\n\t\t\t.000000085\t  \/\/ 85 nm\n\t\t),\n\n\t\tAtmModel(\n\t\t\t7.5296 * ATM_SCALE,\n\t\t\t0.5,\n\t\t\tATM_TAU_RAYLEIGH + ATM_TAU_AEROSOL + ATM_TAU_OZONE + ATM_TAU_VAPOR,\t\t\/\/ total optical depth\n\t\t\tATM_TAU_RAYLEIGH + ATM_TAU_AEROSOL * ATM_OMEGA_AEROSOL,\t\t\t\t\t\/\/ scattering optical depth\n\t\t\tATM_TAU_AEROSOL + ATM_TAU_VAPOR,\t\t\t\t\t\t\t\t\t\t\/\/ ground layer optical depth\n\t\t\tATM_TAU_AEROSOL * ATM_OMEGA_AEROSOL,\t\t\t\t\t\t\t\t\t\/\/ ground layer scattering optical depth\n\t\t\t4.,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ ground layer scale height multiplier\n\t\t\tATM_TAU_OZONE * 0.95,\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ ozone layer\n\t\t\tvec2( 22.4308, 6.4103 ) * ATM_SCALE,\t\t\t\t\t\t\t\t\t\/\/ (altitude profile)\n\t\t\tCOL_AIRGLOW,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ emission layer\n\t\t\tvec2( 85.1393, 4.4863 ) * ATM_SCALE\t\t\t\t\t\t\t\t\t\t\/\/ (altitude profile)\n\t\t),\n\n\t\tCldData(\n\t\t\tvec3( 2.2, 65., 0.85 ),\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ akg\n\t\t\tvec3( 3, 9, 1 ),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ fluff\n\t\t\tvec2( 32, 1.5 ),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ size\n\t\t\tvec4( 20.05, -8, -31, 8 ),\t\t\t\t\t\t\t\t\t\t\t\t\/\/ noise\n\t\t\tvec4( .42, .000045, .000015, .00002 )\t\t\t\t\t\t\t\t\t\/\/ move\n\t\t)\n\t),\n\n\t\/\/ Muni\n\tPlanetData(\n\t\t1.,\n\t\t384.241473 * SCN_SCALE,\n\t\t416.174725 * SCN_SCALE,\n\t\t40.0059351 * SCN_SCALE,\n\t\t40.0059351 * SCN_SCALE,\n\t\tvec2( radians( -95.3701 ), radians( 89.9783 ) ),\n\t\tKEPLERA( 16810.0503 * SCN_SCALE, 0.039031473, radians( 5.1 ), radians( 125.1 ), radians( 318.2 ) ),\n\n\t\tTrnData(\n\t\t\tvec3( -0.00, -1.05, -8.05 ),\t\t\/\/ seed\n\t\t\tvec3( -0.023, 0.020, 0.0006 ),\t\t\/\/ levels\n\t\t\tZERO,\n\t\t\tvec3( 1.70, 6, 4.5 ),\t\t\t\t\/\/ noise\n\t\t\tvec3( 0.0003, 0.010, 0.95 ),\t\t\/\/ flatten\n\t\t\tvec3( 1.0, -1.0, 2.0 ) ),\t\t\t\/\/ slope\n\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\t\tTrnLayer( vec4(0), vec4(0), vec4(0), 0., 0., 0. ),\n\n\t\tOcnData( vec4(0), vec4(0), ZERO ),\n\t\tAtmProfile( vec4(0), ZERO, 0., mat4x2(0), mat4x2(0), ZERO, mat2x3( ZERO, ZERO ), vec2(0), 0. ),\n\t\tAtmModel( 0., 0., vec4(0), vec4(0), vec4(0), vec4(0), 0., vec4(0), vec2(0), vec4(0), vec2(0) ),\n\t\tCldData( ZERO, ZERO, vec2(0), vec4(0), vec4(0) )\n\t)\n);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ START DATA\n\/\/ ----------------------------------------------------------------------------\n\nconst StartData[] g_start_data = StartData[](\n\n\t\/\/ Init\n\tStartData( uvec4(0), ivec4( 1, 1, 0, 0 ), vec4( 30, 120, 1000, 120 ) ),\n\n\t\/\/ Low orbit\n\tStartData( uvec4( 0x4c6f7720, 0x90000000, 0, 5 ),\n\t\t\t   ivec4( 1, 0, 0, 7 ), vec4( 0, 30, 150, 60 ) ),\n\n\t\/\/ Space center west\n\tStartData( uvec4( 0x94959700, 0, 0, 3 ),\n\t\t\t   ivec4( 3, 0, 0, 7 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Space center east\n\tStartData( uvec4( 0x94959600, 0, 0, 3 ),\n\t\t\t   ivec4( 3, 7, 0, 25 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Lucerne\n\tStartData( uvec4( 0x4c756365, 0x726e6500, 0, 7 ),\n\t\t\t   ivec4( 3, 15, 0, 19 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Bensersiel\n\tStartData( uvec4( 0x42656e73, 0x65727369, 0x656c0000, 10 ),\n\t\t\t   ivec4( 2, 0, 0, 19 ), vec4( 62.47, 152.0782, .0008, 250. ) ),\n\n\t\/\/ North point (Kaffeklubben island)\n\tStartData( uvec4( 0x4b616666, 0x656b6c75, 0x6262656e, 0x20a8000e ),\n\t\t\t   ivec4( 2, 0, 0, 19 ), vec4( 87.3323, 157.6711, -.0003, 180 ) ),\n\n\t\/\/ Spitsbergen\n\tStartData( uvec4( 0x53706974, 0x73626572, 0x67656e00, 11 ),\n\t\t\t   ivec4( 2, 0, 0, 73 ), vec4( 72.4248, 79.5030, 6.0972, 270 ) ),\n\n\t\/\/ Canc\u00fan\n\tStartData( uvec4( 0xa1202020, 0, 0, 4 ),\n\t\t\t   ivec4( 3, 25, 0, 37 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Underwater primitive exhibition\n\tStartData( uvec4( 0xa2a36578, 0x68696269, 0x74696f6e, 12 ),\n\t\t\t   ivec4( 2, 0, 0, 25 ), vec4( 28.9906, 156.4883, -.0143, 350 ) ),\n\n\t\/\/ Rocky Springs\n\tStartData( uvec4( 0x526f636b, 0x79205370, 0x72696e67, 0x7300000d ),\n\t\t\t   ivec4( 3, 45, 0, 51 ), vec4( -1, ZERO ) ),\n\n\t\/\/ Lake Victoria\n\tStartData( uvec4( 0x4c616b65, 0x20566963, 0x746f7269, 0x6100000d ),\n\t\t\t   ivec4( 3, 51, 0, 45 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Hang gliding challenge\n\tStartData( uvec4( 0x48616e67, 0x20676c69, 0x64696e67, 0x20a4000e ),\n\t\t\t   ivec4( 2, 0, 0, 58 ), vec4( -51.5485, -124.1851, 7.3009, 70 ) ),\n\n\t\/\/ Hang gliding destination\n\tStartData( uvec4( 0x48616e67, 0x20676c69, 0x64696e67, 0x20ad000e ),\n\t\t\t   ivec4( 3, 58, 0, 55 ), vec4( -1, ZERO ) ),\n\n\t\/\/ South pole station\n\tStartData( uvec4( 0x999a9b00, 0, 0, 3 ),\n\t\t\t   ivec4( 2, 0, 0, 69 ), vec4( -89.9883, 31.6990, .0123, 150. ) ),\n\n\t\/\/ Gonder (Ethiopian highlands)\n\tStartData( uvec4( 0x476f6e64, 0x65720000, 0, 6 ),\n\t\t\t   ivec4( 3, 70, 0, 0 ), vec4( -1, ZERO ) ),\n\n\t\/\/ Dakhla oasis\n\tStartData( uvec4( 0x44616b68, 0x6c61206f, 0x61736973, 12 ),\n\t\t\t   ivec4( 2, 0, 0, 70 ), vec4( 25.8881, -149.4194, .0045, 150 ) ),\n\n\t\/\/ Ash island\n\tStartData( uvec4( 0x41736820, 0x69736c61, 0x6e640000, 10 ),\n\t\t\t   ivec4( 3, 72, 0, 0 ), vec4( 1, ZERO ) ),\n\n\t\/\/ Edge of the trench\n\tStartData( uvec4( 0x45646765, 0x206f6620, 0x74686520, 0xa600000d ),\n\t\t\t   ivec4( 2, 0, 0, 0 ), vec4( 3.0093, 22.9312, -7.5635, 35 ) ),\n\n\t\/\/ Towards sunrise\n\tStartData( uvec4( 0x546f7761, 0x72647320, 0x73756e72, 0x6973650f ),\n\t\t\t   ivec4( 3, 73, 0, 0 ), vec4( 1, ZERO ) ),\n\n\t\/*\n\t\/\/ The north face\n\tStartData( uvec4( 0x54686520, 0x98666163, 0x65000000, 9 ),\n\t\t\t   ivec4( 2, 0, 0, 0 ), vec4( 60.2080, 120.2213, 6.6135, 205 ) ),\n\t*\/\n\n\t\/\/ Hand gliding 2\n\tStartData( uvec4( 0x48616e67, 0x20676c69, 0x64696e67, 0x20a4320f ),\n\t\t\t   ivec4( 2, 0, 0, 0 ), vec4( 58.6771, 125.2689, 8.5348, 100 ) ),\n\n\t\/\/ Continue high orbit\n\tStartData( uvec4( 0x436f6e74, 0x696e7565, 0x20686967, 0x6820900f ),\n\t\t\t   ivec4(0), vec4(0) )\n);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE DATA\n\/\/ ----------------------------------------------------------------------------\n\nconst VehicleData[] g_vehicle_data = VehicleData[](\n\n\t\/\/ \"Super XR 7000\"\n\t\/\/ blend of 3 parts F-16 and 1 part Shuttle orbiter ...\n\tVehicleData(\n\t\tvec4( 48.27, 11.62, 5.31, 10630. ),\t\t\t\t\t\/\/ Sbcm\n\t\tvec4( 23700, 147800, 163000, 1100 ),\t\t\t\t\/\/ I\n\t\tvec4(  0.0365,\t1.8875,\t 1.0488,  0.0750 ),\t\t\t\/\/ CD\n\t\tvec4(  0.1850,\t3.8547, 23.0975,  0.4925 ),\t\t\t\/\/ CL\n\t\tvec4( -0.0028, -0.1481, -5.2071, -0.4816 ),\t\t\t\/\/ Cm\n\t\tvec4( -1.0047, -0.1717,\t 1.0391,  0.1715 ),\t\t\t\/\/ CY\n\t\tvec4(  0.1906,\t0.0597, -0.4233, -0.0826 ),\t\t\t\/\/ Cn\n\t\tvec4( -0.0642, -0.3149,\t 0.0951,  0.1378 ),\t\t\t\/\/ Cl\n\t\tvec2(  0.2500, -0.0250 ),\t\t\t\t\t\t\t\/\/ Cadot\n\t\tvec4( -0.5938, -3.0300, -0.3085, -0.0947 ),\t\t\t\/\/ C90\n\t\tvec2(  0.1786, -0.4419 ),\t\t\t\t\t\t\t\/\/ Cnside\n\t\tvec3(  0.2000, -0.3082,\t 0.0844 ),\t\t\t\t\t\/\/ misc\n\t\tvec3(  0.8700,\t0.0159,\t 0.0106 ),\t\t\t\t\t\/\/ mach\n\t\tvec2( .35, 0.2097 ),\t\t\t\t\t\t\t\t\/\/ rare\n\t\tvec4( .45, -.25, .2, .5 ),\t\t\t\t\t\t\t\/\/ greff\n\t\tmat3( 0.0350, 0.1805, 0, 0.0300, -0.0500, 0, 0.0204, 0.0075, 0 ),\n\t\t 0.0736,\n\t\tvec4( 0.45, 0.98, 1.00, 0.55 ),\n\t\tvec3( 0.4663, 0.3640, 0.5220 ),\n\t\t136000.\n\t),\n\n\t\/\/ B747\n\tVehicleData(\n\t\tvec4( 511.38, 59.67, 8.32, 162500. ),\n\t\tvec4( 14415000, 25253000, 37922000, 0 ),\n\t\tvec4(  0.0149,\t0.8377,\t 0.3350,  0.0690 ),\n\t\tvec4(  0.2195,\t4.9966,\t 7.2544,  0.3253 ),\n\t\tvec4(  0.0700, -1.1460,-22.5088, -1.2960 ),\n\t\tvec4( -0.9553,\t0.0000,\t 0.3000,  0.1477 ),\n\t\tvec4(  0.1847, -0.1181, -0.3219, -0.1077 ),\n\t\tvec4( -0.1433, -0.3828,\t 0.1742,  0.0318 ),\n\t\tvec2(  6.7242, -3.6500 ),\n\t\tvec4( -1.5000, -3.7737, -0.3189, -0.2474 ),\n\t\tvec2(  0.5267, -0.1129 ),\n\t\tvec3(  0.2000, -0.4104,\t 0.0000 ),\n\t\tvec3(  0.7200,\t0.0431,\t 0.0102 ),\n\t\tvec2( 2., 0.0931 ),\n\t\tvec4(0),\n\t\tmat3( 0.0980, 0.9750, -0.1700, 0.0240, -0.0800, -0.0100, 0.0270, 0, -0.0100 ),\n\t\t-0.1719,\n\t\tvec4( 0.15, 0.35, 1.00, 0.55 ),\n\t\tvec3( 0.3640, 0.3640, 0.4663 ),\n\t\t830000.\n\t)\n);\n\nconst int USE_VEHICLE_INDEX = 0;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MENU DATA\n\/\/ ----------------------------------------------------------------------------\n\nconst uvec4[] g_menu_data = uvec4[](\n\n\tuvec4(0),\n\tuvec4( 0x82810000, 0, 0, 0x00080602 ),\t\t\t\t\/\/ 'Command ...' -> 08\n\tuvec4( 0x4d617020, 0x81000000, 0, 0x00400605 ),\t\t\/\/ 'Map ...' -> 40\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4( 0x53757265, 0x3f000000, 0, 5 ),\t\t\t\t\/\/ 'Sure?'\n\n\t\/\/ 08 Command ...\n\tuvec4( 0x86888100, 0, 0, 0x00100803 ),\t\t\t\t\/\/ 'Info page ...' -> 10\n\tuvec4( 0x484d4420, 0x87810000, 0, 0x00180306 ),\t\t\/\/ 'HMD mode ...' -> 18\n\tuvec4( 0x8d878100, 0, 0, 0x00200303 ),\t\t\t\t\/\/ 'Aero mode ...' -> 20\n\tuvec4( 0x52435320, 0x87810000, 0, 0x00280406 ),\t\t\/\/ 'RCS mode ...' -> 28\n\tuvec4( 0x83878100, 0, 0, 0x00380403 ),\t\t\t\t\/\/ 'Engine mode ...' -> 38\n\tuvec4( 0x51756974, 0, 0, 0x00070104 ),\t\t\t\t\/\/ 'Quit' -> 07\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 10 Info page ...\n\tuvec4( 0x866f6666, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'Info off'\n\tuvec4( 0x91860000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Location info'\n\tuvec4( 0xa7860000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Waypoint info'\n\tuvec4( 0x90860000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Orbit info'\n\tuvec4( 0x476c6964, 0x65208600, 0, 7 ),\t\t\t\t\/\/ 'Glide info'\n\tuvec4( 0x84860000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Control info'\n\tuvec4( 0x41697220, 0x86000000, 0, 5 ),\t\t\t\t\/\/ 'Air info'\n\tuvec4( 0x54696d65, 0x20860000, 0, 6 ),\t\t\t\t\/\/ 'Time info'\n\n\t\/\/ 18 HMD mode ...\n\tuvec4( 0x484d4420, 0x6f666600, 0, 7 ),\t\t\t\t\/\/ 'HMD off'\n\tuvec4( 0x8fa50000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Surface overlay'\n\tuvec4( 0x90a50000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Orbit overlay'\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 20 Aero mode ...\n\tuvec4( 0x8d6f6666, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'Aero off'\n\tuvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t\/\/ 'Direct manual control'\n\tuvec4( 0x466c7920, 0x627920af, 0x84000000, 9 ),\t\t\/\/ 'Fly by wire control'\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 28 RCS mode ...\n\tuvec4( 0x52435320, 0x6f666600, 0, 7 ),\t\t\t\t\/\/ 'RCS off'\n\tuvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t\/\/ 'Direct manual control'\n\tuvec4( 0xae898400, 0, 0, 3 ),\t\t\t\t\t\t\/\/ 'Rotation rate control'\n\tuvec4( 0xae89842b, 0x204c564c, 0x48000000, 9 ),\t\t\/\/ 'Rotation rate control + LVLH'\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 30 Throttle mode ...\n\tuvec4( 0x856f6666, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'Throttle off'\n\tuvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t\/\/ 'Manual'\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 38 Engine mode ...\n\tuvec4( 0x836f6666, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'Engine off'\n\tuvec4( 0x8a830000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Drive engine'\n\tuvec4( 0x8b830000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Impulse engine'\n\tuvec4( 0x8c830000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ 'Nova engine'\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\tuvec4(0),\n\n\t\/\/ 40 Map ...\n\tuvec4( 0x50687973, 0x6963616c, 0, 8 ),\t\t\t\t\/\/ Physical\n\tuvec4( 0x456c6576, 0x6174696f, 0x6e000000, 9 ),\t\t\/\/ Elevation\n\tuvec4( 0x536c6f70, 0x65000000, 0, 5 ),\t\t\t\t\/\/ Slope\n\tuvec4( 0x45717561, 0x6c206172, 0x65610000, 10 ),\t\/\/ Equal area\n\tuvec4( 0x45717561, 0x6c20616e, 0x676c6500, 11 ),\t\/\/ Equal angle\n\tuvec4( 0x53657420, 0xa7000000, 0, 5 ),\t\t\t\t\/\/ Set waypoint\n\tuvec4(0),\n\tuvec4(0)\n);\n\nconst int MENU_HMD_BEGIN = 0x18;\nconst int MENU_HMD_SIZE = 3;\nconst int MENU_AERO_BEGIN = 0x20;\nconst int MENU_AERO_SIZE = 3;\nconst int MENU_RCS_BEGIN = 0x28;\nconst int MENU_RCS_SIZE = 4;\nconst int MENU_THR_BEGIN = 0x30;\nconst int MENU_THR_SIZE = 2;\nconst int MENU_ENG_BEGIN = 0x38;\nconst int MENU_ENG_SIZE = 4;\nconst int MENU_MMODE_BEGIN = 0x40;\nconst int MENU_MMODE_SIZE = 3;\nconst int MENU_MPROJ_BEGIN = 0x43;\nconst int MENU_MPROJ_SIZE = 2;\nconst int MENU_SET_WAYPOINT = 0x45;\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE INPUTS\n\/\/ ----------------------------------------------------------------------------\n\nconst int KEY_BACK = 8;\nconst int KEY_TAB = 9;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_ESC = 27;\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_LESS = 60;\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_Z = 90;\nconst int KEY_NUM2 = 98;\nconst int KEY_NUM4 = 100;\nconst int KEY_NUM6 = 102;\nconst int KEY_NUM8 = 104;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_F5 = 116;\nconst int KEY_F12 = 123;\nconst int KEY_ACCENT_FIREFOX = 192;\nconst int KEY_ACCENT_CHROME = 226;\nconst int KEY_META_FIREFOX = 224;\nconst int KEY_META_CHROME = 91;\n\nfloat keystate( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 0 ), 0 ).x; }\n\nfloat keypress( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 1 ), 0 ).x; }\n\nfloat keystatepress( int key )\n\t{ return max( keystate( key ), keypress( key ) ); }\n\nstruct VehicleInputs\n{\n\tfloat flapsswitch;\n\tfloat spoiltoggle;\n\tfloat gearstoggle;\n\tfloat gearbrake;\n\tfloat lightstoggle;\n\tfloat throttlecommand;\n\tvec3 joycommand;\n\tfloat trimcommand;\n\tbool trimdisplay;\n\t\/\/ vec3 rcscommand;\n\tfloat tvecswitch;\n\tfloat canopytoggle;\n\n\t\/\/ read only\n\tvec3 vjoy_copy;\n};\n\nVehicleInputs vi_read_inputs( VehicleState vs )\n{\n\tVehicleInputs result;\n\n\tfloat shift = keystate( KEY_SHIFT );\n\tfloat meta = max( keystate( KEY_CTRL ), max( keystate( KEY_META_FIREFOX ), keystate( KEY_META_CHROME ) ) );\n\tvec2 arrows = vec2( keystatepress( KEY_RIGHT ) - keystatepress( KEY_LEFT ), keystatepress( KEY_UP ) - keystatepress( KEY_DOWN ) );\n\tvec2 WASD = vec2( max( keystatepress( KEY_A ), keystatepress( KEY_Q ) ) - keystatepress( KEY_D ), max( keystatepress( KEY_W ), keystatepress( KEY_Z ) ) - keystatepress( KEY_S ) );\n\tfloat shiftmod = mix( 1., .25, shift );\n\n\tresult.flapsswitch = keypress( KEY_F ) * ( 1. - 2. * shift );\n\tresult.spoiltoggle = keypress( KEY_V );\n\tresult.gearstoggle = keypress( KEY_G );\n\tresult.gearbrake = shiftmod * max( keystate( KEY_B ), keystate( KEY_SPACE ) );\n\tresult.lightstoggle = keypress( KEY_L );\n\tresult.throttlecommand = keystate( KEY_SPACE ) > 0. ? -9999. : vs.modes.z == VS_ENG_OFF ? 0. : mix( 1., abs( vs.throttle ) < 0.1 ? .0625 : .25, shift ) * WASD.y;\n\n\tresult.joycommand = ZERO;\n\tresult.trimcommand = 0.;\n\tresult.trimdisplay = false;\n\n\tif( vs.modes2.x != VS_AERO_OFF && meta > 0. )\n\t{\n\t\tresult.trimdisplay = true;\n\t\tresult.trimcommand = mix( 1., .25, shift ) * -arrows.y;\n\t\tarrows.y = 0.;\n\t}\n\n\tresult.joycommand = shiftmod * vec3( -arrows.y, arrows.x, WASD.x );\n\tresult.tvecswitch = max( keypress( KEY_LESS ), max( keypress( KEY_ACCENT_FIREFOX ), keypress( KEY_ACCENT_CHROME ) ) ) * ( 2. * shift - 1. );\n\tresult.canopytoggle = keypress( KEY_C );\n\n\tresult.vjoy_copy = ZERO;\n\treturn result;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ FRAME CONTEXT\n\/\/ ----------------------------------------------------------------------------\n\nstruct FrameContext\n{\n\tfloat timeaccel;\n\tint subframe_count;\n\tfloat subframe_dt;\n\tfloat dt;\n};\n\nFrameContext fr_init( vec4 dtime, bool local )\n{\n\tFrameContext result;\n\tfloat dt_frame = dot( dtime, vec4( 1, 2, 2, 1 ) \/ 6. );\n\tresult.timeaccel =\n\t\tkeystate( KEY_F4 ) > 0. && !local ? 10000. :\n\t\tkeystate( KEY_F3 ) > 0. ? 1000. :\n\t\tkeystate( KEY_F2 ) > 0. ? 100. :\n\t\tkeystate( KEY_F1 ) > 0. ? 10. :\n\t\t1.;\n\tresult.subframe_count = min( VS_MAX_ITER, int( ceil( sqrt( result.timeaccel ) ) ) );\n\tresult.subframe_dt = min( local ? VS_MAX_PACE_LOCAL : VS_MAX_PACE, dt_frame * result.timeaccel \/ float( result.subframe_count ) );\n\tresult.timeaccel = result.timeaccel == 1. ? 1. : float( result.subframe_count ) * safediv( result.subframe_dt, dt_frame );\n\tresult.dt = result.subframe_dt * float( result.subframe_count );\n\treturn result;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE OBJECT\n\/\/ ----------------------------------------------------------------------------\n\nSceneObj so_init( vec4 navb, vec4 tybr )\n{\n\tSceneObj result;\n\tresult.r = nav2r( vec3( navb.xy, PD.radius + navb.z ) );\n\tresult.B = bearing2B( result.r, navb.w );\n\tresult.tybr = tybr;\n\treturn result;\n}\n\nSceneObj so_init( const SceneData data )\n{\n\tSceneObj result = so_init( data.navb, data.tybr );\n\tresult.paramsA = data.paramsA;\n\tresult.paramsB = data.paramsB;\n\treturn result;\n}\n\nSceneObj so_end()\n{\n\tSceneObj result = so_init( vec4(0), vec4( SCNOBJ_TYPE_INVALID, ZERO ) );\n\tresult.paramsA = result.paramsB = vec4(0);\n\treturn result;\n}\n\nint so_expand_to_primitives( SceneObj obj, int k, float timer, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tint type = int( obj.tybr );\n\tif( type == SCNOBJ_TYPE_TOWER )\n\t{\n\t\tobj.r -= obj.B[2] * obj.paramsB.z;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), obj.paramsB ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r += obj.B * obj.paramsB.xyz;\n\t\tobj.r -= obj.B[2] * obj.paramsA.w;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww, obj.paramsA.w, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B[2] * ( obj.paramsA.w + 0.001 );\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww + 0.001, 0.001, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B[2] * ( 0.005 );\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww + 0.002, 0.0005, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B[2] * ( 0.003 );\n\t\tfloat s = sin( timer ), c = cos( timer );\n\t\tmat3 M = mat3( c, -s, 0, s, c, 0, 0, 0, 1 );\n\t\tobj.B *= M;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.w, 0.0005, 0.0002, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t}\n\telse\n\tif( type == SCNOBJ_TYPE_LIGHTHOUSE )\n\t{\n\t\tobj.r -= obj.B[2] * obj.paramsA.w;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( -99, 10, 13, 3 ), vec4( obj.paramsB.w, obj.paramsA.w, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r += obj.B * vec3( obj.paramsB.xy, obj.paramsA.w );\n\t\tobj.r -= obj.B[2] * obj.paramsB.z;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), obj.paramsB ), ADDR_SCENE_OBJECTS + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B * vec3( obj.paramsB.xy, 2. * obj.paramsA.w );\n\t\tobj.r -= obj.B[2] * ( 0.0005 - obj.paramsB.z );\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w + 0.0005, 0.0005, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B[2] * 0.0025;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w - 0.0005, 0.0015, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t\tobj.r -= obj.B[2] * 0.0025;\n\t\tso_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w, 0.00025, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t}\n\telse\n\t{\n\t\tfloat offset =\n\t\t\ttype != SCNOBJ_TYPE_PRIMITIVE ? 0. :\n\t\t\tobj.paramsA.w == 1. ? obj.paramsB.x :\n\t\t\tobj.paramsA.w == 2. ? obj.paramsB.z :\n\t\t\tobj.paramsA.w == 3. ? obj.paramsB.y :\n\t\t\t0.;\n\n\t\tobj.r -= obj.B[2] * offset;\n\t\tso_store( obj, addr + ivec2( k, 0 ), sc, fc );\n\t\tk++;\n\t}\n\n\treturn k;\n}\n\nvoid so_dynamic_bubblesort( int index, vec3 campos, ivec2 sc, inout vec4 fc )\n{\n\tint phase = ( iFrame & 1 ) \/ 1;\n\tint indexeven = ( ( index + phase ) & ~1 ) - phase;\n\tSceneObj obj1 = so_load( iChannel0, ADDR_SCENE_DATA + ivec2( indexeven + 0, 0 ) );\n\tSceneObj obj2 = so_load( iChannel0, ADDR_SCENE_DATA + ivec2( indexeven + 1, 0 ) );\n\tfloat d1 = distance( campos, obj1.r ) * obj2.tybr.y;\n\tfloat d2 = distance( campos, obj2.r ) * obj1.tybr.y;\n\tbool inorder = int( obj1.tybr ) == SCNOBJ_TYPE_INVALID ||\n\t\t\t\t   int( obj2.tybr ) == SCNOBJ_TYPE_INVALID ||\n\t\t\t\t   d1 < d2;\n\tso_store( obj1, ADDR_SCENE_DATA + ivec2( indexeven + int( !inorder ), 0 ), sc, fc );\n\tso_store( obj2, ADDR_SCENE_DATA + ivec2( indexeven + int( inorder ), 0 ), sc, fc );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ PLANET STATE\n\/\/ ----------------------------------------------------------------------------\n\nPlanetState ps_init( PlanetData data )\n{\n\tPlanetState ps = PlanetState( ZERO, ZERO, 0., IDENTITY, ZERO, ZERO, 0., 0., 0., 0. );\n\tps.dnudt90 = safediv( TAU, data.orb_period * sqrt( abs( cube( 1. - data.orbit.e * data.orbit.e ) ) ) ) \/ 3600.;\n\tps.nu = PI - data.orbit.O - data.orbit.w;\n\tps.E = kp_nu2E( ps.nu, data.orbit.e );\n\tps.M = kp_E2M( ps.E, data.orbit.e );\n\tps.B[2] = vec3(\n\t\tcos( data.rot_northpole.x ) * cos( data.rot_northpole.y ),\n\t\tcos( data.rot_northpole.x ) * sin( data.rot_northpole.y ),\n\t\tsin( data.rot_northpole.x ) );\n\tps.B[0] = normalize( reject( -UNIT_X, ps.B[2] ) );\n\tps.B[1] = cross( ps.B[2], ps.B[0] );\n\tps.omega = safediv( TAU, data.rot_period * 3600. );\n\tkp_get_vectors( data.orbit, ps.nu, ps.dnudt90, ps.orbitr, ps.orbitv );\n\tps.r = ps.orbitr;\n\tps.v = ps.orbitv;\n\treturn ps;\n}\n\nvoid ps_pace( inout PlanetState ps, Kepler orbit, float dt )\n{\n\tps.nu += dt * ps.dnudt90 * square( 1. + orbit.e * cos( ps.nu ) );\n\tps.E = kp_nu2E( ps.nu, orbit.e );\n\tps.M = kp_E2M( ps.E, orbit.e );\n\tps.B = spin( ps.B, dt * ps.omega * ps.B[2] );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ FLIGHT DYNAMICS\n\/\/ ----------------------------------------------------------------------------\n\nfloat lift_efficiency_curve( float s, float c, vec4 config, float M )\n{\n\tfloat z = mix( config.z, config.w, M \/ ( M + 3. ) );\n\treturn mix( z, config.w, c < 0. ? 1. : clamp( safediv( abs(s) - config.x, config.y - config.x ), 0., 1. ) );\n}\n\nfloat mach_curve( float M, float CD0, vec3 machcfg )\n{\n\tfloat c = safediv( machcfg.y - machcfg.z, CD0 + machcfg.z );\n\tfloat k = safediv( c, c + 1. );\n\tfloat b = ( 1. - machcfg.x ) * k;\n\treturn M < machcfg.x ? 0. : safediv( k * square( M - machcfg.x ), ( c * square( M - machcfg.x - b ) + b * b ) );\n}\n\nfloat delta_sincos( float s, float c, float ds, float dc )\n\t{ return ds * dc * ( c * c - s * s ) - 2. * ds * ds * s * c; }\n\nvoid compute_flight_dynamics(\n\tconst VehicleData vd,\n\tconst LocalEnv env,\n\tvec3 velo,\t\t\t\/\/ incoming wind velocity vector (= 'uvw' in body axes)\n\tvec3 rates,\t\t\t\/\/ rotation rates (= 'pqr' in body axes)\n\tvec3 ctrl,\t\t\t\/\/ control inputs 0..1 (de, da, dr)\n\tvec3 fsg,\t\t\t\/\/ flaps\/spoilers\/gears\n\tvec4 gnh,\t\t\t\/\/ direction of local ground normal and ground clearance\n\tfloat wdelay,\t\t\/\/ time-lagged z component of the velo vector, must have an effective delay of c_bar\/(2u) seconds\n\tinout vec3 uvwdot,\t\/\/ = accelerations (body axes)\n\tinout vec3 pqrdot,\t\/\/ = angular accelerations (body axes)\n\tinout vec3 info )\n{\n\tvec3 XYZ = ZERO;\n\tvec3 LMN = ZERO;\n\n\tfloat S = vd.Sbcm.x;\n\tfloat V2 = dot( velo, velo );\n\tfloat QS = env.atm.z * V2 * S \/ 2.;\n\n\tif( QS >= FRACT_2_TO_M_63 )\n\t{\n\t\tfloat V = sqrt( V2 );\n\t\tfloat rcpV = 1. \/ V;\n\n\t\t\/\/ wind axes frame\n\n\t\tmat3x3 W;\n\t\tW[0] = velo * rcpV;\n\t\tW[2] = safenormalize( cross( W[0], UNIT_Y ) );\n\t\tW[1] = cross( W[2], W[0] );\n\n\t\t\/\/ common vars\n\n\t\tfloat b = vd.Sbcm.y,\t\tc_bar = vd.Sbcm.z;\n\t\tfloat u = W[0].x,\t\t\tp = sinatan( rates.x * rcpV * b \/ 2. );\n\t\tfloat v = W[0].y,\t\t\tq = sinatan( rates.y * rcpV * c_bar \/ 2. );\n\t\tfloat w = W[0].z,\t\t\tr = sinatan( rates.z * rcpV * b \/ 2. );\n\t\tfloat sin_a = -W[2].x,\t\t\tcos_a = W[2].z;\n\t\tfloat sin_b = W[0].y,\t\t\tcos_b = W[1].y;\n\t\tfloat sin_b_cos_a = -W[1].x,\tadot = w - wdelay * rcpV;\n\n\t\tvec3 sinctrl = sinatan( ctrl * vd.dx_max );\n\t\tvec3 cosctrl = cosatan( ctrl * vd.dx_max );\n\t\tfloat d_wu_de = delta_sincos( w, u, sinctrl.x, cosctrl.x );\n\t\tfloat d_wu_da = delta_sincos( w, u, sinctrl.y, cosctrl.y );\n\t\tfloat d_uv_dr = delta_sincos( sin_b_cos_a, u, sinctrl.z, cosctrl.z );\n\n\t\tfloat M = safediv( V, 1000. * env.atm.w );\n\t\tfloat eta = lift_efficiency_curve( sin_a, cos_a, vd.etaCL, M );\n\n\t\t\/\/ inputs + coeffs\n\n\t\tvec3 CD_inputs = vec3( 1, w * w, v * v );\n\t\tvec4 CL_inputs = vec4( vec3( 1, w, q ) * u, d_wu_de );\n\t\tvec4 CY_inputs = vec4( vec3( v, p, r ) * u, d_uv_dr );\n\t\tvec4 Cl_inputs = vec4( vec3( v, p, r ) * u, d_wu_da );\n\t\tvec3 C90_inputs = vec3( w, q, v ) * w * w;\n\t\tvec2 Cside_inputs = vec2( v, r ) * v * v;\n\t\tfloat Cadot_input = adot * u;\n\t\tfloat Cmi_input = square( vd.CL.y * w * u * eta ) * w;\n\n\t\tvec4 config = vec4( vd.config * fsg, vd.gearClb * fsg.z );\n\n\t\tvec3 CD_coeffs = vec3( vd.CD.x + config.x, vd.CD.yz );\n\t\tvec4 CL_coeffs = vec4( vd.CL.x + config.y, vd.CL.yzw * eta );\n\t\tvec4 Cm_coeffs = vec4( vd.Cm.x + config.z, vd.Cm.yzw * eta );\n\t\tvec4 Cl_coeffs = vec4( vd.Cl.x + config.w, vd.Cl.yzw ) * vec4( mix( 1., eta, vd.misc.z ) * u, u, u, eta * cos_a );\n\n\t\tfloat machdrag = mach_curve( M, vd.CD.x, vd.mach );\n\n\t\t\/\/ longitudinal system - drag, lift, pitching moment\n\n\t\tfloat CD = dot( CD_coeffs, CD_inputs )\t\t\t\t\t\/\/ CD0, CDa2, CDb2\n\t\t\t\t\t+ vd.mach.y * machdrag;\t\t\t\t\t\t\/\/ + wave drag effect (mach number)\n\n\t\tfloat CL = dot( CL_coeffs, CL_inputs )\t\t\t\t\t\/\/ CL0, CLa, CLq, CLde\n\t\t\t\t\t+ vd.Cadot.x * eta * Cadot_input;\t\t\t\/\/ + CLadot\n\n\t\tfloat Cm = dot( Cm_coeffs, CL_inputs ) * cos_a\t\t\t\/\/ Cm0, Cma, Cmq, Cmde\n\t\t\t\t\t+ vd.Cadot.y * eta * Cadot_input * cos_a\t\/\/ + Cmadot\n\t\t\t\t\t+ dot( vd.C90.xy, C90_inputs.xy )\t\t\t\/\/ + Cm90, Cmq90\n\t\t\t\t\t+ vd.misc.z * Cmi_input;\t\t\t\t\t\/\/ + Cmi\n\n\t\t\/\/ lateral\/directional system - side force, yawing moment, rolling moment\n\n\t\tfloat CY = dot( vd.CY, CY_inputs );\t\t\t\t\t\t\/\/ CYb, CYp, CYr, CYdr\n\n\t\tfloat Cn = dot( vd.Cn, CY_inputs ) * u\t\t\t\t\t\/\/ Cnb, Cnp, Cnr, Cndr\n\t\t\t\t\t+ dot( vd.Cside, Cside_inputs )\t\t\t\t\/\/ + Cnside, Cnpside\n\t\t\t\t\t+ vd.C90.z * C90_inputs.z;\t\t\t\t\t\/\/ + Cnb90\n\n\t\tfloat ClCn = safediv( vd.Cl.x, vd.Cn.x ) * ( 1. - vd.misc.z );\n\n\t\tfloat Cl = dot( Cl_coeffs, Cl_inputs )\t\t\t\t\t\/\/ Clb, Clp, Clr, Clda\n\t\t\t\t\t+ dot( vd.Cside, Cside_inputs ) * ClCn\t\t\/\/ + Clside, Clrside (via roll-yaw coupling)\n\t\t\t\t\t+ vd.C90.w * C90_inputs.z\t\t\t\t\t\/\/ + Clb90\n\t\t\t\t\t+ vd.misc.y * eta * u * v * w;\t\t\t\t\/\/ + Clab (wing sweep effect)\n\n\t\tvec3 CL_inputs_F = vec3( 1, w, q ) * v * cos_b;\t\t\t\/\/ CL_inputs rewritten with u exchanged for v * cos_b\n\t\tvec3 CY_inputs_F = vec3( v, p, r ) * w;\t\t\t\t\t\/\/ CY_inputs rewritten with u exchanged for w\n\n\t\tfloat CF = dot( CL_coeffs.xyz, CL_inputs_F )\t\t\t\/\/ cross lift: CF = ( CL * sin_b + CY * sin_a ) \/ cos_a\n\t\t\t\t\t+ dot( vd.CY.xyz, CY_inputs_F );\t\t\t\/\/ reformulated to eliminate division by zero\n\n\t\tfloat CQ = CY * cos_a + CF * sin_a;\t\t\t\t\t\t\/\/ combined lateral force coeff CQ = (CY + CL * sin_b) \/ cos_a\n\n\t\t\/\/ induced drag\n\n\t\tCD += vd.CD.w * square( CL - CL_coeffs.x * CL_inputs.x );\n\n\t\t\/\/ ground effect\n\n\t\tvec3 gnhw = gnh.xyz * W;\n\t#if WORKAROUND_12_TANH\n\t\tfloat greff = dot( vec3( -CD, CQ, -CL ), gnhw ) * ( 1. - tanh( clamp( gnh.w \/ ( 2. * b * vd.greff.z ), -10., 10. ) ) );\n\t#else\n\t\tfloat greff = dot( vec3( -CD, CQ, -CL ), gnhw ) * ( 1. - tanh( gnh.w \/ ( 2. * b * vd.greff.z ) ) );\n\t#endif\n\t\tCD -= greff * vd.greff.x * gnhw.x;\n\t\tCQ += greff * vd.greff.x * gnhw.y;\n\t\tCL -= greff * vd.greff.x * gnhw.z;\n\t\tCl += greff * vd.greff.y * cross( UNIT_Z, gnh.xyz ).x * c_bar \/ b;\n\t\tCm += greff * vd.greff.y * cross( UNIT_Z, gnh.xyz ).y;\n\n\t\t\/\/ rarefied flow\n\n\t\tfloat raremix = safediv( env.atm2.y, vd.rare.x + env.atm2.y );\n\t\tCD = mix( CD, length( vec3( vd.rare.y, vd.CD.y * w, vd.CD.z * v ) ), raremix );\n\t\tCQ = mix( CQ, 0., raremix );\n\t\tCL = mix( CL, 0., raremix );\n\t\tCl = mix( Cl, 0., raremix );\n\t\tCm = mix( Cm, dot( vd.C90.xy, vec2( w, q ) ), raremix );\n\t\tCn = mix( Cn, dot( vd.Cside.xy, vec2( v, r ) ), raremix );\n\n\t\t\/\/ assemble result in wind axes\n\n\t\tXYZ = QS * W * vec3( -CD, CQ, -CL );\t\t\t\t\t\/\/ = forces\n\t\tLMN = QS * vec3( Cl, Cm, Cn ) * vec3( b, c_bar, b );\t\/\/ = moments\n\n\t\tinfo.x = CL;\n\t\tinfo.y = CD;\n\t\tinfo.z = atan( sin_a, cos_a );\n\t}\n\n\t\/\/ = linear accelerations in body axes\n\n\tfloat invm = safediv( FDM_MASS_SCALE, vd.Sbcm.w );\n\tuvwdot = XYZ * invm \/* + cross( velo, rates ) *\/;\n\n\t\/\/ = angular accelerations in body, incl inertia\n\n\tLMN += ( rates.yzx * rates.zxy * ( vd.I.yzx - vd.I.zxy ) + cross( rates, vec3( rates.xz, 0 ).yzx ) * vd.I.w ) \/ FDM_MASS_SCALE;\n\tpqrdot.y = safediv( LMN.y * FDM_MASS_SCALE, vd.I.y );\n\tpqrdot.xz = ( vd.I.zw * LMN.x + vd.I.wx * LMN.z ) * safediv( FDM_MASS_SCALE, determinant( mat2( vd.I.zw, vd.I.wx ) ) );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE STATE\n\/\/ ----------------------------------------------------------------------------\n\nvoid vs_cvt_local2orbit( inout VehicleState vs, PlanetState ps )\n{\n\tvec3 localpsomega = vec3( 0, 0, ps.omega );\n\tvs.orbitr = ps.B * ( vs.localr );\n\tvs.orbitv = ps.B * ( vs.localv + cross( localpsomega, vs.localr ) );\n\tvs.B = ps.B * ( vs.localB );\n\tvs.omega = ps.B * ( vs.localomega + localpsomega );\n}\n\nvoid vs_cvt_orbit2local( inout VehicleState vs, PlanetState ps )\n{\n\tvec3 localpsomega = vec3( 0, 0, ps.omega );\n\tvs.localr = vs.orbitr * ps.B;\n\tvs.localv = vs.orbitv * ps.B - cross( localpsomega, vs.localr );\n\tvs.localB = transpose( ps.B ) * vs.B;\n\tvs.localomega = vs.omega * ps.B - localpsomega;\n}\n\nvoid vs_cvt_orbit2global( inout VehicleState vs, PlanetState ps )\n{\n\tvs.r = vs.orbitr + ps.r;\n\tvs.v = vs.orbitv + ps.v;\n}\n\nvoid vs_cvt_global2orbit( inout VehicleState vs, PlanetState ps )\n{\n\tvs.orbitr = vs.orbitr - ps.r;\n\tvs.orbitv = vs.orbitv - ps.v;\n}\n\nvoid vs_commit_local( inout VehicleState vs, PlanetState ps )\n{\n\tvs_cvt_local2orbit( vs, ps );\n\tvs_cvt_orbit2global( vs, ps );\n\tvs.localr_diff = ZERO;\n\tvs.localr_base = vs.localr;\n}\n\nvoid vs_reset_to_orbiting( inout VehicleState vs, PlanetState ps, PlanetData pd, vec4 navb, bool downfacing )\n{\n\tvs = vs_init();\n\tfloat R = navb.z + pd.radius;\n\tvs.localr = nav2r( vec3( navb.xy, R ) );\n\tvs.localB = bearing2B( vs.localr, navb.w );\n\tif( downfacing )\n\t\t{ rot90( vs.localB[1], vs.localB[0] ); rot90( vs.localB[0], vs.localB[2] ); }\n\tvs.orbitr = ps.B * vs.localr;\n\tvs.B = ps.B * vs.localB;\n\tvs.orbitv = sqrt( pd.GM \/ R ) * normalize( downfacing ? vs.B[1] : vs.B[0] );\n\tvs.omega = cross( vs.orbitr, vs.orbitv ) \/ dot( vs.orbitr, vs.orbitr );\n\tvs_cvt_orbit2local( vs, ps );\n\tvs_cvt_orbit2global( vs, ps );\n\tvs.modes = ivec3( VS_HMD_ORB, 0, VS_ENG_IMP );\n\tvs.modes2 = ivec3( 0, VS_RCS_LVLH, VS_THR_MAN );\n}\n\nvoid vs_reset_to_offroad( inout VehicleState vs, PlanetState ps, PlanetData pd, vec4 navb )\n{\n\tvs = vs_init();\n\tfloat R = navb.z + pd.radius;\n\tvs.localr = nav2r( vec3( navb.xy, R ) );\n\tvs.localB = bearing2B( vs.localr, navb.w );\n\tvs_commit_local( vs, ps );\n\tvs.FSG.z = 1.;\n\tvs.modes = ivec3( VS_HMD_SFCE, 0, VS_ENG_DRV );\n\tvs.modes2 = ivec3( VS_AERO_MAN, 0, VS_THR_MAN );\n\tvs.switches |= VS_GEARS;\n}\n\nvoid vs_reset_to_threshold( inout VehicleState vs, PlanetState ps, SceneObj runway, float sense )\n{\n\tvs = vs_init();\n\tvs.localr = runway.r - runway.B[0] * sense * ( runway.paramsB.x \/ 2. - 30. ) \/ 1000.;\n\tvs.localB[0] = runway.B[0] * sense;\n\tvs.localB[1] = cross( vs.localB[0], normalize( vs.localr ) );\n\tvs.localB[2] = cross( vs.localB[0], vs.localB[1] );\n\tvs_commit_local( vs, ps );\n\tvs.FSG.z = 1.;\n\tvs.modes = ivec3( VS_HMD_SFCE, 0, VS_ENG_IMP );\n\tvs.modes2 = ivec3( VS_AERO_MAN, 0, VS_THR_MAN );\n\tvs.switches |= VS_GEARS;\n}\n\nvoid vs_realize_startpos( inout VehicleState vs, inout GameState gs, PlanetState ps, StartData start )\n{\n#if WORKAROUND_03_SWITCH\n\tif( start.iparams.x == 1 )\n\t\tvs_reset_to_orbiting( vs, ps, PD, start.params * vec4( 1, 1, ATM_SCALE, 1 ), bool( start.iparams.y ) );\n\telse\n\tif( start.iparams.x == 2 )\n\t\tvs_reset_to_offroad( vs, ps, PD, start.params * vec4( 1, 1, TRN_SCALE, 1 ) );\n\telse\n\tif( start.iparams.x == 3 && start.iparams.y < SCENE_DATA_COUNT )\n\t\tvs_reset_to_threshold( vs, ps,\n\t\t\tso_init( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENE_DATA + SCENE_DATA_SIZE * start.iparams.y ) ) ),\n\t\t\tstart.params.x );\n#else\n\tswitch( start.iparams.x )\n\t{\n\tcase 1:\n\t\tvs_reset_to_orbiting( vs, ps, PD, start.params * vec4( 1, 1, ATM_SCALE, 1 ), bool( start.iparams.y ) );\n\t\tbreak;\n\tcase 2:\n\t\tvs_reset_to_offroad( vs, ps, PD, start.params * vec4( 1, 1, TRN_SCALE, 1 ) );\n\t\tbreak;\n\tcase 3:\n\t\tif( start.iparams.y < g_scene_data_length )\n\t\t\tvs_reset_to_threshold( vs,\n\t\t\t\tso_init( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * start.iparams.y ) ) ),\n\t\t\t\tstart.params.x );\n\t\tbreak;\n\t}\n#endif\n\n\tif( start.iparams.w > 0 && start.iparams.w < SCENE_DATA_COUNT )\n\t\tgs.waypoint = nav2r( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENE_DATA + SCENE_DATA_SIZE * start.iparams.w ) ).navb.xyz + UNIT_Z * PD.radius );\n}\n\nvoid vs_pace_switches( inout VehicleState vs, VehicleInputs vi )\n{\n\tvs.switches = ( vs.switches & ~VS_FLAPS_MASK )\n\t\t| ( uint( clamp( float( ( vs.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT ) + vi.flapsswitch, 0., 3. ) ) << VS_FLAPS_SHIFT );\n\n\tvs.switches = ( vs.switches & ~VS_TVEC_MASK )\n\t\t| ( uint( clamp( float( ( vs.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT ) + vi.tvecswitch, 0., VS_TVEC_MAX ) ) << VS_TVEC_SHIFT );\n\n\tif( vi.spoiltoggle != 0. )\n\t\tvs.switches ^= VS_SPOIL;\n\n\tif( vi.gearstoggle != 0. )\n\t\tvs.switches ^= VS_GEARS;\n\n\tif( vi.lightstoggle != 0. )\n\t\tvs.switches ^= VS_LIGHT;\n\n\tif( vi.canopytoggle != 0. )\n\t\tvs.switches ^= VS_CANOPY;\n\n\t\/*\n\tif( lensq( vs.localv ) >= 0.0004 )\n\t\tvs.switches |= VS_CANOPY;\n\t*\/\n}\n\nvoid vs_pace_FSG( inout VehicleState vs, float dt )\n{\n\tvec3 FSG_target = vec3(\n\t\tvs_flaps_notches( float( ( vs.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT ) ),\n\t\tfloat( ( vs.switches & VS_SPOIL ) == VS_SPOIL ),\n\t\tfloat( ( vs.switches & VS_GEARS ) == VS_GEARS ) );\n\tvec3 FSG_move = vec3( .125, .5, .125 );\n\tvec3 FSG_delta = dt * clamp( 8. * ( FSG_target - vs.FSG ), -FSG_move, FSG_move );\n\tvs.FSG = clamp( vs.FSG + FSG_delta, -1., 1. );\n\tfloat tvec_target = vs_tvec_notches( float( ( vs.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT ) );\n\tfloat tvec_move = 15.;\n\tfloat tvec_delta = dt * clamp( 25. * ( tvec_target - vs.tvec ), -tvec_move, tvec_move );\n\tvs.tvec = clamp( vs.tvec + tvec_delta, 0., 180. );\n}\n\nvoid vs_pace_canopy( inout VehicleState vs, float dt )\n{\n\tfloat canopy_target = float( ( vs.switches & VS_CANOPY ) == VS_CANOPY );\n\tfloat canopy_move = .25;\n\tfloat canopy_delta = dt * clamp( 8. * ( canopy_target - vs.canopy ), -canopy_move, canopy_move );\n\tvs.canopy = clamp( vs.canopy + canopy_delta, 0., 1. );\n}\n\nvoid vs_pace_throttle( inout VehicleState vs, VehicleInputs vi, float dt )\n{\n\tif( vi.throttlecommand == -9999. )\n\t\tvs.throttle = 0.;\n\telse\n\t{\n\t\tfloat modelimit = vs.modes.z == VS_ENG_IMP ? -0.15 : -1.;\n\t\tfloat tmin = ( vs.switches & VS_THROTTLE_EDGE ) == 0u ? modelimit :\n\t\t\tvs.throttle >= 0. ? 0. : modelimit;\n\t\tfloat tmax = ( vs.switches & VS_THROTTLE_EDGE ) == 0u ? 1. :\n\t\t\tvs.throttle <= .00 ? .00 :\n\t\t\tvs.throttle <= .15 ? .15 :\n\t\t\tvs.throttle <= .35 ? .35 :\n\t\t\tvs.throttle <= .70 ? .70 : 1.;\n\t\tvs.switches = ( vs.switches & ~VS_THROTTLE_EDGE ) | ( VS_THROTTLE_EDGE * uint( vi.throttlecommand != 0. && vs.thr_hold < .5 ) );\n\t\tfloat delta = .25 * dt * vi.throttlecommand;\n\t\tvs.thr_hold = vs.throttle + delta > tmax ? vs.thr_hold + 4. * ( vs.throttle + delta - tmax ) : 0.;\n\t\tvs.throttle = clamp( vs.throttle + delta, tmin, tmax );\n\t}\n}\n\nvoid vs_pace_EAR_and_trim( inout VehicleState vs, VehicleInputs vi, float dt )\n{\n\tvec3 target = ZERO;\n\tif( vs.modes2.x == VS_AERO_MAN )\n\t{\n\t\tvs.trim = clamp( vs.trim + dt * .0625 * vi.trimcommand, -1., 1. );\n\t\ttarget = vi.vjoy_copy + vs.trim * UNIT_X;\n\t}\n\telse\n\tif( vs.modes2.x == VS_AERO_FBW )\n\t\ttarget = vec3( vs.aerostuff.yw, vi.vjoy_copy.z );\n\ttarget = clamp( target, -1., 1. );\n\tvs.EAR += sign( target - vs.EAR ) * min( abs( target - vs.EAR ), 2. * dt );\n}\n\nvoid vs_pace_RCS( VehicleState vs, VehicleInputs vi, PlanetState ps, float dt,\n\t\t\t\t  inout vec3 domega, bool localphysics, bool pausemode )\n{\n\tconst float MAX_RCS_THRUST = 0.06;\t\/\/ TODO: CONFIG\n\n\tvec3 thrustercommand = ZERO;\n\tvec3 joycmd = vi.joycommand.yxz * vec3( 1, 1, -1 );\n\n\tif( vs.modes2.y == VS_RCS_MAN )\n\t\tthrustercommand = joycmd * MAX_RCS_THRUST;\n\telse\n\tif( vs.modes2.y != VS_RCS_OFF )\n\t{\n\t\tvec3 bodyomega = vs.omega * vs.B;\n\t\tvec3 targetomega = radians( 12. ) * joycmd;\n\n\t\tif( vs.modes2.y == VS_RCS_LVLH )\n\t\t{\n\t\t\tvec3 localpsomega = vec3( 0, 0, ps.omega );\n\t\t\tif( !pausemode )\n\t\t\t\ttargetomega += cross( vs.orbitr, vs.orbitv ) \/ dot( vs.orbitr, vs.orbitr ) * vs.B;\n\t\t}\n\n\t\ttargetomega = length( targetomega ) < .25 ? targetomega : normalize( targetomega );\n\t\tthrustercommand = clamp( targetomega - bodyomega, -MAX_RCS_THRUST, MAX_RCS_THRUST );\n\t}\n\n\tdomega += ( localphysics ? vs.localB : vs.B ) * ( -expm1( -2. * dt ) * thrustercommand );\n}\n\nvoid vs_pace_thrust( VehicleState vs, float dt,\n\t\t\t\t\t inout vec3 dv, bool localphysics )\n{\n\tif( vs.modes.z == VS_ENG_IMP )\n\t{\n\t\tconst float T_max = g_vehicle_data[ USE_VEHICLE_INDEX ].T_max;\n\t\tconst float mass = g_vehicle_data[ USE_VEHICLE_INDEX ].Sbcm.w \/ FDM_MASS_SCALE;\n\t\tvec2 sct = sincospi( vs.tvec \/ 180. );\n\t\tvec3 tvec = vec3( sct.y, 0, -sct.x );\n\t\tdv += 0.001 * dt * vs.throttle * T_max \/ mass * ( ( localphysics ? vs.localB : vs.B ) * tvec );\n\t}\n}\n\nvoid vs_pace_flight_dynamics( inout VehicleState vs, LocalEnv env, vec4 localterrain,\n\t\t\t\t\t\t\t  float dt, inout vec3 dv, inout vec3 domega, vec3 dr )\n{\n\tvec3 uvw = 1000. * vs.localv * vs.localB;\n\tvec3 pqr = vs.localomega * vs.localB;\n\tvec3 uvwdot = ZERO, pqrdot = ZERO;\n\tfloat invtau = 2. * length( uvw ) \/ ( g_vehicle_data[ USE_VEHICLE_INDEX ].Sbcm.z );\n\n\tvec3 N = normalize( localterrain.xyz );\n\tfloat bN = dot( vs.localr_base, N );\n\tfloat dN = dot( vs.localr_diff + dr, N );\n\tfloat tN = dot( normalize( vs.localr ), N ) * ( localterrain.w + PD.radius );\n\tfloat clearance = dN - FORCE_EVAL( tN - bN );\n\n\tcompute_flight_dynamics(\n\t\tg_vehicle_data[ USE_VEHICLE_INDEX ],\n\t\tenv,\n\t\tuvw,\n\t\tpqr,\n\t\tvec3( -vs.EAR.x, vs.EAR.yz ),\n\t\tvs.FSG,\n\t\tvec4( N * vs.localB, 1000. * clearance ),\n\t\tvs.wdelay,\n\t\tuvwdot,\n\t\tpqrdot,\n\t\tvs.info.xyz );\n\n\tvs.wdelay -= expm1( -dt * invtau ) * ( uvw.z - vs.wdelay );\n\tdv += dt * vs.localB * ( uvwdot \/* - cross( uvw, pqr ) *\/ ) \/ 1000.;\n\tdomega += dt * vs.localB * pqrdot;\n}\n\nvec3 calc_gravity_relief( vec3 r, vec3 v )\n{\n\tvec3 omega = cross( r, v ) \/ dot( r, r );\n\treturn cross( omega, cross( omega, r ) );\n}\n\nvec3 calc_gravity( vec3 r )\n{\n\tfloat r2 = dot( r, r );\n\treturn r2 < square( PD.radius ) ?\n\t\t- PD.GM \/ cube( PD.radius ) * r :\n\t\t- PD.GM \/ ( r2 * sqrt( r2 ) ) * r;\n}\n\nvoid vs_pace_fly_by_wire( inout VehicleState vs, VehicleInputs vi, LocalEnv env, float dt, vec3 gr )\n{\n\tVehicleData vd = g_vehicle_data[ USE_VEHICLE_INDEX ];\n\n\tfloat V2 = max( FRACT_1_65536, dot( vs.localv, vs.localv ) );\n\tfloat Q = max( .02, 5. * env.atm.z * V2 );\n\tfloat V = sqrt( V2 );\n\n\tfloat c = length( reject( normalize( vs.localv ), normalize( vs.localr ) ) );\n\tfloat d = length( reject( normalize( vs.localB[1] ), normalize( vs.localr ) ) );\n\tfloat g0 = length( gr ) * c \/ max( .65, d );\n\tfloat thr = -0.0005 * vs.throttle * vd.T_max \/ vd.Sbcm.w * sin( radians( vs.tvec ) );\n\tfloat cmd = ( ( vi.vjoy_copy.x < 0. ?\n\t\t ( -.003 * FDM_STD_G - g0 - thr ) :\n\t\t (\t.009 * FDM_STD_G + g0 + thr ) ) ) * abs( vi.vjoy_copy.x );\n\tvec3 uvw = vs.localv * vs.localB \/ V;\n\tvec3 pqr = vs.localomega * vs.localB * vd.Sbcm.yzy \/ ( 2000. * V );\n\tfloat adot = ( dot( gr, vs.localB[2] ) + vs.acc.z ) * vd.Sbcm.z \/ ( 2000. * V2 ) + pqr.y;\n\tfloat eta = lift_efficiency_curve( uvw.z, uvw.x, vd.etaCL, V \/ env.atm.w );\n\tvec3 config = vd.config * vs.FSG;\n\n\tconst float ki = .25;\n\tconst float kp = .2;\n\tconst float kd = 18.;\n\tfloat kr = min( 3., env.atm.z );\n\tfloat krinv = min( 1., inversesqrt( env.atm.z ) );\n\n\tvs.aerostuff.x = clamp( vs.aerostuff.x + dt * ( cmd + g0 + thr + vs.acc.z ) \/ ( krinv ), -FRACT_1_16, FRACT_1_16 );\n\n\tfloat acctgt = ( cmd + g0 + thr + ki * vs.aerostuff.x );\n\tfloat CLtgt = clamp( acctgt * vd.Sbcm.w \/ ( Q * vd.Sbcm.x * 100. ), -2., 2. );\n\tfloat CLtgt_a = ( CLtgt - vd.CL.x - config.y ) \/ eta - vd.CL.z * pqr.y + vd.CL.w * vs.EAR.x * vd.dx_max.x - .25 * vd.Cadot.x * adot;\n\tfloat atgt = clamp( CLtgt_a \/ vd.CL.y, -.5, .5 );\n\tfloat aerr = kr * ( atgt - uvw.z ) - krinv * kd * adot;\n\tfloat adottgt = clamp( kr * kp * aerr, -2., 2. );\n\tfloat qtgt = adottgt + pqr.y - adot;\n\n\tfloat Cmtgt_de = vd.Cm.x + config.z + ( vd.Cm.y * atgt + krinv * vd.Cm.z * qtgt + .25 * vd.Cadot.y * adottgt ) * eta;\n\tvs.aerostuff.y = Cmtgt_de \/ ( vd.Cm.w * vd.dx_max.x );\n\n\tfloat ptgt = 5. * vi.vjoy_copy.y * vd.Sbcm.y \/ ( 2000. * V );\n\n\tvs.aerostuff.z = clamp( vs.aerostuff.z + dt * ( ptgt - pqr.x ), -.02, .02 );\n\n\tptgt += .5 * vs.aerostuff.z;\n\n\tfloat Cltgt_da = ( vd.Cl.x + vd.gearClb * vs.FSG.z ) * uvw.y * ( 1. - vd.misc.x ) + vd.Cl.y * ptgt + vd.Cl.z * pqr.z;\n\tvs.aerostuff.w = -Cltgt_da \/ ( vd.Cl.w * vd.dx_max.y );\n}\n\nbool vs_pace_ground_interaction( VehicleState vs, VehicleInputs vi, vec4 localterrain, float dt,\n\t\t\t\t\t\t\t\t inout vec3 dv, inout vec3 domega, inout vec3 dr )\n{\n\tbool result = false;\n\tvec3 tentative_localv = vs.localv + dv;\n\tvec3 N = normalize( localterrain.xyz );\n\tfloat bN = dot( vs.localr_base, N );\n\tfloat dN = dot( vs.localr_diff + dr, N );\n\tfloat tN = dot( normalize( vs.localr ), N ) * ( localterrain.w + PD.radius );\n\tfloat gearcoord = - 0.0015 * vs.FSG.z;\n\tfloat clearance = dN - FORCE_EVAL( tN - bN ) + gearcoord;\n\tfloat dotvN = dot( tentative_localv, N );\n\tfloat error_in_r = 8. * FRACT_1_16777216 * length( vs.localr );\n\tfloat error_in_v = 8. * FRACT_1_16777216 * length( tentative_localv );\n\n\tif( dotvN < -error_in_v && clearance < error_in_r - dt * dotvN )\n\t{\n\t\tresult = true;\n\n\t\t\/\/ handle friction, drive and steering\n\t\tvec3 T = reject( vs.localB[0], N );\n\t\tif( dot( T, T ) >= FRACT_1_16777216 )\n\t\t{\n\t\t\tT = normalize(T);\n\t\t\tvec3 B = normalize( cross( T, N ) );\n\t\t\tfloat dotvT = dot( tentative_localv, T );\n\t\t\tfloat dotvB = dot( tentative_localv, B );\n\t\t\tfloat dotomegaN = dot( vs.localomega, N );\n\t\t\tfloat cT = vs.FSG.z >= .25 ? 0.90 : 0.60;\n\t\t\tconst float cB = 0.60; \/\/ TODO: config\n\t\t\tconst float comega = 600.; \/\/ TODO: config\n\t\t\tconst float cnb = 15.; \/\/ TODO: config\n\t\t\tconst float invturnradius = 140.; \/\/ TODO: config\n\t\t\tconst float maxspeed = 0.036; \/\/ TODO: config\n\n\t\t\tfloat steer = invturnradius * clamp( vs.EAR.z, -1., 1. ) * dotvT;\n\t\t\tfloat maxdvup = dt * ( dotvT < 0. ? 0.045 : min( 0.045, 0.0004 \/ abs( dotvT ) ) );\n\t\t\tfloat maxdvdn = dt * ( dotvT < 0. ? min( 0.045, 0.0004 \/ abs( dotvT ) ) : 0.045 );\n\t\t\tfloat drive =\n\t\t\t\tvs.FSG.z < .25 ? 0. :\n\t\t\t\tvs.modes.z != VS_ENG_DRV || vi.gearbrake > 0. ?\n\t\t\t\t\tsign( dotvT ) * max( 0., abs( dotvT ) - mix( 0.001 * dt, -cT * dotvN, vi.gearbrake ) ) :\n\t\t\t\t\tclamp( vs.throttle * maxspeed, ( dotvT ) - maxdvdn, ( dotvT ) + maxdvup );\n\n\t\t\t\/\/ friction works to reduce slip up to a maximum delta-v budget per frame\n\t\t\tdv -= sign( dotvT - drive ) * min( abs( dotvT - drive ), -cT * dotvN ) * T;\n\t\t\tdv -= sign( dotvB ) * min( abs( dotvB ), -cB * dotvN ) * B;\n\n\t\t\tfloat dotvB_new = dot( vs.localv + dv, B );\n\t\t\tfloat domegatarget = dotomegaN - steer + cnb * dotvB_new;\n\t\t\tdomega -= sign( domegatarget ) * min( abs( domegatarget ), -comega * dotvN ) * N;\n\t\t}\n\n\t\t\/\/ force vehicle to contact position\n\t\tfloat u = -clearance \/ dotvN;\n\t\tif( error_in_v > 0. )\n\t\t\tdr += u * tentative_localv;\n\n\t\t\/\/ eliminate normal velocity component\n\t\tdv -= dotvN * N;\n\n\t\t\/\/ advance to end of frame using new v\n\t\tdr += ( dt - u ) * ( vs.localv + dv );\n\n\t\t\/\/ add spring and damping to align upwards (wheel springs)\n\t\tfloat spring = min( 2. \/ dt, dt > 0. ? 1000. * max( 0., -dotvN \/ dt ) : 0. ); \/\/ TODO: config\n\t\tdomega -= dt * spring * cross( vs.localB[2], N );\n\t\tdomega -= dt * spring * cross( cross( N, vs.localomega ), N ) * .2;\n\t}\n\n\treturn result;\n}\n\nvoid vs_pace_beginframe( inout VehicleState vs, bool localphysics )\n{\n\tif( localphysics )\n\t{\n\t\tvec3 d = FORCE_EVAL( vs.localr - vs.localr_base );\n\t\tif( dot( d, d ) >= 1. )\n\t\t{\n\t\t\tvs.localr_diff -= d;\n\t\t\tvs.localr_base = vs.localr;\n\t\t}\n\t}\n}\n\nvoid vs_pace_halfstep( inout VehicleState vs, VehicleInputs vi,\n\t\t\t\t\t   float dt, bool localphysics, bool pausemode )\n{\n\tvs_pace_FSG( vs, dt );\n\tvs_pace_canopy( vs, dt );\n\tvs_pace_throttle( vs, vi, dt );\n\tvs_pace_EAR_and_trim( vs, vi, dt );\n\n\tif( localphysics )\n\t{\n\t\tif( !pausemode )\n\t\t{\n\t\t\tvs.localr_diff += dt * vs.localv;\n\t\t\tvs.localr = vs.localr_base + vs.localr_diff;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif( !pausemode )\n\t\t\tvs.orbitr += dt * vs.orbitv;\n\t}\n}\n\nvoid vs_pace_midframe( inout VehicleState vs, VehicleInputs vi, LocalEnv env,\n\t\t\t\t\t   TrnSampler ts, PlanetState ps, float dt, bool localphysics, bool pausemode )\n{\n\tvec3 dvsum = ZERO, grsum = ZERO;\n\tfloat dtsum = 0.;\n\tif( localphysics )\n\t{\n\t\tvec4 localterrain = ts_sample( ts, iChannel1, normalize( vs.localr ) );\n\t\tvec3 localpsomega = vec3( 0, 0, ps.omega );\n\t\tvec3 gr_static = calc_gravity( vs.localr );\n\t\tvec3 gr_centrifugal = cross( localpsomega, cross( localpsomega, vs.localr ) );\n\t\tfloat min_dt = inversesqrt( 1. + 250. * env.atm.z * ( 1. + env.atm.z * dot( vs.localv, vs.localv ) ) );\n\t\tint n = clamp( int( ceil( dt \/ min_dt ) ), FDM_MIN_ITER, FDM_MAX_ITER );\n\t\tfloat dt_inner = dt \/ float(n);\n\t\tvec3 dr = ZERO;\n\t\tmat3x3 localB = vs.localB;\n\n\t\tfor( int i = 0; i < n; ++i )\n\t\t{\n\t\t\tvec3 gr_coriolis = 2. * cross( localpsomega, vs.localv );\n\t\t\tvec3 gr = gr_static - gr_centrifugal - gr_coriolis;\n\t\t\tif( pausemode )\n\t\t\t\tgr -= calc_gravity_relief( vs.localr, vs.localv );\n\t\t\tvec3 dv = dt_inner * gr;\n\t\t\tvec3 domega = ZERO;\n\n\t\t\tvs_pace_RCS( vs, vi, ps, dt_inner, domega, true, pausemode );\n\t\t\tvs_pace_thrust( vs, dt_inner, dv, true );\n\t\t\tvs_pace_flight_dynamics( vs, env, localterrain, dt_inner, dv, domega, dr );\n\t\t\tif( vs_pace_ground_interaction( vs, vi, localterrain, dt_inner, dv, domega, dr ) )\n\t\t\t\tvs.info.w = 1.;\n\n\t\t\tfloat limit = min(\n\t\t\t\tlensq( dv ) == 0. ? 1. : min( 1., sqrt( ( FRACT_1_16 + lensq( vs.localv ) ) \/ ( 16. * lensq( dv ) ) ) ),\n\t\t\t\tlensq( domega ) == 0. ? 1. : min( 1., sqrt( ( FRACT_1_16 + lensq( vs.localomega ) ) \/ ( 16. * lensq( domega ) ) ) ) );\n\n\t\t\tif( 2 * n < FDM_MAX_ITER + i && limit < 1. )\n\t\t\t{\n\t\t\t\tn += n - i;\n\t\t\t\tdt_inner \/= 2.;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgrsum += dt_inner * gr;\n\t\t\tdtsum += dt_inner;\n\t\t\tdvsum += dv * limit - dt_inner * gr;\n\t\t\tvs.localv += dv * limit;\n\t\t\tvs.localomega += domega * limit;\n\t\t\tvs.localB = spin( vs.localB, dt_inner * vs.localomega );\n\t\t}\n\n\t\tif( dot( dr, dr ) > 0. )\n\t\t{\n\t\t\tvs.localr_diff += dr - dt * vs.localv;\n\t\t\tvs.localr += vs.localr_base + vs.localr_diff;\n\t\t}\n\n\t\tif( vs.modes2.x == VS_AERO_FBW )\n\t\tvs_pace_fly_by_wire( vs, vi, env, dtsum, safediv( grsum, dtsum ) );\n\t}\n\telse\n\t{\n\t\tvec3 gr = calc_gravity( vs.orbitr );\n\t\tif( pausemode )\n\t\t\tgr -= calc_gravity_relief( vs.orbitr, vs.orbitv );\n\t\tvec3 dv = ZERO;\n\t\tvec3 domega = ZERO;\n\t\tvs_pace_RCS( vs, vi, ps, dt, domega, false, pausemode );\n\t\tvs_pace_thrust( vs, dt, dv, false );\n\t\tvs.orbitv += ( dvsum = dv ) + ( dtsum = dt ) * ( grsum = gr );\n\t\tvs.omega += domega;\n\t\tvs.B = spin( vs.B, dt * vs.omega );\n\t}\n\n\tvs.acc = safediv( dvsum, dtsum ) * ( localphysics ? vs.localB : vs.B );\n}\n\nvoid vs_pace_endframe( inout VehicleState vs, PlanetState ps, float dt, bool localphysics )\n{\n\tif( localphysics )\n\t{\n\t\tvs.localr = vs.localr_base + vs.localr_diff;\n\t\tvs_cvt_local2orbit( vs, ps );\n\t}\n\telse\n\t{\n\t\tvs_cvt_orbit2local( vs, ps );\n\t\tvs.localr_diff = ZERO;\n\t\tvs.localr_base = vs.localr;\n\t}\n\tvs_cvt_orbit2global( vs, ps );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MESSAGE QUEUE\n\/\/ ----------------------------------------------------------------------------\n\nvoid msg_push( inout MsgQueue msg, uvec4 phrase, vec4 argv )\n{\n\tif( msg.state.x < float( TXT_MSG_MAX_PHRASES - 2 ) )\n\t{\n\t\tif( msg.state.x < 0. )\n\t\t\tmsg.state.x++;\n\t\tmsg.state.x++;\n\t\tif( int( ceil( msg.state.x ) ) == g_msgindex )\n\t\t{\n\t\t\tmsg.phrase = phrase;\n\t\t\tmsg.argv = argv;\n\t\t}\n\t}\n}\n\nvoid msg_push_if_empty( inout MsgQueue msg, uvec4 phrase, vec4 argv )\n{\n\tif( msg_empty( msg ) )\n\t\tmsg_push( msg, phrase, argv );\n}\n\nvoid msg_store( MsgQueue self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.state, addr, 0, sc, fc );\n\tif( g_msgindex >= 0 && g_msgindex < TXT_MSG_MAX_PHRASES )\n\t{\n\t\tmemstore( pack_uvec4( self.phrase ), addr, g_msgindex + 1, sc, fc );\n\t\tmemstore( self.argv, addr, g_msgindex + 1 + TXT_MSG_MAX_PHRASES, sc, fc );\n\t}\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MENU\n\/\/ ----------------------------------------------------------------------------\n\nvoid check_menu_item( int i, int p )\n{\n\tif( keypress( KEY_1 + i ) == 1. )\n\t{\n\t\tint curr = p + i;\n\t\tint next = int( md_load( iChannel0, p + i ).w >> 8 ) & 0xff;\n\t\tGS.menustate.x = next == 0 ? 0 : curr;\n\t\tGS.menustate.y = next == 0 ? curr : 0;\n\t\tGS.menustate.z = GS.menustate.y;\n\t}\n}\n\nvoid process_menu()\n{\n\tGS.menustate.y = 0;\n\tif( GS.menustate.x > 0 )\n\t{\n\t\tuvec4 currmenu = md_load( iChannel0, GS.menustate.x );\n\t\tint n = int( currmenu.w >> 8 ) & 0xff;\n\t\tint p = int( currmenu.w >> 16 ) & 0xff;\n\t#if WORKAROUND_02_FOR_IF\n\t\tfor( int i = 0, n = 8; i < n; ++i )\n\t\t\tif( i < n )\n\t\t\t\tcheck_menu_item( i, p );\n\t#else\n\t\tfor( int i = 0; i < n; ++i )\n\t\t\tcheck_menu_item( i, p );\n\t#endif\n\t}\n}\n\nvoid respond_to_menu( inout MsgQueue msg )\n{\n\tif( GS.menustate.y >= MENU_INFO_BEGIN && GS.menustate.y < MENU_INFO_BEGIN + MENU_INFO_SIZE )\n\t\tGS.switches = ( GS.switches & ~GS_IPAGE_MASK ) | ( uint( GS.menustate.y - MENU_INFO_BEGIN ) << GS_IPAGE_SHIFT );\n\telse\n\tif( GS.menustate.y >= MENU_HMD_BEGIN && GS.menustate.y < MENU_HMD_BEGIN + MENU_HMD_SIZE )\n\t\tVS.modes.x = GS.menustate.y - MENU_HMD_BEGIN;\n\telse\n\tif( GS.menustate.y >= MENU_ENG_BEGIN && GS.menustate.y < MENU_ENG_BEGIN + MENU_ENG_SIZE )\n\t{\n\t\tif( GS.menustate.y - MENU_ENG_BEGIN == int( VS_ENG_NOVA ) )\n\t\t\tmsg_push_if_empty( msg, uvec4( 0x8c836e6f, 0x7420a900, 0, 7 ), vec4(0) );\n\t\telse\n\t\t\tVS.modes.z = GS.menustate.y - MENU_ENG_BEGIN, VS.throttle = 0.;\n\t}\n\telse\n\tif( GS.menustate.y >= MENU_THR_BEGIN && GS.menustate.y < MENU_THR_BEGIN + MENU_THR_SIZE )\n\t\tVS.modes2.z = GS.menustate.y - MENU_THR_BEGIN;\n\telse\n\tif( GS.menustate.y >= MENU_AERO_BEGIN && GS.menustate.y < MENU_AERO_BEGIN + MENU_AERO_SIZE )\n\t{\n\t\tint newmode = GS.menustate.y - MENU_AERO_BEGIN;\n\t\tif( VS.modes2.x < VS_AERO_FBW && newmode >= VS_AERO_FBW )\n\t\t\tVS.trim = 0.;\n\t\tif( VS.modes2.x >= VS_AERO_FBW && newmode < VS_AERO_FBW )\n\t\t\tVS.trim = VS.EAR.x, VS.aerostuff = vec4(0);\n\t\tVS.modes2.x = newmode;\n\t}\n\telse\n\tif( GS.menustate.y >= MENU_RCS_BEGIN && GS.menustate.y < MENU_RCS_BEGIN + MENU_RCS_SIZE )\n\t\tVS.modes2.y = GS.menustate.y - MENU_RCS_BEGIN;\n\telse\n\tif( GS.menustate.y >= MENU_MMODE_BEGIN && GS.menustate.y < MENU_MMODE_BEGIN + MENU_MMODE_SIZE )\n\t\tGS.switches = ( GS.switches & ~GS_MMODE_MASK ) | ( uint( GS.menustate.y - MENU_MMODE_BEGIN ) << GS_MMODE_SHIFT );\n\telse\n\tif( GS.menustate.y >= MENU_MPROJ_BEGIN && GS.menustate.y < MENU_MPROJ_BEGIN + MENU_MPROJ_SIZE )\n\t\tGS.switches = ( GS.switches & ~GS_MPROJ_MASK ) | ( uint( GS.menustate.y - MENU_MPROJ_BEGIN ) << GS_MPROJ_SHIFT );\n\telse\n\tif( GS.menustate.y == MENU_SET_WAYPOINT )\n\t\tGS.waypoint = GS.mapmarker, GS.mapmarker = ZERO;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ACHIEVEMENT DETECTOR\n\/\/ ----------------------------------------------------------------------------\n\nvoid ad_pace( inout AchievementDetector ad, inout MsgQueue msg, VehicleState vs,\n\t\t\t  vec4 localterrain, float dt )\n{\n\tbool contact = bool( vs.info.w );\n\tswitch( ad.LT_state )\n\t{\n\tcase AD_LT_INIT:\n\t\tad.LT_state = contact ? AD_LT_LANDED : AD_LT_AIRBORNE;\n\t\tad.LT_timer = 0.;\n\t\tad.LT_localv = ZERO;\n\t\tbreak;\n\tcase AD_LT_LANDED:\n\t\tif( !contact )\n\t\t{\n\t\t\tad.LT_timer -= dt;\n\t\t\tif( ad.LT_timer < -2. )\n\t\t\t{\n\t\t\t\tad.LT_state = AD_LT_AIRBORNE;\n\t\t\t\tad.LT_timer = 0.;\n\t\t\t\tad.LT_localv = vs.localv;\n\t\t\t\tmsg_push_if_empty( msg, uvec4( 0x41697262, 0x6f726e65, 0, 8 ), vec4(0) );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tad.LT_timer = 0.;\n\t\tbreak;\n\tcase AD_LT_AIRBORNE:\n\t\tad.LT_timer -= dt;\n\t\tif( ad.LT_timer < -5. && contact )\n\t\t{\n\t\t\tvec3 N = localterrain.xyz;\n\t\t\tvec3 T = normalize( reject( vs.localB[0], N ) );\n\t\t\tvec3 B = normalize( reject( vs.localB[1], N ) );\n\t\t\tad.LT_localv = 1000. * ad.LT_localv * mat3( T, B, -N );\n\t\t\tif( abs( ad.LT_localv.x ) < 250. &&\n\t\t\t\tabs( ad.LT_localv.y ) < 10. &&\n\t\t\t\tad.LT_localv.z < 6. &&\n\t\t\t\tdot( vs.localB[0], N ) < .342 &&\n\t\t\t\tdot( vs.localB[0], N ) >= -.087 &&\n\t\t\t\tabs( dot( vs.localB[1], N ) ) < .342 )\n\t\t\t{\n\t\t\t\tad.LT_state = vs.FSG.z >= FRACT_63_64 ? AD_LT_TOUCHDOWN : AD_LT_BELLYDOWN;\n\t\t\t\tad.LT_timer = 0.;\n\t\t\t\tmsg_push( msg, uvec4( 0xaa000000, 0, 0, 1 ), vec4(0) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tad.LT_state = AD_LT_CRASH;\n\t\t\t\tad.LT_timer = 0.;\n\t\t\t\tmsg_push( msg, uvec4( 0x43726173, 0x68000000, 0, 5 ), vec4(0) );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tad.LT_localv = vs.localv;\n\t\tbreak;\n\tcase AD_LT_TOUCHDOWN:\n\tcase AD_LT_BELLYDOWN:\n\t\tif( contact )\n\t\t{\n\t\t\tad.LT_timer += dt;\n\t\t\tif( ad.LT_timer >= 5. )\n\t\t\t{\n\t\t\t\tbool wasempty = msg_empty( msg );\n\t\t\t\tmsg_push( msg, ad.LT_state == AD_LT_TOUCHDOWN ?\n\t\t\t\t\t\t\t\tuvec4( 0xab6c616e, 0x64696e67, 0, 8 ) :\n\t\t\t\t\t\t\t\tuvec4( 0x42656c6c, 0x79206c61, 0x6e64696e, 0x6700000d ),\n\t\t\t\t\t\t  vec4(0) );\n\t\t\t\tif( wasempty )\n\t\t\t\t{\n\t\t\t\t\tmsg_push( msg, uvec4( 0xaa737065, 0x656420f7, 0, 8 ), vec4( ad.LT_localv.x, ZERO ) );\n\t\t\t\t\tmsg_push( msg, uvec4( 0x44657363, 0x656e7420, 0x72617465, 0x20f6000e ), vec4( ad.LT_localv.z, ZERO ) );\n\t\t\t\t\tif( ad.LT_localv.z >= 4. )\n\t\t\t\t\t\tmsg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20686172, 0x6400000d ), vec4(0) );\n\t\t\t\t\telse\n\t\t\t\t\tif( ad.LT_localv.x >= 80. )\n\t\t\t\t\t\tmsg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20666173, 0x7400000d ), vec4(0) );\n\t\t\t\t\telse\n\t\t\t\t\tif( ad.LT_localv.z < 2. )\n\t\t\t\t\t\tmsg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20ac0000, 10 ), vec4(0) );\n\t\t\t\t}\n\t\t\t\tad.LT_state = AD_LT_LANDED;\n\t\t\t\tad.LT_timer = 0.;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tad.LT_timer -= dt;\n\t\t\tif( ad.LT_timer < 0. )\n\t\t\t{\n\t\t\t\tad.LT_state = AD_LT_AIRBORNE;\n\t\t\t\tad.LT_timer = 0.;\n\t\t\t\tad.LT_localv = vs.localv;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AD_LT_CRASH:\n\t\tad.LT_timer += dt;\n\t\tif( ad.LT_timer >= 5. )\n\t\t\tad.LT_state = AD_LT_INIT;\n\t\tbreak;\n\t}\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAP MODE\n\/\/ ----------------------------------------------------------------------------\n\nvoid enter_map_mode()\n{\n\tGS.switches |= GS_TRMAP;\n\tGS.switches &= ~GS_IRCAM;\n\tGS.mouselook = vec3(\n\t\tnormalize( -GS.campos.xy ),\n\t\tatan( -GS.campos.z, length( GS.campos.xy ) ) );\n\tGS.camzoom = 16.;\n\tGS.mapmarker = ZERO;\n}\n\nvoid leave_map_mode()\n{\n\tGS.switches &= ~GS_TRMAP;\n\tGS.mouselook = UNIT_X;\n\tGS.camzoom = 1.;\n}\n\nvoid process_map_mode()\n{\n\tif( keypress( KEY_TAB ) == 1. )\n\t\tGS.menustate.x = GS.menustate.x != 0 ? 0 : MENU_MAP;\n\n\tfloat zoomspeed = max( keystatepress( KEY_W ), keystatepress( KEY_Z ) ) -\n\t\t\t\t\t\t   keystatepress( KEY_S );\n\tzoomspeed *= ( keystate( KEY_SHIFT ) > 0. ? .25 : 1. );\n\tGS.camzoom = clamp( GS.camzoom * exp2pp( dot( DT, vec4( 1, 2, 2, 1 ) \/ 6. ) * zoomspeed ), 0.5, 6826.66667 * TRN_SCALE );\n\n\tif( iMouse.z < 0. && GS.dragstate.xy == -iMouse.zw )\n\t{\n\t\tvec4 marker = gs_map_unproject( GS, iMouse.xy + .5, iResolution.xy );\n\t\tif( abs( marker.w ) < 1. )\n\t\t{\n\t\t\tmarker *= ( PD.radius + texelFetch( iChannel1, ivec2( iMouse.xy ), 0 ).w );\n\t\t\tif( marker.xyz == GS.mapmarker )\n\t\t\t\tGS.mapmarker = ZERO;\n\t\t\telse\n\t\t\t\tGS.mapmarker = marker.xyz;\n\t\t}\n\t\tGS.dragstate.xy = vec2(0);\n\t}\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ CAMERA\n\/\/ ----------------------------------------------------------------------------\n\nvoid mouselook()\n{\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t{\n\t\tconst mat2x2 R = mat2x2( 1, -1, 1, 1 ) * SQRTHALF;\n\t\tfloat C = dot( normalize( VS.localr ), VS.localB[2] );\n\t\tfloat S = dot( normalize( VS.localr ), VS.localB[1] );\n\n\t\tif( keypress( KEY_BACK ) == 1. )\n\t\t\tGS.mouselook = UNIT_X, GS.camzoom = 1.;\n\t\telse\n\t\tif( keypress( KEY_NUM8 ) == 1. )\n\t\t\tGS.mouselook = UNIT_X;\n\t\telse\n\t\tif( keypress( KEY_NUM2 ) == 1. )\n\t\t\tGS.mouselook = -UNIT_X;\n\t\telse\n\t\tif( keypress( KEY_NUM4 ) == 1. )\n\t\t\tGS.mouselook.xy = R * GS.mouselook.xy, GS.mouselook.z = -.5 * GS.mouselook.y * C * S;\n\t\telse\n\t\tif( keypress( KEY_NUM6 ) == 1. )\n\t\t\tGS.mouselook.xy = GS.mouselook.xy * R, GS.mouselook.z = -.5 * GS.mouselook.y * C * S;\n\t}\n\telse\n\tif( keypress( KEY_BACK ) == 1. )\n\t\tenter_map_mode();\n\n\tif( iMouse.z > 0. )\n\t{\n\t\tfloat zoomres = GS.camzoom * CAM_FOCUS * iResolution.y;\n\t\tvec2 dragdelta = 2. * ( iMouse.xy - GS.dragstate ) \/ zoomres;\n\t\tGS.dragstate = iMouse.xy;\n\t\tfloat l = PI \/ 2. - 0.001 \/ GS.camzoom;\n\t\tfloat q = cos( GS.mouselook.z ) + 0.25 \/ GS.camzoom;\n\t\tvec2 sc = sincospi( dragdelta.x \/ ( q * PI ) );\n\t\tGS.mouselook.xy = normalize( GS.mouselook.xy * mat2( sc.yx, -sc.x, sc.y ) );\n\t\tGS.mouselook.z = clamp( GS.mouselook.z + dragdelta.y, -l, l );\n\t}\n}\n\nvoid update_camera()\n{\n\tvec2 sc = sincospi( GS.mouselook.z \/ PI );\n\tvec3 forward = vec3( GS.mouselook.xy * sc.y, sc.x );\n\tvec3 right = normalize( cross( UNIT_Z, forward ) );\n\tvec3 down = cross( forward, right );\n\tGS.camframe = mat3( forward, right, down );\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t{\n\t\tif( keypress( KEY_R ) == 1. )\n\t\t\tif( keystate( KEY_SHIFT ) == 1. )\n\t\t\t\tGS.camzoom = GS.camzoom > 3. ? 3. : 1.;\n\t\t\telse\n\t\t\t\tGS.camzoom = GS.camzoom < 3. ? 3. : 8.;\n\t\tGS.campos_diff = VS.localB * vec3( .001, 0, -.0015 );\n\t\tGS.campos = VS.localr + GS.campos_diff;\n\t\tGS.camframe = VS.localB * GS.camframe;\n\t}\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ GAME UPDATE\n\/\/ ----------------------------------------------------------------------------\n\nbool pace_camera_transition( float dt )\n{\n\tfloat u = -expm1( -1.00 * dt * min( 1., .5 * GS.timer ) );\n\tfloat v = -expm1( -1.50 * dt * min( 1., .5 * GS.timer ) );\n\tvec3 a = normalize( mix( GS.camframe[0], normalize( VS.localr - GS.campos ), v ) );\n\tvec3 b = normalize( mix( normalize( GS.camframe[1] - a * dot( GS.camframe[1], a ) ),\n\t\t\t\t\t\t\t normalize( VS.localB[1] - a * dot( VS.localB[1], a ) ), v ) );\n\tvec3 target = VS.localr - 0.03 * VS.localB[0];\n\tfloat alt = mix( length( GS.campos ), length( target ) + .150 * length( target - GS.campos ), u );\n\tGS.campos = normalize( mix( GS.campos, target, u ) ) * alt;\n\tGS.camframe = mat3( a, b, cross( a, b ) );\n\treturn dot( normalize( VS.localr - GS.campos ), VS.localB[0] ) >= FRACT_15_16;\n\t\/\/ return distance( GS.campos, VS.localr ) < ( length( target ) - PD.radius < 25. ? 0.0305 : 0.3 );\n}\n\nvoid pace_hud_brightness( float dt )\n{\n\tif( GS.exposure.x > 0. )\n\t{\n\t\tuint hudbright = ( GS.switches & GS_HMD_BRIGHT_MASK ) >> GS_HMD_BRIGHT_SHIFT;\n\t\tGS.hudbright += -expm1( -4. * dt ) * ( exp2pp( 2. * float( hudbright ) - 6. ) * sqrt( GS.exposure.x + 0.00005 ) - GS.hudbright );\n\t}\n}\n\nvoid pace_first_person_mode( float dt )\n{\n\tif( keypress( KEY_T ) == 1. )\n\t\tGS.switches ^= GS_TRDAR;\n\n\tif( keypress( KEY_I ) == 1. )\n\t{\n\t\tGS.switches ^= GS_IRCAM;\n\t\t\/*\n\t\tif( ( gs.switches & GS_IRCAM ) != 0u )\n\t\t\tgs.switches &= ~GS_NVISN;\n\t\t*\/\n\t}\n\n\tif( keypress( KEY_N ) == 1. )\n\t{\n\t\tGS.switches ^= GS_NVISN;\n\t\t\/*\n\t\tif( ( gs.switches & GS_NVISN ) != 0u )\n\t\t\tgs.switches &= ~GS_IRCAM;\n\t\t*\/\n\t}\n\n\tif( keypress( KEY_P ) == 1. )\n\t\tGS.switches ^= GS_PAUSE;\n\n\tif( keypress( KEY_TAB ) == 1. )\n\t\tGS.menustate.x = GS.menustate.x != 0 ? 0 : MENU_COMMAND;\n\n\tint hudbright = int( ( GS.switches & GS_HMD_BRIGHT_MASK ) >> GS_HMD_BRIGHT_SHIFT );\n\tif( keypress( KEY_H ) == 1. )\n\t\thudbright = clamp( hudbright + ( keystate( KEY_SHIFT ) == 1. ? -1 : 1 ), 0, 3 );\n\tGS.switches = ( GS.switches & ~GS_HMD_BRIGHT_MASK ) | ( uint( hudbright ) << GS_HMD_BRIGHT_SHIFT );\n}\n\nvoid pace_running_state( float dt )\n{\n\tif( abs( iMouse.x - iMouse.z ) < 6. &&\n\t\tabs( iMouse.y - iMouse.w ) < 6. && iMouse.z > 0. )\n\t{\n\t\tGS.dragstate = iMouse.xy;\n\t}\n\n\tif( keypress( KEY_M ) == 1. )\n\t\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t\t\tenter_map_mode();\n\t\telse\n\t\t\tleave_map_mode();\n\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t\tpace_first_person_mode( dt );\n\telse\n\t\tprocess_map_mode();\n\n\tprocess_menu();\n\tif( GS.menustate.y == MENU_QUIT )\n\t\tGS = gs_init();\n}\n\nvoid pace_exposure( float dt )\n{\n\tif( GS.stage != GS_INIT )\n\t{\n\t\tvec4 sum = vec4(0);\n\n\t\tfor( int i = 0; i < 8; ++i )\n\t\t\tfor( int j = 0; j < 8; ++j )\n\t\t\t\tsum += texelFetch( iChannel0, ADDR_EXPOSURE.yx + ivec2( i, j ), 0 );\n\n\t\tfloat mu = safediv( sum.x, sum.z );\n\t\tfloat sigma = sqrt( max( 0., safediv( sum.y, sum.z ) - mu * mu ) );\n\t\tfloat sigmaswitch = mu \/ ( .0625 + mu );\n\t\tfloat level = max( mu, mix( -1., 1., sigmaswitch ) * sigma );\n\n\t  #if WITH_ILLUM_TEST\n\t\tGS.exposure.x -= expm1( -dt * ( GS.exposure.x < level ? 4. : 2. ) ) * ( level - GS.exposure.x );\n\t\tGS.exposure.y = 0.;\n\t  #else\n\t\tGS.exposure.x -= expm1( -dt * ( GS.exposure.x < level ? 4. : 2. ) ) * ( level - GS.exposure.x );\n\t\tGS.exposure.y -= expm1( -dt * ( GS.exposure.y < level ? 1. : .5 ) ) * ( level - GS.exposure.y );\n\t  #endif\n\t}\n\telse\n\t\tGS.exposure = vec2(1);\n}\n\nvoid pace_vjoy( inout VehicleInputs vi, float urgency, float dt )\n{\n\t\/\/ TODO: config\n\tconst float RISE = .25;\n\tconst float HOLD = .0625;\n\tconst float FALL = .5;\n\tconst float SWITCH = 2.;\n\tvec3 sc = sign( vi.joycommand );\n\tvec3 ac = abs( vi.joycommand );\n\tvec3 asc = abs( sc );\n\tvec3 speed = urgency * mix( mix( vec3( HOLD ), vec3( FALL ), step( .5, GS.vjoy_hold ) ), vec3( RISE ) * ac, asc );\n\tfloat speedsw = urgency * SWITCH;\n\tvec3 ds = max( ZERO, -sc * GS.vjoy );\n\tvec3 dtsw = min( vec3( dt ), ds \/ speedsw );\n\tGS.vjoy += sign( sc - GS.vjoy ) * min( abs( sc - GS.vjoy ), ( dt - dtsw ) * speed + dtsw * speedsw );\n\tGS.vjoy_hold = ( GS.vjoy_hold + dt ) * ( 1. - asc );\n\tvi.vjoy_copy = GS.vjoy;\n}\n\nvoid pace_game(\n\tinout FrameContext fr,\n\tinout VehicleInputs vi,\n\tinout MsgQueue msg,\n\tinout LocalEnv le,\n\tbool irmode,\n\tbool resolutionchange )\n{\n\tint localplanetindex = 1;\n\n\tPlanetState ps;\n\tif( GS.stage == GS_INIT )\n\t\tps = ps_init( PD );\n\telse\n\t\tps = ps_load( iChannel0, ps_addr( localplanetindex ) );\n\tif( GS.stage != GS_TRANSITION )\n\t\tif( ts_is_valid( TS ) )\n\t\t\tps_pace( ps, PD.orbit, fr.dt );\n\tif( GS.stage == GS_INIT )\n\t{\n\t\tle = le_init();\n\t\tVS.r = ps.r;\n\t}\n\telse\n\t\tle = le_load( iChannel0, ADDR_LOCAL_ENV );\n\n\tle.L = normalize( -VS.r * ps.B );\n\tle.sunlight = irselect( COL_SUNLIGHT, irmode ) * square( kp_semimajor( g_planet_data[1].orbit ) ) \/ dot( VS.r, VS.r );\n\tle.sundisk = square( g_planet_data[0].radius ) \/ dot( VS.r, VS.r );\n\tle.starlight = irselect( COL_STARLIGHT, irmode );\n\tle.radius = PD.radius;\n\n\tif( resolutionchange )\n\t\tTS = ts_init();\n\n\tuint lastswitches = GS.switches;\n\tvec4 rn = length_normalize( VS.localr );\n\n\tswitch( GS.stage )\n\t{\n\tcase GS_INIT:\n\t\tvs_realize_startpos( VS, GS, ps, g_start_data[0] );\n\t\tVS.modes = ivec3(0);\n\t\tVS.modes2 = ivec3(0);\n\t\tTS = ts_init();\n\t\tmsg_push( msg, uvec4( 0x949cf220, 0x9d9e0000, 0, 6 ), vec4( 2020, ZERO ) );\n\t\tmsg_push( msg, uvec4( 0x939f9100, 0, 0, 3 ), vec4(0) );\n\t\tGS.stage = GS_SELECT_LOCATION;\n\t\tGS.timer = 0.;\n\t\tGS.datetime.y = 14.;\n\t\t\/\/ fallthrough\n\n\tcase GS_SELECT_LOCATION:\n\t\tGS.timer += fr.dt;\n\t\tint selected = 0;\n\t\tfor( int i = 1, n = START_DATA_COUNT; i < n; ++i )\n\t\t{\n\t\t#if WORKAROUND_07_KEYPRESS\n\t\t\tif( keypress( KEY_A - 1 + i ) == 1. )\n\t\t#else\n\t\t\tif( keypress( KEY_A + i - 1 ) == 1. )\n\t\t#endif\n\t\t\t\tselected = i;\n\t\t}\n\t\tif( selected > 0 )\n\t\t{\n\t\t\tStartData start = st_load( iChannel0, ADDR_START_DATA + ivec2( selected, 0 ) );\n\t\t\tvs_realize_startpos( VS, GS, ps, start );\n\t\t\tif( dot( VS.localr, le.L ) < 0. || length( VS.orbitr ) < PD.radius - 0.03 )\n\t\t\t\tVS.switches |= VS_LIGHT;\n\t\t\tmsg_push( msg, uvec4( 0xa0746f20, 0x2e2e2e00, 0, 7 ), vec4(0) );\n\t\t\tmsg_push( msg, start.name, vec4(0) );\n\t\t\tGS.stage = GS_TRANSITION;\n\t\t\tGS.timer = 0.;\n\t\t}\n\t\tbreak;\n\n\tcase GS_TRANSITION:\n\t\tGS.timer += fr.dt;\n\t\tbool high = length( GS.campos ) >= PD.radius * ( 1. + PD.trn.levels.y );\n\t\tif( !high && ts_is_valid( TS ) && ts_is_uv_safe( TS, rn.xyz ) )\n\t\t{\n\t\t\tVS.localr = rn.xyz * ( ts_sample( TS, iChannel1, rn.xyz ).w + 0.0015 + PD.radius );\n\t\t\tvs_commit_local( VS, ps );\n\t\t}\n\t\tif( pace_camera_transition( fr.dt ) )\n\t\t{\n\t\t\tGS.stage = GS_RUNNING;\n\t\t\tGS.mouselook = UNIT_X;\n\t\t}\n\t\tbreak;\n\n\tcase GS_RUNNING:\n\t\tGS.timer += fr.dt;\n\t\tpace_running_state( fr.dt );\n\t\trespond_to_menu( msg );\n\t\tmouselook();\n\t\tpace_vjoy( vi, VS.modes.z == VS_ENG_DRV ? 2. : 1., fr.dt );\n\t\tvs_pace_switches( VS, vi );\n\t\tfloat wp_elev = texelFetch( iChannel1, ivec2( ADDR_B_WAYPOINT_SAMPLE, 0 ), 0 ).w;\n\t\tif( wp_elev > 0. )\n\t\t\tGS.waypoint = normalize( GS.waypoint ) * wp_elev;\n\t\tbreak;\n\t}\n\n\tif( GS.stage != GS_RUNNING || ( lastswitches & GS_TRMAP ) == 0u )\n\t{\n\t\tpace_exposure( fr.dt );\n\t\tpace_hud_brightness( fr.dt );\n\t}\n\n\tif( GS.stage != GS_TRANSITION )\n\t{\n\t\tVS.info = vec4(0);\n\t\tif( ts_is_valid( TS ) )\n\t\t{\n\t\t\tfor( int i = 0; i < fr.subframe_count; ++i )\n\t\t\t{\n\t\t\t\tfloat dt = fr.subframe_dt;\n\t\t\t\tfloat Q = 5. * le.atm.z * dot( VS.localv, VS.localv );\n\t\t\t\tfloat rmax = PD.radius * ( 1. + PD.trn.levels.y );\n\t\t\t\tbool localphysics = Q >= FRACT_1_1048576 || rn.w < rmax;\n\t\t\t\tbool pausemode = ( GS.switches & GS_PAUSE ) == GS_PAUSE;\n\t\t\t\tvs_pace_beginframe( VS, localphysics );\n\t\t\t\tvs_pace_halfstep( VS, vi, dt \/ 2., localphysics, pausemode );\n\t\t\t\t{\n\t\t\t\t\tvec3 rnxy = length_normalize( rn.xy );\n\t\t\t\t\tvec3 psrn = normalize( ps.r );\n\t\t\t\t\tvec3 pshn = normalize( cross( ps.r, ps.v ) );\n\t\t\t\t\tvec3 pshB = normalize( reject( ps.B[2], pshn ) );\n\t\t\t\t\tvec2 Lnxy = normalize( ( -ps.r * ps.B ).xy );\n\t\t\t\t\tvec2 lphase = vec2( rnxy.z, rn.z );\n\t\t\t\t\tvec2 sphase = vec2( dot( pshB, psrn ), dot( pshB, pshn ) );\n\t\t\t\t\tvec2 dphase = vec2( dot( perp( Lnxy ), rnxy.xy ), dot( Lnxy, rnxy.xy ) );\n\t\t\t\t\tfloat terrain = texelFetch( iChannel1, ivec2( ADDR_B_CAMPOS_SAMPLE + 15 - int( log2( PD.radius * PI ) + log2( max( 1.5, length( VS.localr ) - PD.radius ) ) ), 0 ), 0 ).w - PD.radius;\n\t\t\t\t\tfloat att = parabolstep( -.25, .75, terrain );\n\t\t\t\t\tvec4 atm = ap_eval( PD.ap, rn.w, PD.radius, lphase, sphase, dphase * att );\n\t\t\t\t\tfloat u = parabolstep( 0., 0.0015, -atm.w );\n\t\t\t\t\tatm.x = mix( atm.x, PD.ocn.Tds2.x, max( 0., -atm.w ) \/ ( .05 + max( 0., -atm.w ) ) );\n\t\t\t\t\tatm.y = mix( atm.y, PD.ap.ref.y - PD.ocn.Tds2.y * FDM_STD_G * atm.w \/ 100., u );\n\t\t\t\t\tatm.z = mix( atm.z, PD.ocn.Tds2.y, u );\n\t\t\t\t\tle.atm.xyz = atm.xyz;\n\t\t\t\t\tle.atm.w = PD.ap.ssref * sqrt( atm.x \/ PD.ap.ref.x );\n\t\t\t\t\tle.phases = fract( vec2( atan( -sphase.x, -sphase.y ), atan( -dphase.x, -dphase.y ) ) \/ TAU );\n\t\t\t\t\tle.atm2.y = PD.ap.mfpref * PD.ap.ref.z \/ le.atm.z;\n\t\t\t\t\tvs_pace_midframe( VS, vi, le, TS, ps, dt, localphysics, pausemode );\n\t\t\t\t}\n\t\t\t\tle.H = float( localphysics );\n\t\t\t\tvs_pace_halfstep( VS, vi, dt \/ 2., localphysics, pausemode );\n\t\t\t\tvs_pace_endframe( VS, ps, dt, localphysics );\n\t\t\t}\n\t\t}\n\t\tupdate_camera();\n\t}\n\n\tconst float solar_day = 1440. * SECONDS_PER_MINUTE;\n\tGS.datetime.x += fr.dt \/ solar_day;\n\tif( GS.datetime.x >= 1. )\n\t{\n\t\tGS.datetime.x--;\n\t\tGS.datetime.y++;\n\t\tfloat days_per_year = 61. + ( mod( GS.datetime.z, 3. ) == 0. ? 1. : 0. );\n\t\tif( GS.datetime.y >= days_per_year )\n\t\t{\n\t\t\tGS.datetime.y -= days_per_year;\n\t\t\tGS.datetime.z++;\n\t\t}\n\t}\n\n\tGS.switches &= ~GS_CHEES;\n\tGS.switches |= GS_CHEES * uint( keystate( KEY_F12 ) );\n\n\tif( keystate( KEY_SHIFT ) == 1. )\n\t{\n\t\tif( keystate( KEY_1 ) == 1. )\n\t\t\tGS.switches = ( GS.switches & ~GS_SUBSAMPLE_MASK ) | ( 0u << GS_SUBSAMPLE_SHIFT );\n\t\telse\n\t\tif( keystate( KEY_2 ) == 1. )\n\t\t\tGS.switches = ( GS.switches & ~GS_SUBSAMPLE_MASK ) | ( 1u << GS_SUBSAMPLE_SHIFT );\n\t\telse\n\t\tif( keystate( KEY_3 ) == 1. )\n\t\t\tGS.switches = ( GS.switches & ~GS_SUBSAMPLE_MASK ) | ( 2u << GS_SUBSAMPLE_SHIFT );\n\t\telse\n\t\tif( keystate( KEY_4 ) == 1. )\n\t\t\tGS.switches = ( GS.switches & ~GS_SUBSAMPLE_MASK ) | ( 3u << GS_SUBSAMPLE_SHIFT );\n\t}\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ AUTO EXPOSURE\n\/\/ ----------------------------------------------------------------------------\n\nvec4 sample_exposure( ivec2 tileindex )\n{\n\tfloat M1 = 0.;\n\tfloat M2 = 0.;\n\tfloat wsum = 0.;\n\n\tvec2 tilesize = iResolution.xy \/ ( 16. * g_subsample );\n\tvec2 tilebase = vec2( tileindex ) * tilesize;\n\tint N = min( IMG_EXPOSURE_SAMPLES, int( tilesize.x * tilesize.y ) );\n\tuint rnd = 7u * uint( iFrame ) + 17u * uint( tileindex.x ) + 11u * uint( tileindex.y );\n\tbool vrmode = bool( texelFetch( iChannel2, ivec2(0,0), 0 ).w );\n\n\tfor( int i = 0; i < N; ++i )\n\t{\n\t\tvec2 uv = tilebase + tilesize * vec2( rnd *= RNG32, rnd *= RNG32 ) * SHR32;\n\t\tfloat weight = square( ( 1. - square( 4. * uv.x * g_subsample \/ iResolution.x - 1. ) ) *\n\t\t\t\t\t\t\t   ( 1. - square( 4. * uv.y * g_subsample \/ iResolution.y - 1. ) ) );\n\t\tif( vrmode )\n\t\t\tuv.x = .5 * uv.x + .5 * float( i < N \/ 2 );\n\t\tvec3 col = texelFetch( iChannel2, ivec2(uv), 1 ).xyz;\n\t\tcol = clamp( col, 0., IMG_EXPOSURE_MAX );\n\t  #if WITH_ILLUM_TEST\n\t\tfloat L = dot( col, COL_YWEIGHTS );\n\t  #else\n\t\tfloat L = hmax( col );\n\t  #endif\n\t\tL = min( L, IMG_EXPOSURE_MAX );\n\t\tM1 += L * weight;\n\t\tM2 += L * L * weight;\n\t\twsum += weight;\n\t}\n\n\treturn vec4( M1, M2, wsum, 0 );\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAIN\n\/\/ ----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{\n\tfcolor = vec4( ZERO, 0 );\n\n#if BUFFER_RUNLEVEL >= 1\n\n\tif( fcoord.x >= 160. || fcoord.y >= 128. )\n\t\tdiscard;\n\n\t\/\/ load \/ init\n\n\tbool init = iFrame == 0;\n\tbool resolutionchange = iResolution.xy != memload( iChannel0, ADDR_RESOLUTION, 0 ).xy;\n\tDT = vec4( iTimeDelta, memload( iChannel0, ADDR_DTIME, 0 ).xyz );\n\tGS = gs_load_or_init( iChannel0, ADDR_GAME_STATE, init );\n\tVS = vs_load_or_init( iChannel0, ADDR_VEHICLE_STATE, init );\n\tTS = ts_load_or_init( iChannel0, ADDR_LOCAL_TS, init );\n\n\tint localplanetindex = 1;\n\tPD = g_planet_data[ localplanetindex ];\n\n\tbool irmode = ( GS.switches & GS_IRCAM ) != 0u;\n\tbool locallimit = length( VS.orbitr ) < 12. * PD.am.scale + log( PD.ap.ref.z ) + PD.radius;\n\tFrameContext fr = fr_init( DT, locallimit );\n\tVehicleInputs vi = vi_read_inputs( VS );\n\n\tg_subsample = gs_get_subsample( GS );\n\n\t\/\/ update\n\n\tivec2 sc = ivec2( fcoord );\n\tg_msgindex = ( sc.x - ADDR_MSG_QUEUE.y - 1 ) % TXT_MSG_MAX_PHRASES;\n\tMsgQueue msg = msg_load_and_pace( iChannel0, ADDR_MSG_QUEUE, g_msgindex, fr.dt );\n\n\tLocalEnv le;\n\tif( in_game_update_range( sc ) || in_terrain_samplers_range( sc ) )\n\t\tpace_game( fr, vi, msg, le, irmode, resolutionchange );\n\n\t\/\/ store\n\n\tif( in_addr_range( sc, ADDR_RESOLUTION, 1, 1 ) )\n\t   memstore( iResolution.xyxy, ADDR_RESOLUTION, 0, sc, fcolor );\n\telse\n\tif( in_addr_range( sc, ADDR_DTIME, 1, 1 ) )\n\t   memstore( DT, ADDR_DTIME, 0, sc, fcolor );\n\telse\n\tif( in_addr_range( sc, ADDR_EXPOSURE, 8, 8 ) )\n\t{\n\t\tivec2 tileindex = sc - ADDR_EXPOSURE.yx;\n\t\tfcolor = init ? vec4(0) : sample_exposure( tileindex );\n\t}\n\telse\n\tif( in_ps_atm_ts_range( sc ) || in_pd_range( sc ) )\n\t{\n\t\tint index = sc.y - ADDR_PLANET_STATES.x;\n\t\tPlanetData data = g_planet_data[ index ];\n\t\tPlanetData parentdata = g_planet_data[ int( data.parent ) ];\n\t\tPlanetState ps, parent;\n\t\tTrnSampler ts, tslast;\n\t\tif( GS.stage == GS_INIT )\n\t\t{\n\t\t\tps = ps_init( data );\n\t\t\tparent = ps_init( parentdata );\n\t\t\tts = ts_init();\n\t\t\ttslast = ts_init();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tps = ps_load( iChannel0, ps_addr( index ) );\n\t\t\tparent = ps_load( iChannel0, ps_addr( int( data.parent ) ) );\n\t\t\tts = ts_load( iChannel0, ts_addr( index ) );\n\t\t\ttslast = ts_load( iChannel0, ts_last_addr( index ) );\n\t\t}\n\t\tif( GS.stage != GS_TRANSITION )\n\t\t\tif( ts_is_valid( TS ) )\n\t\t\t\tps_pace( ps, data.orbit, fr.dt );\n\t\tkp_get_vectors( data.orbit, ps.nu, ps.dnudt90, ps.orbitr, ps.orbitv );\n\t\tps.r = ps.orbitr + parent.orbitr;\n\t\tps.v = ps.orbitv + parent.orbitv;\n\t\tAtmContext ac = ac_init( data, irmode );\n\t\tpd_store( data, pd_addr( index ), sc, fcolor );\n\t\tps_store( ps, ps_addr( index ), sc, fcolor );\n\t\tac_store( ac, ac_addr( index ), sc, fcolor );\n\t}\n\telse\n\tif( in_so_objrange( sc ) || in_addr_range( sc, ADDR_DATASIZES, 1, 1 ) )\n\t{\n\t\tint k = 0;\n\t\tfloat distthres = .25 * GS.camzoom * CAM_FOCUS_INNER * iResolution.x \/ g_subsample;\n\t\tbool notmapmode = ( GS.switches & GS_TRMAP ) == 0u;\n\n\t\tif( iFrame >= 4 )\n\t\tfor( int i = 0, n = SCENE_DATA_COUNT; i < n && k < SCN_MAX_PRIMITIVES; ++i )\n\t\t{\n\t\t\tSceneObj obj = so_load( iChannel0, so_dataaddr(i) );\n\t\t\tif( int( obj.tybr.x ) != SCNOBJ_TYPE_INVALID )\n\t\t\t{\n\t\t\t\tif( notmapmode && distance( GS.campos, obj.r ) >= obj.tybr.y * distthres )\n\t\t\t\t\tbreak;\n\n\t\t\t\tif( notmapmode || int( obj.tybr.x ) < SCNOBJ_TYPE_3D )\n\t\t\t\t\tk = so_expand_to_primitives( obj, k, GS.timer, ADDR_SCENE_OBJECTS, sc, fcolor );\n\t\t\t}\n\t\t}\n\t\tmemstore( vec4( 0, 0, 0, k ), ADDR_DATASIZES, 0, sc, fcolor );\n\t}\n\telse\n\tif( in_game_update_range( sc ) )\n\t{\n\t\tgs_store( GS, ADDR_GAME_STATE, sc, fcolor );\n\t\tvs_store( VS, ADDR_VEHICLE_STATE, sc, fcolor );\n\t\tle_store( le, ADDR_LOCAL_ENV, sc, fcolor );\n\n\t\tvec4 localterrain = texelFetch( iChannel1, ivec2( ADDR_B_CAMPOS_SAMPLE, 0 ), 0 );\n\t\tif( localterrain.w == 0. )\n\t\t\tlocalterrain = vec4( normalize( GS.campos ), PD.radius );\n\n\t\tAchievementDetector ad = ad_load_or_init( iChannel0, ADDR_ACHIEVEMENTS, init );\n\t\tif( GS.stage == GS_RUNNING && ( GS.switches & GS_TRMAP ) == 0u )\n\t\t\tad_pace( ad, msg, VS, localterrain, fr.dt );\n\n\t\tad_store( ad, ADDR_ACHIEVEMENTS, sc, fcolor );\n\t\tmsg_store( msg, ADDR_MSG_QUEUE, sc, fcolor );\n\n\t\tts_store( TS, ADDR_LOCAL_TS_LAST, sc, fcolor );\n\t\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t\t\tts_update_stable( TS, GS.campos, localterrain.w, iResolution.y, ts_box_main( iChannel1 ) );\n\t\telse\n\t\t\tTS = ts_init();\n\t\tts_store( TS, ADDR_LOCAL_TS, sc, fcolor );\n\t}\n\telse\n\tif( in_so_datarange( sc ) )\n\t{\n\t\tint index = sc.y - ADDR_SCENE_DATA.x;\n\t\tif( iFrame >= 3 && keypress( KEY_F5 ) == 0. )\n\t\t\tso_dynamic_bubblesort( index, GS.campos, sc, fcolor );\n\t\telse\n\t\t{\n\t\t\tSceneData sd = sd_load( iChannel1, sd_addr_b( index ) );\n\t\t\tSceneObj obj = so_init( sd );\n\t\t\tso_store( obj, so_dataaddr( index ), sc, fcolor );\n\t\t}\n\t}\n\telse\n\tif( in_addr_range( sc, ADDR_MENU_DATA, 2, g_menu_data.length() ) )\n\t{\n\t\tint index = sc.y - ADDR_MENU_DATA.x;\n\t\tfcolor = pack_uvec4( g_menu_data[ index ] );\n\t}\n\telse\n\tif( in_st_range( sc ) )\n\t{\n\t\tint index = sc.y - ADDR_START_DATA.x;\n\t\tStartData start = g_start_data[ index ];\n\t\tst_store( start, st_addr( index ), sc, fcolor );\n\t}\n\n#endif \/\/ RUNLEVEL\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 3 of 6: Buffer B shader (terrain elevation model)\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\/\n\nGameState GS;\nVehicleState VS;\nPlanetState PS;\nPlanetData PD;\nLocalEnv LE;\n\nfloat g_subsample = SCN_SUBSAMPLE;\nvec2 g_textres = vec2(0);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ LOCATION DATA\n\/\/ ----------------------------------------------------------------------------\n\nLocData[] g_loc_data = LocData[](\n\t\/\/ 0\n\tLocData( vec4(\t34.342,\t 117.332, 4.000, 80 ),\tuvec4(0u) ),\n\tLocData( vec4(\t15.882,\t 167.539, 2.667, 98 ),\tuvec4(0u) ),\n\tLocData( vec4(\t52.529,\t 115.867, 1.500, 60 ),\tuvec4(0u) ),\n\tLocData( vec4(\t62.133,\t 150.955, 1.667, 57 ),\tuvec4(0u) ),\n\tLocData( vec4(\t62.468,\t 152.073,  .100, 0 ),\tuvec4(0u) ),\n\t\/\/ 5\n\tLocData( vec4(\t29.907,\t 156.418, 2.667, 191 ), uvec4(0u) ),\n\tLocData( vec4(\t28.970,\t 156.660, 1.000, 0 ),\tuvec4(0u) ),\n\tLocData( vec4(\t28.994,\t 156.489,  .167, 0 ),\tuvec4(0u) ),\n\tLocData( vec4(\t17.449,\t 117.416, 1.333, 82 ),\tuvec4(0u) ),\n\tLocData( vec4(\t-5.083,\t 107.220, 1.333, 3 ),\tuvec4(0u) ),\n\t\/\/ 10\n\tLocData( vec4( -51.548, -124.185,  .050, 70 ),\tuvec4(0u) ),\n\tLocData( vec4( -50.551, -120.686, 1.333, 91 ),\tuvec4(0u) ),\n\tLocData( vec4( -90.000,\t   0.000, 2.000, 10 ),\tuvec4(0u) ),\n\tLocData( vec4(\t34.275, -152.626, 1.667, 0 ),\tuvec4(0u) ),\n\tLocData( vec4( -26.900,\t  28.262, 1.333, 0 ),\tuvec4(0u) ),\n\t\/\/ 15\n\tLocData( vec4(\t65.652,\t  61.718, 1.167, 0 ),\tuvec4(0u) )\n);\n\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE DATA\n\/\/ ----------------------------------------------------------------------------\n\nSceneData[] g_scene_data = SceneData[](\n\n\t\/\/ 00 - Space center west\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,   2.200, 0, 0 ), vec4(\t  .060, -.430, 0, 102 ),\tvec4( 7, 0, 0, .12 ),\t\tvec4( 4382, 65, 15, 5 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,   1.278, 0, 0 ), vec4(\t -.810,\t .230, 0, 31 ),\t\tvec4( 7, 0, 0, .12 ),\t\tvec4( 2739, 65, 12, 4 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.228, 0, 0 ), vec4(\t\t 0,\t\t0, 0, 80 ),\t\tvec4( 6, 0, 0, 0 ),\t\t\tvec4( 250, 150, 5, 4 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.028, 0, 0 ), vec4(\t -.305,\t .165, 0, 80 ),\t\tvec4( 2, 0, 0, .015 ),\t\tvec4( .009, .012, .004, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(\t -.090,\t .200, 0, 80 ),\t\tvec4( 1, 0, 0, 2 ),\t\t\tvec4( .040, .060, .006, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(\t  .075,\t .200, 0, 80 ),\t\tvec4( 1, 0, 0, 2 ),\t\t\tvec4( .040, .060, .006, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(\t  .290, -.015, 0, 80 ),\t\tvec4( 1, 0, 0, 2 ),\t\t\tvec4( .040, .060, .006, 0 ) ),\n\n\t\/\/ 07 - Space center east\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,   1.643, 0, 1 ), vec4(\t\t 0,\t .975, 0, 98 ),\t\tvec4( 2, 0, 0, .7 ),\t\tvec4( 3286, 55, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 1 ), vec4(\t -.700,\t .540, 0, 188 ),\tvec4( 1, 0, 0, 0 ),\t\t\tvec4( 639, 350, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 1 ), vec4(\t -.300, -.375, 0, 92 ),\t\tvec4( 2, 0, 0, 0 ),\t\t\tvec4( 1278, 35, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.146, 0, 1 ), vec4(\t  .410, -.300, 0, 92 ),\t\tvec4( 2, 0, 0, 0 ),\t\t\tvec4( 160, 160, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.028, 0, 1 ), vec4(\t -.920,\t .150, 0, 278 ),\tvec4( 1, 0, 0, .012 ),\t\tvec4( .025, .015, .002, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .050, 0, 1 ), vec4( -1.000, -.200, 0, 92 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .100, .070, .005, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .040, 0, 1 ), vec4(\t -.890, -.505, 0, 92 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .030, .035, .040, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .040, 0, 1 ), vec4(\t -.790, -.495, 0, 92 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .030, .035, .040, 0 ) ),\n\n\t\/\/ 15 - Lucerne\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.657, 0, 2 ), vec4(\t\t 0,\t .025, 0, 60 ),\t\tvec4( 2, 0, 0, .7 ),\t\tvec4( 1315, 25, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.110, 0, 2 ), vec4(\t -.015, -.050, 0, 60 ),\t\tvec4( 1, 0, 0, 0 ),\t\t\tvec4( 120, 50, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.015, 0, 2 ), vec4(\t  .015, -.090, 0, 330 ),\tvec4( 2, 0, 0, .006 ),\t\tvec4( .012, .010, .002, .002 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .018, 0, 2 ), vec4(\t -.040, -.090, 0, 60 ),\t\tvec4( 3, 0, 0, 2 ),\t\t\tvec4( .018, .012, .003, 0 ) ),\n\n\t\/\/ 19 - Bensersiel airfield\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.822, 0, 3 ),  vec4(  .349, -.000, 0, 57 ),\t\tvec4( 8, 0, 0,\t.7 ),\t\tvec4( 1643, 35, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.228, 0, 3 ),  vec4(  .192,\t .067, 0, 57 ),\t\tvec4( 9, 0, 0, 0 ),\t\t\tvec4( 250, 50, 50, 10 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.012, 0, 3 ),  vec4(  .288,\t .111, 0, 147 ),\tvec4( 2, 0, 0, .007 ),\t\tvec4( .012, .010, .002, .002 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .012, 0, 3 ),  vec4(  .219,\t .108, 0, 57 ),\t\tvec4( 14, 0, 0, 2 ),\t\tvec4( .012, .012, .004, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .012, 0, 3 ),  vec4(  .253,\t .110, 0, 57 ),\t\tvec4( 14, 0, 0, 2 ),\t\tvec4( .012, .012, .004, 0 ) ),\n\n\t\/\/ 24 - Bensersiel Lighthouse\n\tSceneData( vec4( SCNOBJ_TYPE_LIGHTHOUSE,.015, 0, 4 ),  vec4( ZERO, 120 ),\t\t\t\tvec4( 2, 0, 0, .010 ),\t\tvec4( .004, .004, .002, .0025 ) ),\n\n\t\/\/ 25 - Cancun airfield\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 5 ),  vec4( -.102,\t .549, 0, 173 ),\tvec4( 5, 0, 0, 0 ),\t\t\tvec4( 1095, 25, 60, 10 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.959, 0, 5 ),  vec4(  .019, -.385, 0, 191 ),\tvec4( 4, 0, 0, .6 ),\t\tvec4( 1917, 35, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 5 ),  vec4( -.323,\t\t0, 0, 191 ),\tvec4( 1, 0, 0, 0 ),\t\t\tvec4( 250, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 5 ),  vec4(  .290,\t\t0, 0, 191 ),\tvec4( 1, 0, 0, 0 ),\t\t\tvec4( 250, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.028, 0, 5 ),  vec4( -.041, -.131, 0, 191 ),\tvec4( 2, 0, 0, .010 ),\t\tvec4( .026, .038, .007, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 5 ),  vec4( -.016,\t\t0, 0, 191 ),\tvec4( 11, 0, 0, 2 ),\t\tvec4( .095, .025, .010, 0 ) ),\n\n\t\/\/ 31 - Cancun hotels\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.230, -.105, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.140, -.060, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.050, -.015, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .060, -.030, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .150,\t .015, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .240,\t .060, 0, 0 ),\t\tvec4( 11, 0, 0, 2 ),\t\tvec4( .025, .005, .013, 0 ) ),\n\n\t\/\/ 37 - Cancun underwater museum\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0255, -.0085, 0, 0 ),\tvec4( 15, 0, 0, 1 ),\t\tvec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0230,  .0012, 0, 0 ),\tvec4( 16, 0, 0, 1 ),\t\tvec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0218, -.0030, 0, 0 ),\tvec4( 17, 0, 0, 1 ),\t\tvec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0020, -.0147, 0, 64 ),\tvec4( 28, 0, 0, 2 ),\t\tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0091, -.0219, 0, 31 ),\tvec4( 28, 0, 0, 2 ),\t\tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0080, -.0177, 0, 22 ),\tvec4( 28, 0, 0, 2 ),\t\tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .003, 0, 7 ),  vec4(  .0245,  .0365, 0, 0 ),\tvec4( 18, 0, 0, 3 ),\t\tvec4( .001, .003, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .003, 0, 7 ),  vec4(  .0267,  .0281, 0, 0 ),\tvec4( 19, 0, 0, 3 ),\t\tvec4( .001, .003, 0, 0 ) ),\n\n\t\/\/ 45 - Rocky springs\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.685, 0, 8 ),  vec4( -.003, -.064, 0, 82 ),\t\tvec4( 3, 0, 0, .6 ),\t\tvec4( 1369, 30, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.110, 0, 8 ),  vec4( -.209, -.002, 0, 82 ),\t\tvec4( 3, 0, 0, 0 ),\t\t\tvec4( 120, 50, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.183, 0, 8 ),  vec4( -.116,\t .085, 0, 172 ),\tvec4( 2, 0, 0, 0 ),\t\t\tvec4( 220, 15, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.183, 0, 8 ),  vec4(  .017,\t .121, 0, 82 ),\t\tvec4( 1, 0, 0, 0 ),\t\t\tvec4( 200, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.015, 0, 8 ),  vec4( -.160,\t .063, 0, 82 ),\t\tvec4( 2, 0, 0, .007 ),\t\tvec4( .012, .016, .0025, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .022, 0, 8 ),  vec4(  .010,\t .222, 0, 82 ),\t\tvec4( 12, 0, 0, 2 ),\t\tvec4( .045, .012, .004, 0 ) ),\n\n\t\/\/ 51 - Lake Victoria\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.548, 0, 9 ),  vec4(  .045,\t .050, 0, 3 ),\t\tvec4( 29, 0, 0, 0 ),\t\tvec4( 1095, 25, 70, 10 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.160,\t .200, 0, 0 ),\t\tvec4( 20, 0, 0, 3 ),\t\tvec4( .012, .003, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.140,\t .240, 0, 0 ),\t\tvec4( 20, 0, 0, 3 ),\t\tvec4( .012, .003, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.120,\t .280, 0, 0 ),\t\tvec4( 20, 0, 0, 3 ),\t\tvec4( .012, .003, 0, 0 ) ),\n\n\t\/\/ 55 - Hang gliding summit station\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .00592,.00382, 0, 0 ),\tvec4( 25, 0, 0, 3 ),\t\tvec4( .00005, .0015, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .00408,.00618, 0, 0 ),\tvec4( 25, 0, 0, 3 ),\t\tvec4( .00005, .0015, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .005,\t .005, .0025, 122 ),vec4( 11, 0, 0, 2 ),\t\tvec4( .002, .00002, .0015, 0 ) ),\n\n\t\/\/ 58 - Hang gliding base\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.411, 0, 11 ), vec4( -.026, -.147, 0, 91 ),\t\tvec4( 9, 0, 0, 0 ),\t\t\tvec4( 822, 25, 10, 2 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .006, 0, 11 ), vec4(  .225, -.182, 0, 91 ),\t\tvec4( 26, 0, 0, 2 ),\t\tvec4( .005, .006, .002, 0 ) ),\n\n\t\/\/ 60 - South pole station\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.959, 0, 12 ),\tvec4( .628, -.362, 0, 150.3 ),\tvec4( 27, 0, 0, .2 ),\t\tvec4( 1917, 40, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,   1.004, 0, 12 ),\tvec4( .122, -.087, 0, 324.7 ),\tvec4( 2, 0, 0, 0 ),\t\t\tvec4( 30, 50, 2, 2 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),\tvec4( .122, -.087, .0035, 324.7 ), vec4( 11, 0, 0, 2 ),\t\tvec4( .015, .025, .004, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),\tvec4( .112, -.067, 0, -30.3 ),\tvec4( 21, 0, 0, 2 ),\t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),\tvec4( .112, -.107, 0, -43.5 ),\tvec4( 21, 0, 0, 2 ),\t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),\tvec4( .132, -.107, 0, -38.6 ),\tvec4( 21, 0, 0, 2 ),\t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),\tvec4( .132, -.067, 0, -26.5 ),\tvec4( 21, 0, 0, 2 ),\t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),\tvec4(0),\t\t\t\t\t\tvec4( 21, 0, 0, 3 ),\t\tvec4( .001, .0002, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),\tvec4(0),\t\t\t\t\t\tvec4( 21, 0, 0, 3 ),\t\tvec4( .00005, .001, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),\tvec4( 0, 0, .002, 0 ),\t\t\tvec4( 22, 0, 0, 1 ),\t\tvec4( .0005, ZERO ) ),\n\n\t\/\/ 70 - Gonder scenery\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.566, 0, 13 ), vec4( -.059, -.038, 0, 213 ),\tvec4( 3, 0, 0, .5 ),\t\tvec4( 1315, 30, 5, 2 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,\t\t.015, 0, 13 ), vec4(  .067,\t .044, 0, 123 ),\tvec4( 2, 0, 0, .006 ),\t\tvec4( .012, .010, .002, .002 ) ),\n\n\t\/\/ 72 - Ash island\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.630, 0, 14 ), vec4( ZERO, 28 ),\t\t\t\tvec4( 7, 0, 0, 0 ),\t\tvec4( 1260, 25, 80, 10 ) ),\n\n\t\/\/ 73 - Whitelands scenery\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.602, 0, 15 ), vec4( ZERO, 72 ),\t\t\t\tvec4( 9, 0, 0, .4 ),\t\tvec4( 1205, 25, 10, 10 ) ),\n\n\t\/\/\n\tSceneData( vec4( SCNOBJ_TYPE_INVALID, ZERO ), vec4(0), vec4(0), vec4(0) )\n);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ TEXT DATA\n\/\/ ----------------------------------------------------------------------------\n\nconst uvec4[] g_text_data = uvec4[](\n\t\/\/ 80\n\tuvec4(0),\n\tuvec4( 0x2e2e2e00, 0, 0, 3 ),\t\t\t\t\t\t\/\/ '...'\n\tuvec4( 0x636f6d6d, 0x616e6400, 0, 7 ),\t\t\t\t\/\/ 'command'\n\tuvec4( 0x656e6769, 0x6e650000, 0, 6 ),\t\t\t\t\/\/ 'engine'\n\tuvec4( 0x636f6e74, 0x726f6c00, 0, 7 ),\t\t\t\t\/\/ 'control'\n\tuvec4( 0x7468726f,\t0x74746c65, 0, 8 ),\t\t\t\t\/\/ 'throttle'\n\tuvec4( 0x696e666f, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'info'\n\tuvec4( 0x6d6f6465, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'mode'\n\n\t\/\/ 88\n\tuvec4( 0x70616765, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'page'\n\tuvec4( 0x72617465, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'rate'\n\tuvec4( 0x64726976, 0x65000000, 0, 5 ),\t\t\t\t\/\/ 'drive'\n\tuvec4( 0x696d7075, 0x6c736500, 0, 7 ),\t\t\t\t\/\/ 'impulse'\n\tuvec4( 0x6e6f7661, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'nova'\n\tuvec4( 0x6165726f, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'aero'\n\tuvec4( 0x6d616e75, 0x616c0000, 0, 6 ),\t\t\t\t\/\/ 'manual'\n\tuvec4( 0x73757266, 0x61636500, 0, 7 ),\t\t\t\t\/\/ 'surface'\n\n\t\/\/ 90\n\tuvec4( 0x6f726269, 0x74000000, 0, 5 ),\t\t\t\t\/\/ 'orbit'\n\tuvec4( 0x6c6f6361, 0x74696f6e, 0, 8 ),\t\t\t\t\/\/ 'location'\n\tuvec4( 0x64697265, 0x63740000, 0, 6 ),\t\t\t\t\/\/ 'direct'\n\tuvec4( 0x73656c65, 0x63740000, 0, 6 ),\t\t\t\t\/\/ 'select'\n\tuvec4( 0x73706163, 0x65000000, 0, 5 ),\t\t\t\t\/\/ 'space'\n\tuvec4( 0x63656e74, 0x65720000, 0, 6 ),\t\t\t\t\/\/ 'center'\n\tuvec4( 0x65617374, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'east'\n\tuvec4( 0x77657374, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'west'\n\n\t\/\/ 98\n\tuvec4( 0x6e6f7274, 0x68000000, 0, 5 ),\t\t\t\t\/\/ 'north'\n\tuvec4( 0x736f7574, 0x68000000, 0, 5 ),\t\t\t\t\/\/ 'south'\n\tuvec4( 0x706f6c65, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'pole'\n\tuvec4( 0x73746174, 0x696f6e00, 0, 7 ),\t\t\t\t\/\/ 'station'\n\tuvec4( 0x476c6964, 0x65720000, 0, 6 ),\t\t\t\t\/\/ 'Glider'\n\tuvec4( 0x53686164, 0x6572746f, 0x79000000, 9 ),\t\t\/\/ 'Shadertoy'\n\tuvec4( 0x45646974, 0x696f6e00, 0, 7 ),\t\t\t\t\/\/ 'Edition'\n\tuvec4( 0x73746172, 0x74000000, 0, 5 ),\t\t\t\t\/\/ 'start'\n\n\t\/\/ a0\n\tuvec4( 0x7472616e, 0x73666572, 0x696e6700, 8 ),\t\t\/\/ 'transfer'\n\tuvec4( 0x43616e63, 0xfa6e0000, 0, 6 ),\t\t\t\t\/\/ 'Canc\u00fan'\n\tuvec4( 0x756e6465, 0x72776174, 0x65720000, 10 ),\t\/\/ 'underwater'\n\tuvec4( 0x7072696d, 0x69746976, 0x65000000, 9 ),\t\t\/\/ 'primitive'\n\tuvec4( 0x6368616c, 0x6c656e67, 0x65000000, 9 ),\t\t\/\/ 'challenge'\n\tuvec4( 0x6f766572, 0x6c617900, 0, 7 ),\t\t\t\t\/\/ 'overlay'\n\tuvec4( 0x7472656e, 0x63680000, 0, 6 ),\t\t\t\t\/\/ 'trench'\n\tuvec4( 0x77617970, 0x6f696e74, 0, 8 ),\t\t\t\t\/\/ 'waypoint'\n\n\t\/\/ a8\n\tuvec4( 0x69736c61, 0x6e640000, 0, 6 ),\t\t\t\t\/\/ 'island'\n\tuvec4( 0x696d706c, 0x656d656e, 0x74656400, 11 ),\t\/\/ 'implemented'\n\tuvec4( 0x746f7563, 0x68646f77, 0x6e000000, 9 ),\t\t\/\/ 'touchdown'\n\tuvec4( 0x73756363, 0x65737366, 0x756c0000, 10 ),\t\/\/ 'successful'\n\tuvec4( 0x65786365, 0x6c6c656e, 0x74000000, 9 ),\t\t\/\/ 'excellent'\n\tuvec4( 0x64657374, 0x696e6174, 0x696f6e00, 11 ),\t\/\/ 'destination'\n\tuvec4( 0x726f7461, 0x74696f6e, 0, 8 ),\t\t\t\t\/\/ 'rotation'\n\tuvec4( 0x77697265, 0, 0, 4 ),\t\t\t\t\t\t\/\/ 'wire'\n\n\t\/\/ b0\n\tuvec4( 0x80000000, 0, 0, 1 ),\t\t\t\t\t\t\/\/ '\u03b1' (alpha)\n\tuvec4( 0x85000000, 0, 0, 1 ),\t\t\t\t\t\t\/\/ '\u03b8' (theta)\n\tuvec4( 0x8a000000, 0, 0, 1 ),\t\t\t\t\t\t\/\/ '\u03c1' (rho)\n\tuvec4( 0xb0000000, 0, 0, 1 ),\t\t\t\t\t\t\/\/ '\u00b0' (degrees)\n\tuvec4( 0xb3000000, 0, 0, 1 ),\t\t\t\t\t\t\/\/ '\u00b3' (super 3)\n\tuvec4( 0x91680000, 0, 0, 2 ),\t\t\t\t\t\t\/\/ '\u0394h' (Delta h)\n\tuvec4(0)\n);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ VEHICLE INPUT STATE\n\/\/ ----------------------------------------------------------------------------\n\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_META = 224;\n\nfloat keystate( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 0 ), 0 ).x; }\n\nfloat keypress( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 1 ), 0 ).x; }\n\nfloat keystatepress( int key )\n\t{ return max( keystate( key ), keypress( key ) ); }\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ FRAME CONTEXT\n\/\/ ----------------------------------------------------------------------------\n\nstruct FrameContext\n{\n\tfloat timeaccel;\n\tint subframe_count;\n\tfloat subframe_dt;\n\tfloat dt;\n};\n\nFrameContext fr_init( vec4 dtime, bool local )\n{\n\tFrameContext result;\n\tfloat dt_frame = dot( dtime, vec4( 1, 2, 2, 1 ) \/ 6. );\n\tresult.timeaccel =\n\t\tkeystate( KEY_F4 ) > 0. && !local ? 10000. :\n\t\tkeystate( KEY_F3 ) > 0. ? 1000. :\n\t\tkeystate( KEY_F2 ) > 0. ? 100. :\n\t\tkeystate( KEY_F1 ) > 0. ? 10. :\n\t\t1.;\n\tresult.subframe_count = min( VS_MAX_ITER, int( ceil( sqrt( result.timeaccel ) ) ) );\n\tresult.subframe_dt = min( local ? VS_MAX_PACE_LOCAL : VS_MAX_PACE, dt_frame * result.timeaccel \/ float( result.subframe_count ) );\n\tresult.timeaccel = result.timeaccel == 1. ? 1. : float( result.subframe_count ) * safediv( result.subframe_dt, dt_frame );\n\tresult.dt = result.subframe_dt * float( result.subframe_count );\n\treturn result;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ TEXT PROCESSING\n\/\/ ----------------------------------------------------------------------------\n\nint ipow( int b, int e )\n{\n\tint result = 1;\n\tif( e >= 0 )\n\t{\n\t\tif( bool( e & 1 ) ) result *= b; b *= b;\n\t\tif( bool( e & 2 ) ) result *= b; b *= b;\n\t\tif( bool( e & 4 ) ) result *= b; b *= b;\n\t\tif( bool( e & 8 ) ) result *= b; b *= b;\n\t}\n\treturn result;\n}\n\nvec4 text_format( int index, vec4 params, uvec4 phrase, vec4 argv )\n{\n#define CHROUT(p,chr) if( (p) >= 0 && (p) < 4 ) result[p] = chr;\n\tvec4 result = vec4(0);\n\tint argc = 0;\n\tint nchars = 0;\n\tint nwords = int( phrase.w & TXT_FMT_LENGTH_MASK );\n\tfor( int i = 0, n = nwords; i < n; ++i )\n\t{\n\t\tint pbase = nchars + 5 - 4 * index;\n\t\tint code = int( ( phrase[ i >> 2 ] >> ( ( ~i & 3 ) << 3 ) ) & 0xffu );\n\t\tif( code >= 0xf0 && argc < 4 )\n\t\t{\n\t\t\t\/\/ numeric conversion\t\t\tintegers\tdecimals\n\t\t\t\/\/ -------------------------------------------------\n\t\t\t\/\/ 0xf0 .. 0xf2:\tunsigned\t2,3,4\t\t0\n\t\t\t\/\/ 0xf3 .. 0xf5:\tsigned\t\t2,3,4\t\t0\n\t\t\t\/\/ 0xf6 .. 0xf8:\tsigned\t\t2,3,4\t\t1\n\t\t\t\/\/ 0xf9 .. 0xfb:\tsigned\t\t2,3,4\t\t2\n\t\t\t\/\/ 0xfc .. 0xfe:\tsigned\t\t2,3,4\t\t4\n\t\t\t\/\/ 0xff:\t\t\tsigned\t\t2\t\t\t6\n\n\t\t\tconst int base = 10;\n\t\t\tfloat arg = argv[ argc ];\n\t\t\tint p = ( code - 0xf0 ) % 3 + 2;\n\t\t\tint m = ipow( base, p );\n\t\t\tint q = ( code - 0xf0 ) \/ 3;\n\t\t\tbool overflow = abs(arg) >= float(m);\n\t\t\tbool signed = q > 0;\n\t\t\tif( signed )\n\t\t\t{\n\t\t\t\tq = q * q \/ 4;\n\t\t\t\tint r = ipow( base, q );\n\t\t\t\tm *= r;\n\t\t\t\targ *= float(r);\n\t\t\t\targ += .5 * sign( arg );\n\t\t\t}\n\t\t\telse\n\t\t\t\targ *= float( base );\n\t\t\tint a = int( arg );\n\t\t\tint k = pbase;\n\t\t\tint jend = min( TXT_FMT_MAX_LEN - nchars - int( signed ), p + q + int( q > 0 ) );\n\t\t\tbool dout = !signed;\n\t\t\tfor( int j = -int( signed ); j < jend; ++j )\n\t\t\t{\n\t\t\t\tint digit = abs(a) \/ m;\n\t\t\t\tfloat chr = 32.;\n\t\t\t\tif( j == p )\n\t\t\t\t{\n\t\t\t\t\tchr = 46.;\n\t\t\t\t\tdout = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif( !dout && arg < 0. && ( abs(a) * base >= m || j + 2 >= p ) )\n\t\t\t\t{\n\t\t\t\t\tchr = 45.;\n\t\t\t\t\ta *= base;\n\t\t\t\t\tdout = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif( overflow )\n\t\t\t\t{\n\t\t\t\t\tchr = j >= 0 ? 42. : 32.;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta -= sign(a) * m * digit;\n\t\t\t\t\ta *= base;\n\t\t\t\t\tif( digit > 0 || j + 1 >= p )\n\t\t\t\t\t\tdout = true;\n\t\t\t\t\tif( dout )\n\t\t\t\t\t\tchr = float( digit ) + 48.;\n\t\t\t\t}\n\t\t\t\tCHROUT( k, chr );\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tnchars += jend + int( signed );\n\t\t\targc++;\n\t\t}\n\t\telse\n\t\tif( code >= 0x80 && ( code & 0x7f ) < g_text_data.length() )\n\t\t{\n\t\t\t\/\/ word substitution for bytes 0x80..0xef\n\t\t\tuvec4 word = g_text_data[ code & 0x7f ];\n\t\t\tint wlen = min( TXT_FMT_MAX_LEN - nchars, int( word.w & 0xffu ) );\n\t\t\tif( pbase >= -wlen && pbase < 4 )\n\t\t\t\tfor( int j = 0; j < wlen; ++j )\n\t\t\t\t{\n\t\t\t\t\tint chr = int( ( word[ j >> 2 ] >> ( ( ~j & 3 ) << 3 ) ) & 0xffu );\n\t\t\t\t\tif( i == 0 && j == 0 )\n\t\t\t\t\t\tchr = int( chr ) & ~0x20;\n\t\t\t\t\tCHROUT( pbase + j, float( chr ) );\n\t\t\t\t}\n\t\t\tnchars += wlen;\n\t\t\tif( i + 1 < nwords )\n\t\t\t\t{ CHROUT( pbase + wlen, 32. ); nchars++; }\n\t\t}\n\t\telse\n\t\tif( code > 0 && nchars < TXT_FMT_MAX_LEN )\n\t\t{\n\t\t\t\/\/ literal character\n\t\t\tCHROUT( pbase, float( code ) ); nchars++;\n\t\t}\n\t}\n\n\tif( index == 0 )\n\t{\n\t\tresult = params;\n\t\tif( ( phrase.w & TXT_FMT_FLAG_CENTER ) == TXT_FMT_FLAG_CENTER )\n\t\t\tresult.x -= abs( result.w ) * float( nchars ) * TXT_FONT_SPACING \/ 2.;\n\t\telse\n\t\tif( ( phrase.w & TXT_FMT_FLAG_RIGHT ) == TXT_FMT_FLAG_RIGHT )\n\t\t\tresult.x -= abs( result.w ) * float( nchars ) * TXT_FONT_SPACING;\n\t}\n\telse\n\tif( index == 1 )\n\t{\n\t\tresult.x = float( nchars );\n\t\tif( ( phrase.w & TXT_FMT_FLAG_HUDCLIP ) == TXT_FMT_FLAG_HUDCLIP )\n\t\t\tresult.x = -result.x;\n\t}\n\treturn result;\n#undef CHROUT\n}\n\nvoid process_text_message_line( int i, inout int N,\n\t\t\t\t\t\t\t\tinout vec4 params, inout uvec4 phrase, inout vec4 argv )\n{\n\tfloat x = ( 1. + 2. * ( 1. - fract( 1. - memload( iChannel0, ADDR_MSG_QUEUE, 0 ).x ) ) ) * g_textres.x \/ 2.;\n\tfloat y = g_textres.y \/ 4. + 16.;\n\tswitch( i - N )\n\t{\n\tcase 0:\n\t\tparams = vec4( x - g_textres.x, y, 1, 15 );\n\t\tphrase = unpack_uvec4( memload( iChannel0, ADDR_MSG_QUEUE, 1 ) );\n\t\tphrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;\n\t\targv = memload( iChannel0, ADDR_MSG_QUEUE, 1 + TXT_MSG_MAX_PHRASES );\n\t\tbreak;\n\tcase 1:\n\t\tparams = vec4( x, y, 1, 15 );\n\t\tphrase = unpack_uvec4( memload( iChannel0, ADDR_MSG_QUEUE, 2 ) );\n\t\tphrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;\n\t\targv = memload( iChannel0, ADDR_MSG_QUEUE, 2 + TXT_MSG_MAX_PHRASES );\n\t\tbreak;\n\t}\n\tN += 2;\n}\n\nvoid process_text_select_location( int i, inout int N,\n\t\t\t\t\t\t\t\t   inout vec4 params, inout uvec4 phrase,\n\t\t\t\t\t\t\t\t   GameState gs )\n{\n\tint n = START_DATA_COUNT - 1;\n\tint index = i - N + 1;\n\tif( index >= 1 && index < n )\n\t{\n\t\tStartData start = st_load( iChannel0, st_addr( index ) );\n\t\tvec3 nav = start.iparams.x == 3 && start.iparams.y < SCENE_DATA_COUNT ?\n\t\t\tsd_load( iChannel1, sd_addr_b( start.iparams.y ) ).navb.xyz :\n\t\t\tstart.params.xyz * vec3( 1, 1, TRN_SCALE );\n\t\tvec3 r = nav2r( vec3( nav.xy, nav.z + PD.radius ) );\n\t\tvec3 v = normalize( r - VS.localr ) * gs.camframe;\n\t\tv = round( 2047.5 * v + 2047.5 );\n\t\tparams = vec4( v.x + v.y \/ 4096., v.z, 1, -12 );\n\t  #if WORKAROUND_05_UVEC4\n\t\tphrase = uvec4( uint( 64 + index ) << 24u, 0u, 0u, 1u );\n\t  #else\n\t\tphrase = uvec4( uint( 64 + index ) << 24u, 0, 0, 1 );\n\t  #endif\n\t}\n\tN += n - 1;\n}\n\nvoid process_text_command_menu( int i, inout int N,\n\t\t\t\t\t\t\t\tinout vec4 params, inout uvec4 phrase,\n\t\t\t\t\t\t\t\tGameState gs )\n{\n\tuvec4 currmenu = md_load( iChannel0, gs.menustate.x );\n\tif( i == N )\n\t\tparams = vec4( 24, g_textres.y - 24., -1, 15 ),\n\t\tphrase = currmenu;\n\tN++;\n\tint j = i - N;\n\tint n = int( currmenu.w >> 8 ) & 0xff;\n\tint p = int( currmenu.w >> 16 ) & 0xff;\n\tif( n > 0 && j >= 0 )\n\t{\n\t\tfloat y = g_textres.y - 48. - float( j % n ) * 16.;\n\t\tif( j < n )\n\t\t\tparams = vec4( 24, y, 1, 15 ), phrase = uvec4( ( ( j + 49 ) << 24 ) | 0x2e2000, 0, 0, 3 );\n\t\telse\n\t\tif( j < 2 * n )\n\t\t\tparams = vec4( 48, y, 1, 15 ), phrase = md_load( iChannel0, p + j - n );\n\t}\n\tN += 2 * n;\n}\n\nvoid process_text_conj_gradients( int i, inout int N,\n\t\t\t\t\t\t\t\t  inout vec4 params, inout uvec4 phrase )\n{\n\tvec3 r_ = VS.orbitr;\n\tvec3 v_ = VS.orbitv;\n\tfloat invGM = 1. \/ PD.GM;\n\n\tfloat r2 = dot( r_, r_ );\n\tfloat v2 = dot( v_, v_ );\n\tfloat rv = dot( r_, v_ );\n\tvec3 h_ = cross( r_, v_ );\n\tfloat h2 = dot( h_, h_ );\n\tfloat h = sqrt( h2 );\n\tfloat r = sqrt( r2 );\n\tfloat epsilon = v2 * invGM - 1. \/ r;\n\tvec3 e_ = epsilon * r_ - rv * invGM * v_;\n\tfloat e2 = dot( e_, e_ );\n\tfloat e = sqrt( e2 );\n\tvec3 f_ = e_ + epsilon * r_;\n\n\tvec3[5] dirs = vec3[5](\n\t\tcross( v_, h_ ) * sign( 1. - e ),\n\t\tf_,\n\t\t2. * e * ( 1. + e ) * r_ - invGM * h2 * f_,\n\t\t2. * e * ( 1. - e ) * r_ + invGM * h2 * f_,\n\t\th_\n\t);\n\n\tif( lensq( dirs[2] ) * 16777216. < r2 * e )\n\t\tdirs[2] = abs( rv ) \/ r2 * r_ + sign( rv ) * e * v_;\n\n\tif( lensq( dirs[3] ) * 16777216. < r2 * e )\n\t\tdirs[3] = abs( rv ) \/ r2 * r_ - sign( rv ) * e * v_;\n\n\tuvec4[5] phrases = uvec4[5](\n\t\tuvec4( 0x00650000, 0, 0, 2 ),\t\t\/\/ e\n\t\tuvec4( 0x00610000, 0, 0, 2 ),\t\t\/\/ a\n\t\tuvec4( 0x00417000, 0, 0, 3 ),\t\t\/\/ Ap\n\t\tuvec4( 0x00506500, 0, 0, 3 ),\t\t\/\/ Pe\n\t\tuvec4( 0x00680000, 0, 0, 2 )\t\t\/\/ h\n\t);\n\n\tvec2 tsc = sincospi( VS.tvec \/ 180. );\n\tmat3 tvecrot = VS.B *\n\t\tmat3( tsc.y, 0, tsc.x, 0, VS.tvec < 105. ? 1 : -1, 0, -tsc.x, 0, tsc.y ) *\n\t\ttranspose( VS.B );\n\n\tfor( int j = 0; j < 5; ++j )\n\tif( lensq( dirs[j] ) * 1e12 >= r2 && i == N++ )\n\t{\n\t\tvec3 dir = tvecrot * normalize( dirs[j] );\n\t\tif( dot( dir, PS.B * GS.camframe[0] ) < 0. )\n\t\t\tdir = -dir;\n\t\tbool plus = dot( dir, tvecrot * ( j >= 4 ? h_ : cross( h_, dirs[ j ^ 1 ] ) ) ) >= 0.;\n\t\tdir = round( 2047.5 * dir * PS.B * GS.camframe + 2047.5 );\n\t\tparams = vec4( dir.x + dir.y \/ 4096., dir.z, 1, -12 );\n\t\tphrase = phrases[j];\n\t\tphrase[0] |= plus ? 0x2b000000u : 0x2d000000u;\n\t}\n}\n\n#define CW(a,b) ( (a) * (b) * TXT_FONT_SPACING )\n\nvoid process_text_hud_numbers( int i, inout int N,\n\t\t\t\t\t\t\t   inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n\t\t\t\t\t\t\t   GameState gs, PlanetState ps )\n{\n\tfloat left = g_textres.x \/ 4.;\n\tfloat right = g_textres.x * 3. \/ 4.;\n\tfloat y = g_textres.y \/ 2.;\n\tvec3 localv = ( VS.localv +\n\t\tcross( vec3( 0, 0, VS.modes.x == VS_HMD_ORB ? ps.omega : 0. ), VS.localr ) );\n\tfloat spd =\t length( localv );\n\tif( spd >= 0.0005 && i == N++ )\n\t{\n\t\t\/\/ speed\n\t\tparams = vec4( left - CW(4.,15.), y, 1, 15 );\n\t\tif( spd < 9.9995 )\n\t\t\tphrase = uvec4( 0x202020f5, 0, 0, 4 ), argv.x = 1000. * spd;\n\t\telse\n\t\tif( spd < 9999.995 )\n\t\t\tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = spd;\n\t\telse\n\t\t\tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = spd \/ 1000.;\n\t}\n\tif( LE.H != 0. )\n\t{\n\t\t\/\/ mach\n\t\tfloat mach = length( VS.localv ) \/ LE.atm.w;\n\t\tif( mach >= 0.005 && i == N++ )\n\t\t{\n\t\t\tparams = vec4( left - CW(2.,12.), y - 16., 1, 12 );\n\t\t\tphrase = uvec4( 0x4df90000, 0, 0, 2 );\n\t\t\targv.x = mach;\n\t\t}\n\t\t\/\/ dyn pressure\n\t\tfloat Q = .5 * ( 1e6 \/ 1e5 ) * LE.atm.z * dot( VS.localv, VS.localv );\n\t\tif( Q >= 0.005 && i == N++ )\n\t\t{\n\t\t\tparams = vec4( left -CW(2.,12.), y - 32., 1, 12 );\n\t\t\tphrase = uvec4( 0x51f90000, 0, 0, 2 );\n\t\t\targv.x = Q;\n\t\t}\n\t}\n\tif( i == N++ )\n\t{\n\t\t\/\/ altitude\n\t\tfloat alt = length( VS.localr ) - PD.radius;\n\t\tparams = vec4( right - CW(8.,15.), y, 1, 15 );\n\t\tif( alt < 9.9995 )\n\t\t\tphrase = uvec4( 0x202020f5, 0, 0, 4 ), argv.x = 1000. * alt;\n\t\telse\n\t\tif( alt < 9999.995 )\n\t\t\tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = alt;\n\t\telse\n\t\t\tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = alt \/ 1000.;\n\t}\n\tfloat vs = dot( localv, normalize( VS.localr ) );\n\tif( abs( vs ) >= 0.0000005 && i == N++ )\n\t{\n\t\t\/\/ vertical speed\n\t\tparams = vec4( right - CW(8.,12.), y - 15., 1, 12 );\n\t\tif( abs( vs ) < 9.9995 )\n\t\t\tphrase = uvec4( abs( vs ) < 0.00995 ? 0x202020f6 : 0x202020f5, 0, 0, 4 ), argv.x = 1000. * vs;\n\t\telse\n\t\tif( abs( vs ) < 9999.5 )\n\t\t\tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = vs;\n\t\telse\n\t\t\tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = vs \/ 1000.;\n\t}\n\tif( i == N++ )\n\t{\n\t\t\/\/ heading\n\t\tparams = vec4( g_textres.x \/ 2. - CW(1.5,12.), g_textres.y \/ 4., 1, 12 );\n\t\tphrase = uvec4( 0xf1000000, 0, 0, 1 );\n\t\targv.x = B2bearing( VS.localr, VS.localB[0] ) + .5;\n\t}\n\tif( i == N++ )\n\t{\n\t\t\/\/ g-load\n\t\tparams = vec4( g_textres.x \/ 2. - CW(3.5,12.), g_textres.y \/ 4. - 18., 1, 12 );\n\t\tphrase = uvec4( 0x47f90000, 0, 0, 2 );\n\t\targv.x = -1000. \/ FDM_STD_G * VS.acc.z;\n\t}\n\n\tbool trimdisplay =\n\t\tmax( keystate( KEY_CTRL ), keystate( KEY_META ) ) > 0. && ( VS.modes2.x != VS_AERO_OFF );\n\n\tif( trimdisplay && i == N++ )\n\t{\n\t\targv.x = 100. * VS.trim;\n\t\tparams = vec4( g_textres.x \/ 2. - CW(4.5,12.), g_textres.y \/ 4. - 36., 1, 12 );\n\t\tphrase = uvec4( 0x5452494d, abs( argv.x ) < 9.95 ? 0xf6000000 : 0xf4000000, 0, 5 );\n\t}\n}\n\nvoid process_text_time_accel( int i, inout int N,\n\t\t\t\t\t\t\t  inout vec4 params, inout uvec4 phrase, inout vec4 argv, FrameContext fr )\n{\n\tfloat y = 3. * g_textres.y \/ 4.;\n\tif( ( GS.switches & GS_PAUSE ) == GS_PAUSE )\n\t{\n\t\tif( i == N )\n\t\t\tparams = vec4( g_textres.x \/ 2., y, step( .5, fract( iTime ) ), 12 ),\n\t\t\tphrase = uvec4( 0x50415553, 0x45000000, 0, 5u | TXT_FMT_FLAG_CENTER );\n\t\tN++;\n\t}\n\telse\n\tif( fr.timeaccel > 1.0625 )\n\t{\n\t\tif( i == N )\n\t\t\tparams = vec4( g_textres.x \/ 2., y, step( .5, fract( iTime ) ), 12 ),\n\t\t\tphrase = uvec4( 0x54494d45, 0x20d7f500, 0, 7u | TXT_FMT_FLAG_CENTER ),\n\t\t\targv.x = fr.timeaccel;\n\t\tN++;\n\t}\n}\n\nvoid process_text_console( int i, inout int N,\n\t\t\t\t\t\t   inout vec4 params, inout uvec4 phrase, inout vec4 argv )\n{\n\tvec3 FSG_distance = abs( VS.FSG - ONE );\n\tFSG_distance.x = min( FSG_distance.x, abs( VS.FSG.x - 1.\/9. ) );\n\tFSG_distance.x = min( FSG_distance.x, abs( VS.FSG.x - 4.\/9. ) );\n\n\tvec3 FSG_light = max( vec3( .25 ),\n\t\t\t\t\t\t  min( step( FRACT_1_64, VS.FSG ),\n\t\t\t\t\t\t\t   max( vec3( step( .5, fract( iTime ) ) ),\n\t\t\t\t\t\t\t\t\t1. - step( FRACT_1_64, FSG_distance ) ) ) );\n\n\tfloat canopy_light = max( .25,\n\t\t\t\t\t\t\t  min( step( FRACT_1_64, VS.canopy ),\n\t\t\t\t\t\t\t\t   max( step( .5, fract( iTime ) ),\n\t\t\t\t\t\t\t\t\t\t1. - step( FRACT_1_64, 1. - VS.canopy ) ) ) );\n\n\tconst uvec2 aero_modes[] = uvec2[] (\n\t\tuvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x46425700, 3u | TXT_FMT_FLAG_CENTER )\n\t);\n\n\tconst uvec2 rcs_modes[] = uvec2[] (\n\t\tuvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x52415445, 4u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x4c564c48, 4u | TXT_FMT_FLAG_CENTER )\n\t);\n\n\tconst uvec2 thr_modes[] = uvec2[] (\n\t\tuvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER )\n\t);\n\n\tconst uvec2 eng_modes[] = uvec2[] (\n\t\tuvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x44525600, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x494d5000, 3u | TXT_FMT_FLAG_CENTER ),\n\t\tuvec2( 0x4e4f5641, 4u | TXT_FMT_FLAG_CENTER )\n\t);\n\n#if WORKAROUND_08_UINT2FLOAT\n\tfloat tvec_notch = float( int( ( VS.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT ) );\n#else\n\tfloat tvec_notch = float( ( VS.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT );\n#endif\n\tfloat tvec_target = vs_tvec_notches( tvec_notch );\n\tfloat tvec_distance = abs( VS.tvec - tvec_target );\n\tfloat tvec_light = max( step( .5, fract( iTime ) ), 1. - step( 2.5, tvec_distance ) );\n\n\tswitch( i - N )\n\t{\n\tcase 0:\n\t\targv.x = 100. * VS.throttle;\n\t#if WORKAROUND_04_VEC4\n\t\tparams = vec4( 32., 8., abs( sign( VS.throttle ) ), 12. );\n\t#else\n\t\tparams = vec4( 32, 8, abs( sign( VS.throttle ) ), 12 );\n\t#endif\n\t\tphrase = uvec4( abs( argv.x ) < 9.95 ? 0xf6000000 : 0xf4000000, 0, 0, 1 );\n\t\tbreak;\n\tcase 1:\n\t\tparams = vec4( 96, 8, 1, 12 );\n\t#if WORKAROUND_05_UVEC4\n\t\tphrase = uvec4( 0x13131313u, 0u, 0u, ( VS.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT | TXT_FMT_FLAG_RIGHT );\n\t#else\n\t\tphrase = uvec4( 0x13131313, 0, 0, ( VS.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT | TXT_FMT_FLAG_RIGHT );\n\t#endif\n\t\tbreak;\n\tcase 2: params = vec4( 104, 8, FSG_light.x, 15 ); phrase = uvec4( 0x46000000, 0, 0, 1 ); break;\n\tcase 3: params = vec4( 120, 8, FSG_light.y, 15 ); phrase = uvec4( 0x53000000, 0, 0, 1 ); break;\n\tcase 4: params = vec4( 136, 8, FSG_light.z, 15 ); phrase = uvec4( 0x47000000, 0, 0, 1 ); break;\n\tcase 5: params = vec4( 152, 8, ( VS.switches & VS_LIGHT ) == VS_LIGHT ? 1. : .25, 15 ); phrase = uvec4( 0x4c000000, 0, 0, 1 ); break;\n\tcase 6: params = vec4( 168, 8, canopy_light, 15 ); phrase = uvec4( 0x43000000, 0, 0, 1 ); break;\n\n\n\tcase 7: params = vec4( 200, 8, VS.modes2.x == 0 ? .25 : 1., 12 ); phrase = aero_modes[ clamp( VS.modes2.x, 0, 2 ) ].xxxy; break;\n\tcase 8: params = vec4( 232, 8, VS.modes2.y == 0 ? .25 : 1., 12 ); phrase = rcs_modes[ clamp( VS.modes2.y, 0, 3 ) ].xxxy; break;\n\t\/\/ case 9: params = vec4( 264, 8, VS.modes2.z == 0 ? .25 : 1., 12 ); phrase = thr_modes[ clamp( VS.modes2.z, 0, 1 ) ].xxxy; break;\n\tcase 10: params = vec4( 296, 8, VS.modes.z == 0 ? .25 : 1., 12 ); phrase = eng_modes[ clamp( VS.modes.z, 0, 3 ) ].xxxy; break;\n\t}\n\tN += 12;\n\n\tif( VS.tvec >= 2.5 && i == N++ )\n\t{\n\t\targv.x = tvec_target;\n\t\tparams = vec4( g_textres.x * .5 + 80., 8, 1, 12 );\n\t\tphrase = uvec4( tvec_light > 0. ? 0x564543f4 : 0x202020f4, 0, 0, 4 );\n\t}\n}\n\nvec3 fmt_time( int arg )\n{\n\tint hours = arg \/ 3600;\n\tint minutes = ( arg - 3600 * hours ) \/ 60;\n\tint seconds = arg - 60 * minutes - 3600 * hours;\n\treturn vec3( hours, minutes, seconds );\n}\n\nvoid process_text_info_page( int i, inout int N,\n\t\t\t\t\t\t\t inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n\t\t\t\t\t\t\t int pageno, GameState gs )\n{\n#define INFO1( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.x = (arg); }\n#define INFO2( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.xy = (arg); }\n#define INFO3( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.xyz = (arg); }\n\tfloat x = g_textres.x - 128.;\n\tfloat y = 64.;\n\tif( i == N++ )\n\t\tparams = vec4( x, y, -1, 12 ), phrase = md_load( iChannel0, MENU_INFO_BEGIN + pageno );\n\tif( i < N )\n\t\treturn;\n\ty -= 20. + 12. * float( ( i - N ) & 3 );\n\tparams = vec4( x, y, 1, 12 );\n\tif( pageno == GS_INFO_LOCATION )\n\t{\n\t\tvec4 loc = navb( VS.localr, VS.localB[0] ) - vec4( 0, 0, PD.radius, 0 );\n\t\tINFO1( 0x6c617420, 0xfeb30000, 0, 6, loc.x );\n\t\tINFO1( 0x6c6f6e67, 0xfeb30000, 0, 6, loc.y );\n\t\tINFO1( 0x616c7420, abs( loc.z ) < 9999.99995 ? 0xfe206b6d : ( loc.z \/= 1000., 0xfe204d6d ), 0, 8, loc.z );\n\t\tINFO1( 0x68646720, 0xfeb30000, 0, 6, loc.w );\n\t}\n\telse\n\tif( pageno == GS_INFO_WAYPOINT && gs.waypoint != ZERO )\n\t{\n\t\tvec2 arcdist = arc_distance( gs.waypoint, VS.localr );\n\t\tfloat eta = length( arcdist ) \/ length( VS.localv );\n\t\tINFO1( 0x62726720, 0xfeb30000, 0, 6, B2bearing( VS.localr, gs.waypoint - VS.localr ) );\n\t\tINFO1( 0x64737420, 0xfe206b6d, 0, 8, arcdist.x );\n\t\tINFO1( 0xb520fe20, 0x6b6d0000, 0, 6, arcdist.y );\n\t\tif( dot( VS.localv, VS.localv ) >= .25e-6 )\n\t\t\tif( eta < 8640000. )\n\t\t\t\t{ INFO3( 0x65746120, 0x2020f33a, 0xf03af020, 12, fmt_time( int( floor( eta ) ) ) ) }\n\t\t\telse\n\t\t\t\tINFO1( 0x65746120, 0xfe206400, 0, 7, eta \/ 86400. );\n\t}\n\telse\n\tif( pageno == GS_INFO_ORBIT )\n\t{\n\t\tKepler K = Kepler( 0., 0., 0., 0., 0. );\n\t\tfloat nu = kp_init( K, VS.orbitr, VS.orbitv, PD.GM );\n\t\tfloat ap = K.p \/ ( 1. - K.e ) - PD.radius;\n\t\tfloat pe = K.p \/ ( 1. + K.e ) - PD.radius;\n\t\tif( K.e < 0.99995 )\n\t\t\tINFO1( 0x41702020, abs( ap ) < 10000. ? 0xfe206b6d : ( ap \/= 1000., 0xfe204d6d ), 0, 8, ap );\n\t\tINFO1( 0x50652020, abs( pe ) < 10000. ? 0xfe206b6d : ( pe \/= 1000., 0xfe204d6d ), 0, 8, pe );\n\t\tINFO1( 0x65202020, 0xfe000000, 0, 5, K.e );\n\t\tif( K.e >= .00005 )\n\t\t\tINFO1( 0xb12020fe, 0xb3000000, 0, 5, degrees( nu ) );\n\t}\n\telse\n\tif( pageno == GS_INFO_GLIDE )\n\t{\n\t\tINFO1( 0x434c2020, 0xfe000000, 0, 5, VS.info.x );\n\t\tINFO1( 0x43442020, 0xfe000000, 0, 5, VS.info.y );\n\t\tINFO1( 0x4c2f4420, 0xfe000000, 0, 5, safediv( VS.info.x, VS.info.y ) );\n\t\tINFO1( 0xb02020fe, 0xb3000000, 0, 5, degrees( VS.info.z ) );\n\t}\n\telse\n\tif( pageno == GS_INFO_CONTROLS )\n\t{\n\t\tINFO1( 0x656c6576, 0xfe000000, 0, 5, VS.EAR.x * 100. );\n\t\tINFO1( 0x61696c20, 0xfe000000, 0, 5, VS.EAR.y * 100. );\n\t\tINFO1( 0x72756464, 0xfe000000, 0, 5, VS.EAR.z * 100. );\n\t\tINFO1( 0x7472696d, 0xfe000000, 0, 5, VS.trim * 100. );\n\t}\n\telse\n\tif( pageno == GS_INFO_AIR )\n\t{\n\t\tINFO1( 0x54202020, 0xfeb34300, 0, 7, LE.atm.x - 273.15 );\n\t\tfloat Q = 5. * LE.atm.z * dot( VS.localv, VS.localv );\n\t\t\/\/*\n\t\tif( LE.atm.y < .03125 || LE.atm.z < .03125 )\n\t\t{\n\t\t\tINFO1( 0x50202020, 0xfe206d62, 0x61720000, 10, 1000. * LE.atm.y );\n\t\t\tINFO1( 0x51202020, 0xfe206d62, 0x61720000, 10, 1000. * Q  );\n\t\t\tINFO1( 0xb22020fe, 0x20672f6d, 0xb4000000, 9, 1000. * LE.atm.z );\n\t\t}\n\t\telse\n\t\t\/\/*\/\n\t\t{\n\t\t\tINFO1( 0x50202020, 0xfe206261, 0x72000000, 9, LE.atm.y );\n\t\t\tINFO1( 0x51202020, 0xfe206261, 0x72000000, 9, Q );\n\t\t\tINFO1( 0xb22020fe, 0x206b672f, 0x6db40000, 10, LE.atm.z );\n\t\t}\n\t}\n\telse\n\tif( pageno == GS_INFO_TIME )\n\t{\n\t\tfloat tzone = round( navb( VS.localr, VS.localB[0] ).y \/ 15. );\n\t\tbool dots = fract( GS.datetime.x * 1440. * SECONDS_PER_MINUTE ) < .5;\n\t\tINFO2( 0x64617465, 0x2020f22d, 0xf0000000, 9, GS.datetime.zy + 1. );\n\t\tINFO2( 0x74696d65, 0x20202020, dots ? 0xf03af000 : 0xf020f000, 11,\n\t\t\tfmt_time( int( mod( 86400. * GS.datetime.x, 86400. ) ) ).xy );\n\t\tINFO3( 0x6c6f6361, 0x6c202020, dots ? 0xf03af020 : 0xf020f020,\n\t\t\t( tzone == 0. ? 11 : tzone < 0. ? 0x202df00f : 0x202bf00f ),\n\t\t\tvec3( fmt_time( int( mod( 86400. * GS.datetime.x + 3600. * tzone, 86400. ) ) ).xy, abs( tzone ) ) );\n\t}\n#undef INFO1\n#undef INFO2\n#undef INFO3\n}\n\nvoid process_text_map_markers( int i, inout int N,\n\t\t\t\t\t\t\t   inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n\t\t\t\t\t\t\t   GameState gs )\n{\n\tif( i == N )\n\t{\n\t\tparams = vec4( g_textres.x \/ 2. - CW(19.,15.) \/ 2., g_textres.y \/ 6., 1, 15 );\n\t\tphrase = uvec4( 0x102020fb, 0x206b6d20, 0x20202012, 12 );\n\t\tfloat ls = 2. * g_textres.x \/ g_textres.y * CW(19.,15.) \/ g_textres.x * PD.radius \/ gs.camzoom;\n\t\targv.x = ls;\n\t}\n\tN++;\n\tfloat x = g_textres.x - 160.;\n\tfloat y = g_textres.y - 24.;\n\tif( gs.waypoint != ZERO )\n\t{\n\t\tvec4 loc = navb( gs.waypoint, ZERO );\n\t\tswitch( i - N )\n\t\t{\n\t\tcase 0: params = vec4( x, y,\t   1, 12 ); phrase = uvec4( 0xa7000000, 0, 0, 1 ); break;\n\t\tcase 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;\n\t\tcase 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;\n\t\tcase 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - PD.radius; break;\n\t\t}\n\t\tN += 4;\n\t\ty -= 80.;\n\t}\n\tif( gs.mapmarker != ZERO )\n\t{\n\t\tvec4 loc = navb( gs.mapmarker, ZERO );\n\t\tswitch( i - N )\n\t\t{\n\t\tcase 0: params = vec4( x, y,\t   1, 12 ); phrase = uvec4( 0x4d61726b, 0x65720000, 0, 6 ); break;\n\t\tcase 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;\n\t\tcase 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;\n\t\tcase 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - PD.radius; break;\n\t\t}\n\t\tN += 4;\n\t}\n}\n\nvec4 process_text( int index,\n\t\t\t\t   int offs,\n\t\t\t\t   FrameContext fr,\n\t\t\t\t   GameState gs,\n\t\t\t\t   PlanetState ps )\n{\n\tint N = 0, i = index;\n\tvec4 params = vec4(0), argv = vec4(0);\n\tuvec4 phrase = uvec4(0);\n\n\tprocess_text_message_line( i, N, params, phrase, argv );\n\n\tif( gs.stage == GS_SELECT_LOCATION && gs.timer >= 3.5 )\n\t\tprocess_text_select_location( i, N, params, phrase, gs );\n\n\tif( gs.stage == GS_RUNNING )\n\t{\n\t\tif( gs.menustate.x > 0 )\n\t\t\tprocess_text_command_menu( i, N, params, phrase, gs );\n\n\t\tif( ( gs.switches & GS_TRMAP ) == 0u )\n\t\t{\n\t\t\tif( VS.modes.x > VS_HMD_OFF )\n\t\t\t{\n\t\t\t\tprocess_text_hud_numbers( i, N, params, phrase, argv, gs, ps );\n\n\t\t\t\tif( VS.modes.x >= VS_HMD_ORB )\n\t\t\t\t\tprocess_text_conj_gradients( i, N, params, phrase );\n\t\t\t}\n\n\t\t\tprocess_text_time_accel( i, N, params, phrase, argv, fr );\n\t\t\tprocess_text_console( i, N, params, phrase, argv );\n\n\t\t\tint infopage = int( gs.switches & GS_IPAGE_MASK ) >> GS_IPAGE_SHIFT;\n\t\t\tif( infopage > 0 && infopage < MENU_INFO_SIZE )\n\t\t\t\tprocess_text_info_page( i, N, params, phrase, argv, infopage, gs );\n\t\t}\n\t\telse\n\t\t\tprocess_text_map_markers( i, N, params, phrase, argv, gs );\n\t}\n\n\t\/*\n\t\/\/ debug numbers\n\t{\n\t\tvec4 debug = vec4(0);\n\n\t\t\/\/ AtmContext atm = atm_load( iChannel0, ADDR_ATMCONTEXTS + ivec2(1,0) );\n\t\t\/\/ debug = vec4( atm.r0, atm.htop, atm.r0 + atm.htop, length( gs.campos ) - PD.radius );\n\t\t\/\/ debug = vec4( log( GS.exposure ) \/ LN10, pow( GS.exposure, vec2( 1.42857143 ) ) * 41372.4866 );\n\t\t\/\/ debug = VS.info;\n\t\t\/\/ debug.xyz = VS.acc * 1000. \/ FDM_STD_G;\n\t\t\/\/ debug.xyz = VS.accz * 1000. \/ FDM_STD_G;\n\t\t\/\/ debug = VS.aerostuff;\n\t\t\/\/ debug.xyz = VS.rcsstuff;\n\t\t\/\/ debug = vec4( LE.phases, LE.atm2 );\n\t\t\/\/ debug.xyz = log( LE.atm.xyz ) \/ LN10;\n\t\t\/\/ debug.xyz = GS.vjoy;\n\t\t\/\/ debug.xyz = vec3( 1000. * iTimeDelta, 1. \/ iTimeDelta, iFrameRate );\n\n\t\t\/\/ debug.x = float( GS.switches & 255u );\n\t\t\/\/ debug.y = float( ( GS.switches >> 8 ) & 255u );\n\t\t\/\/ debug.z = float( ( GS.switches >> 16 ) & 255u );\n\n\t\t\/\/ debug.w = safediv( LE.atm2.y, .03 * 5.31 + LE.atm2.y );\n\n\t\t\/\/ const float VIS_EXPONENT = -.65;\n\t\t\/\/ const vec3  VIS_LIMITS = vec3( .0013, .94e-6, .0001 );\n\t\t\/\/ vec4 exposure;\n\t\t\/\/ exposure.xy = GS.exposure.xy;\n\t\t\/\/ exposure.zw = pow( GS.exposure + VIS_LIMITS.xy, vec2( VIS_EXPONENT ) );\n\t\t\/\/ #define barten(x) (pow( (x) + 0.32 * pow( (x), 1.\/.58 ), .58 ))\n\t\t\/\/ debug.x = 40000. * pow( exposure.x, 1.43 );\n\t\t\/\/ debug.y = 100. * pow( exposure.x * exposure.z, 1.43 );\n\t\t\/\/ debug.z = log2( barten( debug.x ) \/ barten( debug.x * .0003 ) );\n\t\t\/\/ debug.w = debug.z \/ log2( barten( debug.y ) \/ barten( debug.y * .0003 ) );\n\n\t\tfloat x = g_textres.x - 240.;\n\t\tfloat y = 64. - 20. - 12. * float( ( i - N ) & 3 );\n\t\tif( i >= N && i < N + 4 )\n\t\t{\n\t\t\tparams = vec4( x, y, 1, 12 );\n\t\t\tswitch( i - N )\n\t\t\t{\n\t\t\tcase 0: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.x; break;\n\t\t\tcase 1: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.y; break;\n\t\t\tcase 2: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.z; break;\n\t\t\tcase 3: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.w; break;\n\t\t\t}\n\t\t}\n\t\tN += 4;\n\t}\n\t\/\/*\/\n\n\treturn text_format( offs, params, phrase, argv );\n}\n\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAIN\n\/\/ ----------------------------------------------------------------------------\n\n\nint get_zone_index( vec3 r )\n{\n\tint k = -1;\n\tfloat mind = 1e36;\n\tvec3 rn = normalize(r);\n\tfor( int i = 0; i < LOC_DATA_COUNT; ++i )\n\t{\n\t\tvec4 zone = ld_load( iChannel1, ld_addr_b(i) ).zone;\n\t\tfloat d = lensq( zone.xyz - rn );\n\t\tif( d < mind )\n\t\t\tmind = d, k = i;\n\t}\n\treturn k;\n}\n\nconst int MODE_NONE\t\t\t= 0;\nconst int MODE_HEIGHT\t\t= 1;\nconst int MODE_RADIUS\t\t= 2;\nconst int MODE_NORMAL\t\t= 4;\nconst int MODE_ZONEINDEX\t= 8;\nconst int MODE_SCENEDATA\t= 16;\nconst int MODE_AO\t\t\t= 32;\n\nstruct TerrainEvalParams\n{\n\tint mode;\n\tvec3 r;\n\tfloat lod;\n\tmat2x3 TB;\n\tfloat eps;\n\tvec3 rn;\n};\n\nTerrainEvalParams get_trn_eval_params( inout vec4 fcolor, vec2 fcoord )\n{\n\tTerrainEvalParams trneval = TerrainEvalParams( 0, ZERO, 0., mat2x3(0), 0., ZERO );\n\n\tivec2 sc = ivec2( fcoord );\n\tif( sc.y < 2 )\n\t{\n\t\t\/\/ bottom letterbox space\n\t\tif( sc.x >= ADDR_B_SCENE_DATA && sc.x < ADDR_B_SCENE_DATA + SCENE_DATA_COUNT * SCENE_DATA_SIZE )\n\t\t{\n\t\t\t\/\/ scene data\n\t\t\tint index = ( sc.x - ADDR_B_SCENE_DATA ) \/ SCENE_DATA_SIZE;\n\t\t\tindex = clamp( index, 0, g_scene_data.length() - 1 );\n\t\t\tSceneData sd = g_scene_data[ index ];\n\t\t\tint locindex = int( sd.tybr.w );\n\t\t\tLocData ld = g_loc_data[ locindex ];\n\t\t\tvec3 locr = nav2r( vec3( ld.zone.xy, PD.radius ) );\n\t\t\tmat3 locB = bearing2B( locr, ld.zone.w );\n\t\t\tsd.navb.xy = r2nav( locr + locB[0] * sd.navb.x - locB[1] * sd.navb.y ).xy;\n\t\t\tif( int( sd.tybr.x ) == SCNOBJ_TYPE_RUNWAY )\n\t\t\t{\n\t\t\t\tsd.tybr.y *= sqrt( SCN_SCALE );\n\t\t\t\tsd.paramsB.x *= sqrt( SCN_SCALE );\n\t\t\t}\n\t\t\tsd_store( sd, ivec2( fcoord.y, ADDR_B_SCENE_DATA + SCENE_DATA_SIZE * index ), sc, fcolor );\n\t\t\tif( sc.x - ADDR_B_SCENE_DATA - SCENE_DATA_SIZE * index == 1 )\n\t\t\t{\n\t\t\t\ttrneval.mode = MODE_SCENEDATA;\n\t\t\t\ttrneval.rn = trneval.r = nav2r( vec3( sd.navb.xy, 1. ) );\n\t\t\t\ttrneval.lod = TRN_MAX_LEVELS;\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif( sc.x >= ADDR_B_LOC_DATA && sc.x < ADDR_B_LOC_DATA + LOC_DATA_COUNT * LOC_DATA_SIZE )\n\t\t{\n\t\t\t\/\/ location data\n\t\t\tint index = ( sc.x - ADDR_B_LOC_DATA ) \/ LOC_DATA_SIZE;\n\t\t\tindex = clamp( index, 0, g_loc_data.length() - 1 );\n\t\t\tLocData ld = g_loc_data[ index ];\n\t\t\tld.zone = vec4( nav2r( vec3( ld.zone.xy, 1 ) ), ld.zone.z * SCN_SCALE \/ PD.radius );\n\t\t\tld_store( ld, ld_addr_b( index ), sc, fcolor );\n\t\t}\n\t\telse\n\t\tif( sc.x >= ADDR_B_WAYPOINT_SAMPLE )\n\t\t{\n\t\t\t\/\/ terrain sample at waypoint (if available)\n\t\t\tif( GS.waypoint != ZERO )\n\t\t\t{\n\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_RADIUS;\n\t\t\t\ttrneval.rn = normalize( trneval.r = GS.waypoint );\n\t\t\t\ttrneval.lod = TRN_MAX_LEVELS - 2. * float( sc.x - ADDR_B_WAYPOINT_SAMPLE );\n\t\t\t}\n\t\t\t\/\/ also the effective text resolution for this frame\n\t\t\tfcolor.xy = g_textres;\n\t\t}\n\t\telse\n\t\t\/\/ if( sc.x >= ADDR_B_CAMPOS_SAMPLE )\n\t\t{\n\t\t\t\/\/ terrain sample at camera position\n\t\t\tif( GS.campos != ZERO )\n\t\t\t{\n\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_RADIUS | MODE_NORMAL;\n\t\t\t\ttrneval.rn = normalize( trneval.r = GS.campos );\n\t\t\t\ttrneval.lod = TRN_MAX_LEVELS - fcoord.x;\n\t\t\t\tvec3 rn = normalize( GS.campos );\n\t\t\t\ttrneval.TB[0] = normalize( reject( UNIT_Z, rn ) );\n\t\t\t\ttrneval.TB[1] = cross( rn, trneval.TB[0] );\n\t\t\t\ttrneval.eps = .0133 * SCN_SCALE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\tif( fcoord.y >= iResolution.y - 2. )\n\t{\n\t\t\/\/ top letterbox space: text processing\n\t\tint index = 2 * ( int( fcoord.x ) >> 4 ) + ( int( fcoord.y ) & 1 );\n\t\tint offs = int( fcoord.x ) & 15;\n\t\tvec4 dtime = memload( iChannel0, ADDR_DTIME, 0 );\n\t\tbool locallimit = length( VS.orbitr ) < 12. * PD.am.scale + log( PD.ap.ref.z ) + PD.radius;\n\t\tFrameContext fr = fr_init( dtime, locallimit );\n\t\tfcolor = process_text( index, offs, fr, GS, PS );\n\t}\n\telse\n\tif( ( GS.switches & GS_TRMAP ) == GS_TRMAP )\n\t{\n\t\t\/\/ main area: map display\n\t\tvec2 c = mix( iResolution.xy \/ 2., fcoord, g_subsample );\n\t\tif( all( lessThan( abs( c - iResolution.xy \/ 2. ), iResolution.xy \/ 2. ) ) )\n\t\t{\n\t\t\tvec4 r = gs_map_unproject( GS, c, iResolution.xy );\n\t\t\tif( abs( r.w ) < 1. )\n\t\t\t{\n\t\t\t\tfloat vrmode = texelFetch( iChannel2, ivec2(0,0), 0 ).w;\n\t\t\t#if WITH_TRN_SURFACE_AA && !WORKAROUND_11_MAP_CRASH\n\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_NORMAL | MODE_ZONEINDEX;\n\t\t\t#else\n\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_NORMAL;\n\t\t\t#endif\n\t\t\t\ttrneval.r = PD.radius * ( trneval.rn = r.xyz );\n\t\t\t\ttrneval.lod = log2( iResolution.y * GS.camzoom ) - TRN_LOD_BIAS - 2.5 * vrmode;\n\t\t\t\ttrneval.TB[0] = normalize( reject( UNIT_Z, trneval.rn ) );\n\t\t\t\ttrneval.TB[1] = cross( trneval.rn, trneval.TB[0] );\n\t\t\t\ttrneval.eps = .0133 * SCN_SCALE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\/\/ main area: terrain buffers\n\n\t\tvec4 mainbox = ts_box_main( iChannel1 );\n\t\tvec4 shadowbox = ts_box_shadow( iChannel1 );\n\n\t\tbool insidemain = ts_box_inside( mainbox, fcoord );\n\t\tbool insideshadow = ts_box_inside( shadowbox, fcoord );\n\n\t\tif( insidemain || insideshadow )\n\t\t{\n\t\t\tTrnSampler ts = ts_load( iChannel0, ADDR_LOCAL_TS );\n\t\t\tTrnSampler tslast = ts_load( iChannel0, ADDR_LOCAL_TS_LAST );\n\n\t\t\tbool samplestate_equal =\n\t\t\t\tiFrame >= 2 &&\n\t\t\t\tts_is_valid( tslast ) &&\n\t\t\t\tts.rn == tslast.rn &&\n\t\t\t\tts.e == tslast.e;\n\n\t\t\tif( insidemain )\n\t\t\t{\n\t\t\t\t\/\/ main elevation buffer\n\t\t\t\tif( samplestate_equal )\n\t\t\t\t\tfcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( fcoord.xy - mainbox.xy ) \/ mainbox.zw;\n\t\t\t\t\tvec4 poslod = ts_uv_inverse_lod( ts, uv );\n\t\t\t\t\tif( poslod.w > 0. )\n\t\t\t\t\t{\n\t\t\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_NORMAL | MODE_ZONEINDEX;\n\t\t\t\t\t\ttrneval.r = poslod.xyz;\n\t\t\t\t\t\ttrneval.lod = log2( mainbox.z * poslod.w ) - TRN_LOD_BIAS;\n\t\t\t\t\t\ttrneval.TB = ts.TB;\n\t\t\t\t\t\ttrneval.eps = max( SCN_SCALE * .0133, 2. * distance( poslod.xyz, GS.campos ) \/ ( mainbox.z * poslod.w ) );\n\t\t\t\t\t\ttrneval.rn = ts.rn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t#if WITH_TRN_SHADOW\n\t\t\telse\n\t\t\tif( insideshadow )\n\t\t\t{\n\t\t\t\t\/\/ shadow buffer\n\t\t\t\tvec3 L = le_load( iChannel0, ADDR_LOCAL_ENV ).L;\n\n\t\t\t\tbool resolutionchange =\n\t\t\t\t\ttexelFetch( iChannel1, ivec2( iResolution.y + 2., 2. ), 0 ).xy != iResolution.xy;\n\n\t\t\t\tbool irchange =\n\t\t\t\t\ttexelFetch( iChannel1, ivec2( iResolution.y + 2., 2. ), 0 ).z != LE.sunlight.y;\n\n\t\t\t\tbool lightdirchange =\n\t\t\t\t\tdot( texelFetch( iChannel1, ivec2( iResolution.y + 4., 2. ), 0 ).xyz, L ) < FRACT_4095_4096;\n\n\t\t\t\tbool shadowupdate = iFrame < 4 || !samplestate_equal || resolutionchange || irchange || lightdirchange;\n\n\t\t\t\tif( !ts_is_valid( tslast ) )\n\t\t\t\t\tfcolor = vec4( -SCN_ZFAR, -SCN_ZFAR + 1., 1, 1 );\n\t\t\t\telse\n\t\t\t\tif( fcoord.x < iResolution.y + 2. && fcoord.y < 4. )\n\t\t\t\t\tfcolor = vec4( shadowupdate );\n\t\t\t\telse\n\t\t\t\tif( !shadowupdate )\n\t\t\t\t\tfcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 );\n\t\t\t\telse\n\t\t\t\tif( fcoord.x < iResolution.y + 4. && fcoord.y < 4. )\n\t\t\t\t\tfcolor.xyz = vec3( iResolution.xy, LE.sunlight.y );\n\t\t\t\telse\n\t\t\t\tif( fcoord.x < iResolution.y + 6. && fcoord.y < 4. )\n\t\t\t\t\tfcolor.xyz = L;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( fcoord.xy - shadowbox.xy ) \/ shadowbox.zw;\n\t\t\t\t\tvec4 poslod = ts_uv_inverse_lod( ts, uv );\n\t\t\t\t\tif( poslod.w > 0. )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 result = ZERO;\n\t\t\t\t\t\tvec3 Z = normalize( poslod.xyz );\n\t\t\t\t\t\tfloat camheight = length( GS.campos );\n\t\t\t\t\t\tfloat lod = log2( shadowbox.z * poslod.w ) - TRN_LOD_BIAS;\n\t\t\t\t\t\tfloat elev = ts_sample( tslast, iChannel1, Z ).w;\n\t\t\t\t\t\tvec3 targetpoint = Z * ( elev + PD.radius );\n\t\t\t\t\t\tvec3 T = normalize( reject( L, Z ) );\n\t\t\t\t\t\tfloat dotLT = dot( L, T );\n\t\t\t\t\t\tfloat dotLZ = dot( L, Z );\n\t\t\t\t\t\tfloat sinalpha = sqrt( LE.sundisk );\n\t\t\t\t\t\tresult.x = result.y = elev;\n\t\t\t\t\t\tresult.z = 1.;\n\t\t\t\t\t\tif( dotLZ < FRACT_15_16 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 slopes = ( dotLZ + vec2( 1, -.1 ) * sinalpha ) \/ dotLT;\n\t\t\t\t\t\t\tfloat t = SCN_RAYCAST_SHADOW_TBIAS;\n\t\t\t\t\t\t\tfor( int i = 0, n = SCN_RAYCAST_SHADOW_MAX_ITER; i < n; ++i )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvec3 x = targetpoint + t * L;\n\t\t\t\t\t\t\t\tvec3 rn = normalize(x);\n\t\t\t\t\t\t\t\tvec4 tsmpl = ts_sample( tslast, iChannel1, rn );\n\t\t\t\t\t\t\t\tvec2 f = dot( rn, Z ) - dot( rn, T ) * slopes;\n\t\t\t\t\t\t\t\tvec2 umbra = tsmpl.w * f + PD.radius * ( f - vec2(1) );\n\t\t\t\t\t\t\t\tif( result.y < umbra.y )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\/*\n\t\t\t\t\t\t\t\t\tfloat s = ( elev - umbra.x ) \/ ( umbra.y - umbra.x );\n\t\t\t\t\t\t\t\t\tresult.x = min( result.x, umbra.y - ( umbra.y - elev ) \/ ( 1. - min( s, result.z ) ) );\n\t\t\t\t\t\t\t\t\tresult.y = umbra.y;\n\t\t\t\t\t\t\t\t\tresult.z = s;\n\t\t\t\t\t\t\t\t\t\/*\/\n\t\t\t\t\t\t\t\t\tresult.x = mix( max( umbra.x, result.x ), umbra.x, saturate( result.z ) );\n\t\t\t\t\t\t\t\t\tresult.y = umbra.y;\n\t\t\t\t\t\t\t\t\tresult.z = ( elev - umbra.x ) \/ ( umbra.y - umbra.x );\n\t\t\t\t\t\t\t\t\t\/\/*\/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt += ( 1. + .25 * dot( tsmpl.xyz, L ) ) * max( t * sinalpha, SCN_RAYCAST_SHADOW_MIN_ADVANCE + t * SCN_RAYCAST_SHADOW_MIN_ADVANCE_SCALE );\n\t\t\t\t\t\t\t\tif( t >= SCN_ZFAR || ( dot( L, rn ) >= 0. && tsmpl.w >= PD.radius * PD.trn.levels.y ) )\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\/\/ x: min height of umbra\n\t\t\t\t\t\t\/\/ y: max height of umbra\n\t\t\t\t\t\t\/\/ z: AO\n\t\t\t\t\t\tfloat D = max( SCN_RAYCAST_SHADOW_HBIAS, SCN_RAYCAST_SHADOW_HSCALE * distance( targetpoint, GS.campos ) );\n\t\t\t\t\t\tfcolor.xy = result.xy - D * vec2( 1. + FRACT_1_64, 1 ) + PD.radius;\n\t\t\t\t\t\tfcolor.z = elev;\n\t\t\t\t\t\ttrneval.mode = MODE_AO;\n\t\t\t\t\t\ttrneval.rn = trneval.r = Z;\n\t\t\t\t\t\ttrneval.lod = lod - TRN_AO_LOD_OFFSET;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t#endif \/\/ TRN_SHADOW\n\t\t}\n\n\t#if WITH_TRN_AUX\n\t\telse\n\t\tfor( int i = 0; i < 1; ++i )\n\t\t{\n\t\t\tvec4 auxbox = ts_box_aux( iChannel1, float(i) );\n\n\t\t\tif( ts_box_inside( auxbox, fcoord ) )\n\t\t\t{\n\t\t\t\t\/*\n\t\t\t\tbool samplestate_equal = true;\n\n\t\t\t\tif( samplestate_equal )\n\t\t\t\t\tfcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 );\n\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( fcoord.xy - auxbox.xy ) \/ auxbox.zw;\n\t\t\t\t\tvec4 poslod = ts_uv_inverse_lod( ts, uv );\n\t\t\t\t\tif( poslod.w > 0. )\n\t\t\t\t\t{\n\t\t\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_NORMAL | MODE_ZONEINDEX;\n\t\t\t\t\t\ttrneval.r = poslod.xyz;\n\t\t\t\t\t\ttrneval.lod = log2( auxbox.z * poslod.w ) - TRN_LOD_BIAS;\n\t\t\t\t\t\ttrneval.TB = ts.TB;\n\t\t\t\t\t\ttrneval.eps = max( SCN_SCALE * .0133, 2. * distance( poslod.xyz, GS.campos ) \/ ( auxbox.z * poslod.w ) );\n\t\t\t\t\t\ttrneval.rn = ts.rn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t#endif \/\/ TRN_AUX\n\t}\n\n\treturn trneval;\n}\n\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{\n\tfcolor = vec4( ZERO, 0 );\n\n#if BUFFER_RUNLEVEL >= 2\n#if WITH_TERRAIN\n\n\tGS = gs_load( iChannel0, ADDR_GAME_STATE );\n\tVS = vs_load( iChannel0, ADDR_VEHICLE_STATE );\n\tPS = ps_load( iChannel0, ps_addr(1) );\n\tPD = pd_load( iChannel0, pd_addr(1) );\n\tLE = le_load( iChannel0, ADDR_LOCAL_ENV );\n\tg_subsample\t = gs_get_subsample( GS );\n\n\tbool vrmode = bool( texelFetch( iChannel2, ivec2(0,0), 0 ).w );\n\tg_textres = vrmode ?\n\t\tiResolution.xy * inversesqrt( iResolution.y \/ 150. ) :\n\t\tiResolution.xy * inversesqrt( iResolution.y \/ 450. );\n\n\tTerrainEvalParams trneval = get_trn_eval_params( fcolor, fcoord );\n\n\tif( trneval.mode != 0 )\n\t{\n\t\tint zoneindex = get_zone_index( trneval.r );\n\t\tvec4 zone = ld_load( iChannel1, ld_addr_b( zoneindex ) ).zone;\n\t\ttrneval.lod = min( trneval.lod, TRN_MAX_LEVELS );\n\t\tfloat h = trn_elevation( trneval.r, trneval.lod, PD, zone );\n\n\t\tif( ( trneval.mode & MODE_HEIGHT ) != 0 )\n\t\t\tfcolor.w = h;\n\n\t\tif( ( trneval.mode & MODE_RADIUS ) != 0 )\n\t\t\tfcolor.w += PD.radius;\n\n\t\tif( ( trneval.mode & MODE_NORMAL ) != 0 )\n\t\t{\n\t\t\tvec2 dhdp = vec2(\n\t\t#if WITH_TRN_CENTRAL_DIFF\n\t\t\t\ttrn_elevation( trneval.r + .5 * trneval.eps * trneval.TB[0], trneval.lod, PD, zone ) -\n\t\t\t\ttrn_elevation( trneval.r - .5 * trneval.eps * trneval.TB[0], trneval.lod, PD, zone ),\n\t\t\t\ttrn_elevation( trneval.r + .5 * trneval.eps * trneval.TB[1], trneval.lod, PD, zone ) -\n\t\t\t\ttrn_elevation( trneval.r - .5 * trneval.eps * trneval.TB[1], trneval.lod, PD, zone )\n\t\t#else\n\t\t\t\ttrn_elevation( trneval.r + trneval.eps * trneval.TB[0], trneval.lod, PD, zone ) - h,\n\t\t\t\ttrn_elevation( trneval.r + trneval.eps * trneval.TB[1], trneval.lod, PD, zone ) - h\n\t\t#endif\n\t\t\t) \/ trneval.eps;\n\t\t\tfcolor.xyz = normalize( normalize( trneval.r ) - trneval.TB * dhdp );\n\t\t}\n\n\t\tif( ( trneval.mode & MODE_ZONEINDEX ) != 0 )\n\t\t{\n\t\t\tfcolor.xy = reject_max( fcolor.xyz, trneval.rn ) * trneval.TB;\n\t\t\tfcolor.z = float( zoneindex );\n\t\t}\n\n\t\tif( ( trneval.mode & MODE_SCENEDATA ) != 0 )\n\t\t\tfcolor.z += h;\n\n\t\tif( ( trneval.mode & MODE_AO ) != 0 )\n\t\t{\n\t\t\tfloat aoscale = PD.radius * exp2( - TRN_AO_LOD_OFFSET \/ 2. - trneval.lod );\n\t\t\tfcolor.z = aoscale \/ ( aoscale + max( 0., h - fcolor.z ) );\n\t\t}\n\t}\n\n#endif \/\/ TERRAIN\n#endif \/\/ RUNLEVEL\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 4 of 6: Buffer C shader (atmospheric scattering)\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\/\n\n\/\/ ----------------------------------------------------------------------------\n\n#if WITH_ATM_TWEAKS\nconst float TWEAK1 = .25;\nconst float TWEAK2 = 4.;\nconst float TWEAK3 = .5;\nconst float TWEAK4 = .25;\nconst float TWEAK5 = .25;\nconst float TWEAK6 = .25;\nconst float TWEAK7 = 32.;\nconst float TWEAK8 = .25;\n#else\nconst float TWEAK1 = .5;\nconst float TWEAK2 = 6.0;\nconst float TWEAK3 = .7;\nconst float TWEAK4 = .5;\nconst float TWEAK5 = .25;\t\/\/ 0.125\nconst float TWEAK6 = .125;\nconst float TWEAK7 = 48.;\nconst float TWEAK8 = .5;\n#endif\n\nGameState GS;\nLocalEnv LE;\nTrnSampler TS;\nAtmContext AC;\nPlanetData PD;\n\/\/ PlanetState PS;\n\nfloat g_subsample = SCN_SUBSAMPLE;\nfloat g_pixelscale = 1.;\nbool g_vrmode = false;\nmat3 g_vrframe = mat3(0);\n\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ CLOUD NOISE SHAPE\n\/\/ ----------------------------------------------------------------------------\n\nconst float ATM_CLOUD_DENS_BIAS = -0.0005;\nconst float ATM_CLOUD_MAX_BETA = -log( 1. + ATM_CLOUD_DENS_BIAS );\n\nfloat cld_alt = 0.;\nfloat cld_k50max = 0.;\nfloat cld_g = 0.;\nfloat cld_f = 0.;\nvec4  cld_noise = vec4(0);\nvec2  cld_size = vec2(0);\nvec3  cld_fluff = ZERO;\nvec4  cld_move = vec4(0);\n\n\nmat2 cld_fluff_rot = mat2(1);\n\n#if WITH_CLOUDS\nfloat atm_cloudnoise1( vec4 r, bool lowfreq )\n{\n\tfloat lod = log2( r.w );\n\tfloat y = ( textureLod( iChannel3, r.xyz \/ 32., lod ).x + 2. * textureLod( iChannel3, r.xyz \/ 64., lod - 1. ).x ) \/ 3.;\n\tif( !lowfreq )\n\t\ty = 4. \/ 5. * y + ( textureLod( iChannel3, r.xyz \/ 8., lod + 2. ).x + 2. * textureLod( iChannel3, r.xyz \/ 16., lod + 1. ).x ) \/ 15.;\n\treturn y;\n}\nvec3 atm_cloudnoise1_offs( vec4 r, bool lowfreq )\n{\n\tfloat lod = log2( r.w );\n\tconst vec2 offs = vec2( 1, 0 );\n\tvec3 offs_y = vec3(\n\t\ttextureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 64., lod - 1. ).x ) \/ 3.;\n\tif( !lowfreq )\n\t\toffs_y = 4. \/ 5. * offs_y + vec3(\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 16., lod + 1. ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 16., lod + 1. ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 16., lod + 1. ).x ) \/ 15.;\n\treturn offs_y;\n}\nfloat atm_cloudnoise2( vec4 r, bool lowfreq )\n{\n\tfloat lod = log2( r.w );\n\tfloat y = textureLod( iChannel3, r.xyz \/ 64., lod - 1. ).x;\n\tif( !lowfreq )\n\t\ty = 2. \/ 3. * y + textureLod( iChannel3, r.xyz \/ 32., lod ).x \/ 3.;\n\treturn y;\n}\nvec3 atm_cloudnoise2_offs( vec4 r, bool lowfreq )\n{\n\tfloat lod = log2( r.w );\n\tconst vec2 offs = vec2( 1, 0 );\n\tvec3 offs_y = vec3(\n\t\ttextureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 64., lod - 1. ).x );\n\tif( !lowfreq )\n\t{\n\t\toffs_y = 2. \/ 3. * offs_y + vec3(\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.xyy ) \/ 32., lod ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) \/ 32., lod ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) \/ 32., lod ).x ) \/ 3.;\n\t}\n\treturn offs_y;\n}\nvec4 atm_cloudnoise1_d( vec4 r, float scale, bool lowfreq )\n{\n\tfloat invscale = 1. \/ scale;\n\tfloat y = atm_cloudnoise1( invscale * r, lowfreq );\n\treturn vec4( invscale * ( atm_cloudnoise1_offs( invscale * r, lowfreq ) - y ), y );\n}\nvec4 atm_cloudnoise2_d( vec4 r, float scale, bool lowfreq )\n{\n\tfloat invscale = 1. \/ scale;\n\tfloat y = atm_cloudnoise2( invscale * r, lowfreq );\n\treturn vec4( invscale * ( atm_cloudnoise2_offs( invscale * r, lowfreq ) - y ), y );\n}\n\nvec4 atm_cloudbeta_d( vec4 r, bool lowfreq )\n{\n\tvec4 rn = length_normalize( r.xyz );\n\tvec4 h = rn - const_d( AC.r0 ) - const_d( cld_alt );\n\tvec4 fluff = mix_d( const_d( cld_fluff.x ), const_d( cld_fluff.y ), saturate_d( h \/ cld_fluff.z ) );\n\tvec3 y = rn.xyz;\n\ty.xy = ( y.xy \/* + 0. * cld_move.z * GS.timer *\/ ) * cld_fluff_rot;\n\tfloat sin2lat = rn.z * rn.z * 2. - 1.;\n\tfloat sin3lat = sin2lat * rn.z * 2. - rn.z;\n\tvec3 x = vec3( rn.xy, sin3lat \/ 3. + cld_move.y * GS.timer + cld_move.x );\n\tvec4 n1 = atm_cloudnoise1_d( vec4( PD.radius * x, r.w ), cld_size.x, lowfreq );\n\tvec4 n2 = atm_cloudnoise2_d( vec4( PD.radius * y, r.w ), cld_size.y, lowfreq );\n\tvec4 c = + const_d( cld_noise.x )\n\t\t\t + const_d( cld_noise.y * sin3lat * sin3lat )\n\t\t\t + cld_noise.z * n1\n\t\t\t - 6. * sqrt_d( ONE_D + square_d( cld_noise.w * h \/ 6. ) )\n\t\t\t + mul_d( fluff, n2 * 2. - ONE_D );\n\treturn min_d( const_d( ATM_CLOUD_MAX_BETA ), c );\n}\n\nfloat cld_tau50( vec4 x, vec4 dx, float tau50limit, bool lowfreq )\n{\n\tvec4 dxdu = dx \/ length( dx.xyz );\n\tfloat tau50 = 0.;\n\tfloat beta = atm_cloudbeta_d( x, lowfreq ).w;\n\tfloat dens = exp2pp( LOG2E * beta );\n\tfloat betachange = 1. \/ cld_noise.w;\n\tfor( int i = 0, n = ATM_CLOUD_MAX_ITER; i < n; ++i )\n\t{\n\t\tfloat du = TWEAK3 * atm_dulimit( TWEAK4, betachange, cld_k50max * dens );\n\t\tdu = du * min( TWEAK7, 1. + tau50 * tau50 \/ 8. );\n\t\tdu = max( 0.005, du );\n\t\tx += du * dxdu;\n\t\tfloat betanext = atm_cloudbeta_d( x, lowfreq ).w;\n\t\tfloat densnext = exp2pp( LOG2E * betanext );\n\t\ttau50 += cld_k50max * max( 0., mix( dens, densnext, .5 ) + ATM_CLOUD_DENS_BIAS ) * du;\n\t\tbetachange = du \/ max( du * ( TWEAK5 * cld_noise.w ), abs( betanext - beta ) );\n\t\tbeta = betanext;\n\t\tdens = densnext;\n\t\tif( tau50 >= tau50limit )\n\t\t\tbreak;\n\t\tfloat alt = length( x.xyz );\n\t\tif( dot( x.xyz, dxdu.xyz ) >= 0. && alt >= PD.radius * ( 1. + PD.trn.levels.y ) )\n\t\t\tbreak;\n\t\tif( dot( x.xyz, dxdu.xyz ) < 0. && alt < PD.radius * ( 1. + PD.trn.levels.x ) )\n\t\t\tbreak;\n\t}\n\treturn tau50;\n}\n#endif\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE MODEL\n\/\/ ----------------------------------------------------------------------------\n\nstruct AtmQuadraturePoint\n{\n\tfloat coschi;\t\t\t\/\/ light zenith angle\n\tfloat dens;\t\t\t\t\/\/ density relative to reference\n\tfloat amtl;\t\t\t\t\/\/ airmass towards lightsource (sun)\n  #if WITH_ATM_LAYER_G\n\tfloat densg;\t\t\t\/\/ same for ground layer\n\tfloat amtlg;\n  #endif\n  #if WITH_ATM_LAYER_A\n\tfloat densa;\t\t\t\/\/ same for absorbtion layer\n\tfloat amtla;\n  #endif\n  #if WITH_ATM_LAYER_E\n\tfloat dense;\t\t\t\/\/ same for emission layer\n  #endif\n\tfloat shadow;\t\t\t\/\/ amount of terrain shadowing\n\tfloat h50;\n  #if WITH_ATM_AMTL_CORRECTION\n\tfloat cosbeta;\n  #endif\n};\n\nfloat eval_gaussian50( float x, vec3 shape )\n\t{ return shape.y * exp2pp( -shape.z * square( x - shape.x ) ); }\n\nAtmQuadraturePoint atm_quadrature_point( vec3 x, vec3 L, vec3 dxn )\n{\n\tAtmQuadraturePoint result;\n\tvec4 xn = length_normalize(x);\n\tfloat x50 = xn.w * AC.invH50;\n\tfloat h50 = x50 - AC.X50;\n\tresult.coschi = dot( xn.xyz, L );\n#if WITH_ATMOSPHERE\n\tresult.dens = exp2pp( -h50 );\n\tfloat s = AC.X50 \/ x50;\n\tfloat c = sqrt( max( 0., 1. - s * s ) );\n\tfloat planetshadow = atm_planet_shadow( result.coschi, c, sqrt( LE.sundisk ) );\n\tresult.shadow = planetshadow * ts_shadow_sample( TS, iChannel1, xn ).x;\n\tresult.amtl = planetshadow >= 0.003 ? atm_chapman50_h( AC.X50, h50, result.coschi ) : 1e6;\n  #if WITH_ATM_LAYER_G\n\tresult.densg = AC.glayer_scale * exp2pp( -h50 * AC.glayer_scale );\n\tresult.amtlg = planetshadow >= 0.003 ? atm_chapman50_h( AC.X50 * AC.glayer_scale, h50 * AC.glayer_scale, result.coschi ) : 1e6;\n  #endif\n  #if WITH_ATM_LAYER_A\n\tresult.densa = eval_gaussian50( h50, AC.alayer_shape );\n\tresult.amtla = ac_tau_layer_a( AC, x * AC.invH50, L );\n  #endif\n  #if WITH_ATM_LAYER_E\n\tresult.dense = eval_gaussian50( h50, AC.elayer_shape );\n  #endif\n\tresult.h50 = h50;\n  #if WITH_ATM_AMTL_CORRECTION\n\tresult.cosbeta = c;\n  #endif\n#else\n\tresult.dens = 0.;\n\tresult.shadow = 1.;\n#endif\n\treturn result;\n}\n\nAtmQuadraturePoint atm_quadrature_mix( AtmQuadraturePoint a, AtmQuadraturePoint b,\n\t\t\t\t\t\t\t\t\t   float t )\n{\n\tAtmQuadraturePoint result;\n\tresult.coschi = mix( a.coschi, b.coschi, t );\n\tresult.dens = mix( a.dens, b.dens, t );\n\tresult.amtl = mix( a.amtl, b.amtl, t );\n  #if WITH_ATM_LAYER_G\n\tresult.densg = mix( a.densg, b.densg, t );\n\tresult.amtlg = mix( a.amtlg, b.amtlg, t );\n  #endif\n  #if WITH_ATM_LAYER_A\n\tresult.densa = mix( a.densa, b.densa, t );\n\tresult.amtla = mix( a.amtla, b.amtla, t );\n  #endif\n  #if WITH_ATM_LAYER_E\n\tresult.dense = mix( a.dense, b.dense, t );\n  #endif\n\tresult.shadow = mix( a.shadow, b.shadow, t );\n\tresult.h50 = mix( a.h50, b.h50, t );\n  #if WITH_ATM_AMTL_CORRECTION\n\tresult.cosbeta = mix( a.cosbeta, b.cosbeta, t );\n  #endif\n\treturn result;\n}\n\nstruct AtmQuadratureSegment\n{\n\tvec3 mu0;\t\t\t\t\/\/ cosine of light incidence angle\n\tvec3 omega0;\t\t\t\/\/ local single-scattering albedo\n\tvec3 k50;\t\t\t\t\/\/ half-value extinction efficiency\n\tvec3 tau50;\t\t\t\t\/\/ half-value optical depth\n\tvec3 T;\t\t\t\t\t\/\/ transmittance\n\tvec3 TL;\t\t\t\t\/\/ transmittance in light direction\n\tvec3 TZ;\t\t\t\t\/\/ transmittance in zenith direction\n\tvec3 TZs;\t\t\t\t\/\/ transmittance in zenith direction, diffusion-scaled\n\tvec3 Is;\t\t\t\t\/\/ single scatter contribution\n\tvec3 Im;\t\t\t\t\/\/ multi scatter contribution\n\tvec3 Ie;\t\t\t\t\/\/ emission\n#if WITH_CLOUDS\n\tvec3 skylight;\t\t\t\/\/ analytical skylight estimate\n#endif\n};\n\nAtmQuadratureSegment atm_quadrature_segment( AtmQuadraturePoint avg,\n\t\t\t\t\t\t\t\t\t\t\t float du,\n\t\t\t\t\t\t\t\t\t\t\t float rayleigh_phase,\n\t\t\t\t\t\t\t\t\t\t\t float aerosol_phase,\n\t\t\t\t\t\t\t\t\t\t\t bool infinite )\n{\n\tAtmQuadratureSegment result;\n\tvec3 mu_stretch = AC.mu_stretch * mix( 1.25, 1., saturate( avg.h50 ) );\n\tresult.mu0 = log2( 1. + exp2pp( mu_stretch * avg.coschi ) ) \/ mu_stretch;\n#if WITH_ATMOSPHERE\n\tvec3 k50 = AC.k50 * avg.dens;\n\tvec3 k50_s = AC.k50_s * avg.dens;\n  #if WITH_ATM_LAYER_G\n\tk50 += ( avg.densg - avg.dens ) * AC.glayer_k50;\n\tk50_s += ( avg.densg - avg.dens ) * AC.glayer_k50_s;\n  #endif\n  #if WITH_ATM_LAYER_A\n\tk50 += ( avg.densa - avg.dens ) * AC.alayer_k50;\n  #endif\n\tresult.omega0 = k50_s \/ k50;\n\tresult.k50 = k50;\n\tresult.tau50 = result.k50 * du;\n\tresult.T = exp2pp( -result.tau50 );\n\tresult.TL = AC.k50 * avg.amtl;\n  #if WITH_ATM_LAYER_G\n\tresult.TL += AC.glayer_k50 * ( avg.amtlg - avg.amtl );\n  #endif\n  #if WITH_ATM_LAYER_A\n\tresult.TL += AC.alayer_k50 * ( avg.amtla - avg.amtl );\n  #endif\n  #if WITH_ATM_AMTL_CORRECTION\n\tresult.TL *= atm_airmass_correction( AC.X50, avg.cosbeta + avg.coschi, ATM_AMTL_CORRECTION );\n  #endif\n\tresult.TL = exp2pp( -AC.H * result.TL );\n\tresult.Is = result.omega0 \/ 4.;\n  #if WITH_ATM_LAYER_G\n\tresult.Is += avg.dens * ( AC.k50_s - AC.glayer_k50_s ) * ( rayleigh_phase - 1. ) \/ ( 4. * k50 );\n\tresult.Is += avg.densg * AC.glayer_k50_s * ( aerosol_phase - 1. ) \/ ( 4. * k50 );\n  #endif\n\tresult.Is *= result.TL * LE.sunlight * avg.shadow;\n\tresult.TZ = exp2pp( -AC.tau50 * avg.dens );\n\tresult.TZs = exp2pp( -AC.tau50s * avg.dens );\n\tresult.Im = result.TZs * ( LE.sunlight * ( 1. - result.TL ) * result.mu0 * AC.omega0 + LE.starlight + AC.elayer_emiss ) * result.omega0;\n\tresult.Ie = ZERO;\n  #if WITH_ATM_LAYER_E\n\tresult.Ie += AC.elayer_emiss * avg.dense * AC.invH50 \/ k50;\n  #endif\n#else\n\tresult.k50 = ZERO;\n\tresult.tau50 = ZERO;\n\tresult.T = ONE;\n\tresult.TL = ONE;\n\tresult.TZ = ONE;\n\tresult.TZs = ONE;\n\tresult.Is = ZERO;\n\tresult.Im = ZERO;\n\tresult.Ie = ZERO;\n#endif\n#if WITH_CLOUDS\n\tvec3 ht = AC.ht0s50 + AC.X50 * avg.coschi * min( 0., avg.coschi ) \/ 2.;\n\tresult.skylight = ( result.TZ * LE.sunlight * exp2pp( -ht ) * AC.omega0 \/ 4. + result.Im * 2. ) * ( 1. - result.TZ );\n\tresult.skylight += ( LE.starlight + AC.elayer_emiss ) * result.TZs;\n#endif\n\treturn result;\n}\n\n#if WITH_CLOUDS\nstruct CldQuadraturePoint\n{\n\tvec4 beta;\t\t\t\t\/\/ log2 relative density, xyz = gradients\n\tfloat dens;\t\t\t\t\/\/ relative density\n\tfloat tau50L;\t\t\t\/\/ optical half-value depth in light direction\n\tfloat tau50Z;\t\t\t\/\/ optical half-value depth in zenith direction\n};\n\nCldQuadraturePoint cld_quadrature_point( vec4 x, vec3 L, float coschi )\n{\n\tCldQuadraturePoint result;\n\tresult.beta = atm_cloudbeta_d( x, false );\n\tresult.dens = exp2pp( LOG2E * result.beta.w );\n\tfloat taulimit = mix( ATM_CLOUD_SHADOW_MIN_TAU, ATM_CLOUD_SHADOW_MAX_TAU, coschi );\n\tvec3 xn = normalize( x.xyz );\n\tvec3 Lc = normalize( reject_min( L, xn ) );\n\tvec3 Z = normalize( L + xn );\n\tresult.tau50L = cld_tau50( x, vec4( Lc, sqrt( LE.sundisk ) ), taulimit, false );\n\tresult.tau50Z = cld_tau50( x, vec4( Z, 4. ), ATM_CLOUD_SHADOW_MIN_TAU, true );\n\treturn result;\n}\n\nCldQuadraturePoint cld_quadrature_mix( CldQuadraturePoint a,\n\t\t\t\t\t\t\t\t\t   CldQuadraturePoint b, float t )\n{\n\tCldQuadraturePoint result;\n\tresult.beta = mix( a.beta, b.beta, t );\n\tresult.dens = mix( a.dens, b.dens, t );\n\tresult.tau50L = mix( a.tau50L, b.tau50L, t );\n\tresult.tau50Z = mix( a.tau50Z, b.tau50Z, t );\n\treturn result;\n}\n\nstruct CldQuadratureSegment\n{\n\tfloat k50s;\t\t\t\t\/\/ half-value extinction efficiency, delta-scaled\n\tfloat tau50s;\t\t\t\/\/ half-value optical depth, delta-scaled\n\tfloat Ts;\t\t\t\t\/\/ segment transmittance, delta-scaled\n\tfloat TL;\t\t\t\t\/\/ transmittance in light direction\n\tfloat TLs;\t\t\t\t\/\/ same, delta-scaled\n\tfloat TZs;\t\t\t\t\/\/ transmittance in zenith direction, delta scaled\n\tfloat FminusL;\t\t\t\/\/ Eddington downwelling flux component for direct sunlight\n\tfloat FminusZ;\t\t\t\/\/ Eddington downwelling flux component for diffuse skylight\n\tvec3 Is;\t\t\t\t\/\/ single scatter contribution\n\tvec3 Im;\t\t\t\t\/\/ multi scatter contribution\n\tvec3 Ii;\t\t\t\t\/\/ indirect scattered skylight contribution\n};\n\nCldQuadratureSegment cld_quadrature_segment( CldQuadraturePoint avg,\n\t\t\t\t\t\t\t\t\t\t\t AtmQuadraturePoint atmavg,\n\t\t\t\t\t\t\t\t\t\t\t AtmQuadratureSegment atmseg,\n\t\t\t\t\t\t\t\t\t\t\t vec3 L,\n\t\t\t\t\t\t\t\t\t\t\t vec3 V,\n\t\t\t\t\t\t\t\t\t\t\t float du,\n\t\t\t\t\t\t\t\t\t\t\t float cloud_phase )\n{\n\tCldQuadratureSegment result;\n\tresult.k50s = cld_k50max * max( 0., avg.dens + ATM_CLOUD_DENS_BIAS ) * ( 1. - cld_f );\n\tresult.tau50s = result.k50s * du;\n\tresult.Ts = exp2pp( -result.tau50s );\n\tresult.TL = exp2pp( -avg.tau50L );\n\tresult.TLs = exp2pp( -avg.tau50L * ( 1. - cld_f ) );\n\tresult.TZs = exp2pp( -avg.tau50Z * ( 1. - cld_f ) );\n\tresult.FminusL = atm_delta_eddington_Fminus_direct( cld_g, avg.tau50L, atmseg.mu0.y );\n\tresult.FminusZ = atm_delta_eddington_Fminus_diffuse( cld_g, avg.tau50Z );\n\tvec3 N = softnormalize( -avg.beta.xyz, 1. \/ cld_noise.w );\n\tfloat H = .5 + 1. * mu_stretch( -dot( N, V ), .125 );\n\t\/\/ float H = 1.;\n\tvec3 mu0 = vec3( mu_stretch( dot( N, L ), .125 ) );\n\tmu0 = mix( atmseg.mu0, mu0, .5 );\n\tresult.Is = atmseg.TL * LE.sunlight * atmavg.shadow * result.TL * cloud_phase \/ 4.;\n\tresult.Im = H * atmseg.TL * LE.sunlight * atmavg.shadow * result.FminusL * mu0;\n\tresult.Ii = H * atmseg.skylight * result.FminusZ;\n\tif( ( GS.switches & GS_IRCAM ) != 0u )\n\t{\n\t\tresult.Is *= 0.85;\n\t\tresult.Im *= 0.85;\n\t\tresult.Ii *= 0.85;\n\t}\n\treturn result;\n}\n\nvec3 cld_atm_interaction( inout AtmQuadratureSegment atmseg,\n\t\t\t\t\t\t  AtmQuadraturePoint atmavg,\n\t\t\t\t\t\t  CldQuadratureSegment cldseg,\n\t\t\t\t\t\t  float coschi )\n{\n\tvec3 illum = atmseg.omega0 * ( cldseg.Is + cldseg.Im + cldseg.Ii ) \/ 2.;\n\tatmseg.Is = mix( illum, atmseg.Is, cldseg.TLs );\n\tatmseg.Im = atmseg.Im * cldseg.TZs;\n\treturn cldseg.k50s \/ ( atmseg.k50 + cldseg.k50s );\n}\n\nfloat cld_betachange( CldQuadraturePoint a, CldQuadraturePoint b, float du )\n\t{ return du \/ max( du * ( TWEAK5 * cld_noise.w ), b.beta.w - a.beta.w ); }\n\n#endif \/\/ WITH_CLOUDS\n\n\nfloat phase_hg( float g, float mu )\n\t{ return ( 1. - g * g ) \/ sqrt( cube( 1. + g * g - 2. * g * mu ) ); }\n\nfloat phase_p( float n, float mu )\n\t{ return 2. \/ ( LN2 * ( n + 1. ) * ( 1. + exp2(-n) - mu ) ); }\n\nfloat phase_e( float n, float mu )\n\t{ return LN2 * n * exp2( ( mu - 1. ) * n \/ 2. ); }\n\nfloat phase_f( float n, float mu )\n\t{ return mix( phase_p( n, mu ), phase_e( n + 1., mu ), .5 ); }\n\nfloat atm_compute_scatter( inout vec3 T, inout vec3 I,\n\t\t\t\t\t\t   vec4 x0, vec4 dx,\n\t\t\t\t\t\t   bool infinite,\n\t\t\t\t\t\t   bool low_aerosol_phase,\n\t\t\t\t\t\t   bool low_cloud_phase )\n{\n\tvec4 dxn = length_normalize( dx.xyz );\n\tvec4 dxdu = dx \/ dxn.w;\n\tvec2 sph = sphere_impact( x0.xyz, dxn.xyz );\n\tfloat R = AC.r0 + AC.htop;\n\tif( R * R < sph.x )\n\t\treturn 1.;\n\tvec2 limits = max( vec2(0), sphere_limits( R, sph ) );\n\tif( !infinite )\n\t\tlimits = min( vec2( dxn.w ), limits );\n\tfloat urange = limits.y - limits.x;\n\tif( urange < .001 )\n\t\treturn 1.;\n\n\t\/\/ TODO: vary water vapor content based on local temperature\n\n\t\/*\n\t{\n\t\tvec4 rn = length_normalize( x0.xyz + max( 0., sph.y ) * dxdu.xyz );\n\t\tvec3 rnxy = length_normalize( rn.xy );\n\t\tvec3 psrn = normalize( g_ps.r );\n\t\tvec3 pshn = normalize( cross( g_ps.r, g_ps.v ) );\n\t\tvec3 pshB = normalize( reject( g_ps.B[2], pshn ) );\n\t\tvec2 Lnxy = normalize( ( -g_ps.r * g_ps.B ).xy );\n\t\tvec2 lphase = vec2( rnxy.z, rn.z );\n\t\tvec2 sphase = vec2( dot( pshB, psrn ), dot( pshB, pshn ) );\n\t\tvec3 lvar = PD.atm_profile.lvar + PD.atm_profile.svar * sphase;\n\t\tfloat dT_l = dot( lvar.xy, lphase ) + lvar.z;\n\t\tfloat T = PD.atm_profile.ref.x + dT_l;\n\t}\n\t*\/\n\n\tfloat u = limits.x;\n\tvec4 x = x0 + u * dxdu;\n\tAtmQuadraturePoint atm1 = atm_quadrature_point( x.xyz, LE.L, dxn.xyz );\n\tbool ir = ( GS.switches & GS_IRCAM ) != 0u;\n\tfloat mu_L = dot( dxn.xyz, LE.L );\n\tfloat rayleigh_phase = .75 * ( 1. + mu_L * mu_L );\n\tfloat aerosol_phase = low_aerosol_phase ? 1. : min( ATM_CLOUD_SHADOW_MIN_TAU, phase_f( ir ? 5. : 6.5, mu_L ) );\n#if WITH_CLOUDS\n\tCldQuadraturePoint cld1 = cld_quadrature_point( x, LE.L, atm1.coschi );\n\tfloat cloud_phase = low_cloud_phase ? 1. : min( ATM_CLOUD_SHADOW_MIN_TAU, phase_f( ir ? 14. : 18., mu_L ) );\n\tfloat betachange = 1. \/ cld_noise.w;\n#endif\n\tfloat dumax = urange \/ float( ATM_SCATTER_MIN_ITER );\n\tfloat CT50s = 0.;\n\tfor( int i = 0, n = ATM_SCATTER_MAX_ITER; i < n; ++i )\n\t{\n\t\tfloat du = dumax;\n\t\tdu = min( du, TWEAK1 * atm_dulimit( TWEAK2, AC.H, AC.k50max * atm1.dens ) );\n\t#if WITH_CLOUDS\n\t\tdu = min( du, TWEAK3 * atm_dulimit( TWEAK4, betachange, cld_k50max * cld1.dens ) );\n\t#endif\n\t\tdu = min( dumax, du \/ max( TWEAK6, T.y ) );\n\t\tdu = min( max( 0.003, du ), limits.y - u );\n\t\tfloat unext = u + du;\n\t\tvec4 xnext = x0 + unext * dxdu;\n\t\tAtmQuadraturePoint atm2 = atm_quadrature_point( xnext.xyz, LE.L, dxn.xyz );\n\t  #if WITH_ATM_TRAPEZ_QUADRATURE\n\t\tAtmQuadraturePoint atmavg = atm_quadrature_mix( atm1, atm2, .5 );\n\t  #else\n\t\tAtmQuadraturePoint atmavg = atm2;\n\t  #endif\n\t\tAtmQuadratureSegment atmseg = atm_quadrature_segment( atmavg, du, rayleigh_phase, aerosol_phase, infinite );\n\t\tatm1 = atm2;\n\t#if WITH_CLOUDS\n\t\tCldQuadraturePoint cld2 = cld_quadrature_point( xnext, LE.L, atm2.coschi );\n\t  #if WITH_ATM_TRAPEZ_QUADRATURE\n\t\tCldQuadraturePoint cldavg = cld_quadrature_mix( cld1, cld2, .5 );\n\t  #else\n\t\tCldQuadraturePoint cldavg = cld2;\n\t  #endif\n\t\tCldQuadratureSegment cldseg = cld_quadrature_segment( cldavg, atmavg, atmseg, LE.L, dxdu.xyz, du, cloud_phase );\n\t\tvec3 cloud_mix = cld_atm_interaction( atmseg, atmavg, cldseg, atmavg.coschi );\n\t\tvec3 segment_I = mix( atmseg.Is + atmseg.Im + atmseg.Ie, cldseg.Is + cldseg.Im + cldseg.Ii, cloud_mix );\n\t\tvec3 segment_T = atmseg.T * cldseg.Ts;\n\t\tvec3 segment_tau50 = atmseg.tau50 + cldseg.tau50s;\n\t\tCT50s += cldseg.tau50s;\n\t\tbetachange = cld_betachange( cld1, cld2, du );\n\t\tcld1 = cld2;\n\t#else\n\t\tvec3 segment_I = atmseg.Is + atmseg.Im + atmseg.Ie;\n\t\tvec3 segment_T = atmseg.T;\n\t\tvec3 segment_tau50 = atmseg.tau50;\n\t#endif\n\t\tsegment_I *= mix( 1. - segment_T, LN2 * segment_tau50, lessThan( segment_tau50, vec3( FRACT_1_4096 ) ) );\n\t\tI = I + T * segment_I;\n\t\tT = T * segment_T;\n\t\tu = unext;\n\t\tif( u >= limits.y )\n\t\t\tbreak;\n\t\tx = xnext;\n\t\tif( CT50s >= ATM_CLOUD_TAU50_CUTOFF )\n\t\t\tbreak;\n\t\t\/\/ debug:\n\t\t\/\/ float value = float( i - ATM_SCATTER_MIN_ITER ) \/ float( ATM_SCATTER_MAX_ITER - ATM_SCATTER_MIN_ITER );\n\t\t\/\/ float value = betachange;\n\t\t\/\/ float value = log2(35.*du)\/10.;\n\t\t\/\/ float value = u \/ limits.y;\n\t\t\/\/ float value = CT50s \/ 1.;\n\t\t\/\/ I = mix( vec3(0,0,1), vec3(1,0,0), saturate( value ) );\n\t\t\/\/ vec3 value = T;\n\t\t\/\/ vec3 value = segment_T;\n\t\t\/\/ vec3 value = atm_transmittance( x0, dxn.xyz );\n\t\t\/\/ vec3 value = T \/ atm_transmittance( x0, dxn.xyz );\n\t\t\/\/ vec3 value = 1. - T;\n\t\t\/\/ I = value;\n\t\t\/\/ if( i == -1 )\n\t\t\/\/\t   break;\n\t}\n\n\tfloat Tc = clamp( ( exp2pp( -CT50s ) - ATM_CLOUD_T_CUTOFF ) \/ ( 1. - ATM_CLOUD_T_CUTOFF ), 0., 1. );\n\n\t\/*\n\tfloat K = .7 * fwidth( CT50s * LN2 );\n\tI.r *= 1. - aaa_interval( K, CT50s * LN2 - 1., K );\n\tI.rg *= 1. - aaa_interval( K, CT50s * LN2 - 3., K );\n\tI.rgb *= 1. - aaa_interval( K, CT50s * LN2 - 10., K );\n\t\/\/*\/\n\n\treturn Tc;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE\n\/\/ ----------------------------------------------------------------------------\n\nvec4 texturenoise( vec3 r )\n{\n\tvec3 uvw = r \/ iChannelResolution[3];\n\treturn texture( iChannel3, uvw ) * 2. - 1.;\n}\n\nvec4 texturenoiseLod( vec3 r, float lod )\n{\n\tvec3 uvw = r \/ iChannelResolution[3];\n\treturn textureLod( iChannel3, uvw, lod ) * 2. - 1.;\n}\n\nvec3 trn_ripplemap( vec3 pos )\n{\n\treturn .20 * texturenoise( pos \/ .01 ).xyz +\n\t\t   .30 * texturenoise( pos \/ .003 ).xyz +\n\t\t   .30 * texturenoise( pos \/ .001 ).xyz +\n\t\t   .20 * texturenoise( pos \/ .0003 ).xyz;\n}\n\nvec3 trn_ripplemapLod( vec3 pos, float scale )\n{\n\tfloat lod = log2( scale \/ 0.001 );\n\treturn .20 * texturenoiseLod( pos \/ .01, lod - 3.322 ).xyz +\n\t\t   .30 * texturenoiseLod( pos \/ .003, lod - 1.585 ).xyz +\n\t\t   .30 * texturenoiseLod( pos \/ .001, lod ).xyz +\n\t\t   .20 * texturenoiseLod( pos \/ .0003, lod + 1.585 ).xyz;\n}\n\nvec3 ndist( vec3 Z, float k, vec3 dZ )\n{\n\tfloat b = dot( Z, dZ );\n\treturn normalize( Z * square( 1. - k + k * b ) + k * ( dZ - Z * b ) );\n}\n\nfloat scene_raycast_terrain( Ray ray, float wlevel,\n\t\t\t\t\t\t\t inout float t0, inout vec3 r, int mode )\n{\n\tbool submerged = length( ray.o ) - PD.radius < wlevel;\n\tfloat t = 0., h = 0., alt = 0.;\n\tfloat lasth = 0., lastt = 0., lasta = 0.;\n\tvec4 tsmpl = vec4(0);\n\tfloat t_switch = pow( 0.0000005 * square( PD.radius ), .333333333 );\n\tfloat C0 = length( ray.o ) - PD.radius;\n\tfloat C1 = dot( ray.o, ray.d ) \/ length( ray.o );\n\tfloat C2 = ( lensq( ray.o ) * lensq( ray.d ) - square( dot( ray.o, ray.d ) ) ) \/ ( length( ray.o ) * lensq( ray.o ) );\n\tfor( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; ++i )\n\t{\n\t\tr = ray.o + t * ray.d;\n\t\ttsmpl = ts_sample( TS, iChannel1, normalize(r) );\n\t\tlasta = alt;\n\t\talt =\n#if WITH_TRN_HIGHP_RAYCAST\n\t\t\tt < t_switch ? C0 + t * C1 + t * t * C2 :\n#endif\n\t\t\tlength(r) - PD.radius;\n\t\tlasth = h;\n\t\th = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );\n\t\tif( h < 0. )\n\t\t{\n\t\t\tt = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );\n\t\t\tr = ray.o + t * ray.d;\n\t\t\treturn t;\n\t\t}\n\t\telse\n\t\tif( submerged && alt >= wlevel )\n\t\t{\n\t\t\tif( t0 > 0. )\n\t\t\t\tbreak;\n\t\t\tt = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );\n\t\t\tr = ray.o + t * ray.d;\n\t\t\tvec3 Z = normalize(r);\n\t\t\tvec3 N = ndist( Z, 1.5 * PD.ocn.Tds2.z, trn_ripplemap( r + 0.002 * iTime * Z ) );\n\t\t\tif( mode == 1 )\n\t\t\t{\n\t\t\t\tr = normalize( simple_refract( ray.d, N ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );\n\t\t\tray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );\n\t\t\tray.o = r;\n\t\t\tt0 = t;\n\t\t\tt = 0.;\n\t\t#if WITH_TRN_HIGHP_RAYCAST\n\t\t\tC0 = length( ray.o ) - PD.radius;\n\t\t\tC1 = dot( ray.o, ray.d ) \/ length( ray.o );\n\t\t\tC2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) \/ ( length( ray.o ) * lensq( ray.o ) );\n\t\t#endif\n\t\t\talt = wlevel;\n\t\t\th = wlevel - ts_sample( TS, iChannel1, Z ).w;\n\t\t}\n\t\tlastt = t;\n\t\tt += max( TRN_SAFE_SLOPE_FACTOR * ( 1. + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );\n\t\tif( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + PD.radius >= PD.radius * ( 1. + PD.trn.levels.y ) ) )\n\t\t\tbreak;\n\t}\n\treturn SCN_ZFAR;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAIN\n\/\/ ----------------------------------------------------------------------------\n\nconst int MODE_NONE\t =\t\t\t0;\nconst int MODE_INSCATTER =\t\t1;\t\t\/\/ trace inscatter ray along view direction\nconst int MODE_SKYLIGHT =\t\t2;\t\t\/\/ trace skylight sample for a terrain position\nconst int MODE_REFLECTION =\t\t3;\t\t\/\/ trace ocean reflection sample from view hitpoint\nconst int MODE_OBJECTS =\t\t4;\t\t\/\/ trace inscatter and skylight for scene objects\nconst int MODE_PRESERVE =\t\t99;\t\t\/\/ preserve previous value (do not overwrite)\n\nstruct RenderParams\n{\n\tint mode;\n\tvec4 x0;\n\tvec4 dx;\n\tfloat scale;\n\tbool infinite;\n\tbool low_aerosol_phase;\n\tbool low_cloud_phase;\n\tfloat t;\n};\n\nRenderParams get_render_params( Ray ray, int mode, vec2 fcoord )\n{\n\tRenderParams result = RenderParams( MODE_NONE, vec4(0), vec4(0), 1., true, false, false, 0. );\n\tfloat r0 = PD.radius;\n\tfloat lod = sqrt( g_pixelscale ) * 2.;\n\n\tif( mode == MODE_OBJECTS )\n\t{\n\t\tif( fcoord.y >= iResolution.y - 8. )\n\t\t{\n\t\t\tvec3 r = GS.campos;\n\t\t\tvec3 Z = normalize(r);\n\t\t\tvec3 sampledir = Z * 4. + LE.L;\n\t\t\tvec3 x = Z * max( r0, length(r) );\n\t\t\t\/\/ skylight sample at camera position\n\t\t\tresult.mode = MODE_SKYLIGHT;\n\t\t\tresult.x0 = vec4( x, lod * length( x - ray.o ) );\n\t\t\tresult.dx = vec4( sampledir, 4. );\n\t\t\tresult.low_aerosol_phase = true;\n\t\t\tresult.low_cloud_phase = true;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint index = int( fcoord.y ) \/ 2 - int( iResolution.y ) \/ 4;\n\t\t\tif( index >= 0 && index < int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ) )\n\t\t\t{\n\t\t\t\tSceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( index, 0 ) );\n\t\t\t\tif( int( obj.tybr.x ) >= SCNOBJ_TYPE_3D )\n\t\t\t\t{\n\t\t\t\t\tif( fcoord.x < iResolution.x - 6. )\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ in-scatter towards object position\n\t\t\t\t\t\tresult.mode = MODE_INSCATTER;\n\t\t\t\t\t\tresult.x0 = vec4( ray.o, 0 );\n\t\t\t\t\t\tresult.dx = vec4( obj.r - ray.o, lod * length( obj.r - ray.o ) );\n\t\t\t\t\t\tresult.infinite = false;\n\t\t\t\t\t\tresult.t = 0.;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 r = obj.r;\n\t\t\t\t\t\tvec3 Z = normalize(r);\n\t\t\t\t\t\tvec3 sampledir = normalize(\n\t\t\t\t\t\t\tfcoord.x < iResolution.x - 4. ? Z * .125 + normalize( reject( LE.L, Z ) ) :\n\t\t\t\t\t\t\tfcoord.x < iResolution.x - 2. ? Z * .125 - normalize( reject( LE.L, Z ) ) :\n\t\t\t\t\t\t\tZ );\n\n\t\t\t\t\t\tvec3 x = Z * max( r0, length(r) );\n\t\t\t\t\t\t\/\/ skylight sample at object position\n\t\t\t\t\t\tresult.mode = MODE_SKYLIGHT;\n\t\t\t\t\t\tresult.x0 = vec4( x, length( x - ray.o ) );\n\t\t\t\t\t\tresult.dx = vec4( sampledir, 4 );\n\t\t\t\t\t\tresult.low_aerosol_phase = true;\n\t\t\t\t\t\tresult.low_cloud_phase = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\tif( mode == MODE_SKYLIGHT )\n\t{\n\t\tvec4 box = ts_box_skylight( iChannel2 );\n\t\tvec2 uv = ( fcoord - box.xy ) \/ box.zw;\n\t\tvec4 poslod = ts_uv_inverse_lod( TS, uv );\n\t\tif( poslod.w > 0. )\n\t\t{\n\t\t\tvec3 Z = normalize( poslod.xyz );\n\t\t\tvec4 tsmpl = ts_unpack_normal( TS, ts_lookup( TS, iChannel1, ts_box_main( iChannel1 ), uv ) );\n\t\t\tvec3 N = normalize( tsmpl.xyz );\n\t\t\tvec3 sampledir = normalize( N * 2. + LE.L );\n\t\t\tvec3 x = Z * ( max( 0., tsmpl.w ) + r0 );\n\t\t\t\/\/ skylight sample on terrain map\n\t\t\tresult.mode = MODE_SKYLIGHT;\n\t\t\tresult.x0 = vec4( x, lod * length( x - ray.o ) );\n\t\t\tresult.dx = vec4( sampledir, 4 );\n\t\t\tresult.scale = .5 + .5 * dot( sampledir, N );\n\t\t\tresult.low_aerosol_phase = true;\n\t\t\tresult.low_cloud_phase = true;\n\t\t}\n\t}\n\telse\n\tif( dot( ray.d, ray.d ) > 0. )\n\t{\n\t\tbool submerged = length( ray.o ) < r0;\n\t\tvec3 r = ray.o + SCN_ZFAR * ray.d;\n\t\tfloat t0 = 0.;\n\t\t\/\/ todo: (1)\n\t\tfloat t = scene_raycast_terrain( ray, 0., t0, r, mode );\n\t\tvec3 Z = normalize(r);\n\t\tvec3 V = normalize( -ray.d );\n\t\tvec4 tsmpl = ts_sample( TS, iChannel1, Z );\n\t\tfloat h = tsmpl.w;\n\t\tfloat dh = fwidth(h);\n\t\ttsmpl.xyz = normalize( tsmpl.xyz );\n\n\t\tif( t >= SCN_ZFAR )\n\t\t{\n\t\t\tif( mode == MODE_INSCATTER )\n\t\t\t{\n\t\t\t\t\/\/ in-scatter along ray direction (terrain miss)\n\t\t\t\tresult.mode = MODE_INSCATTER;\n\t\t\t\tresult.x0 = vec4( submerged ? ray.o + t0 * ray.d : ray.o, 0 );\n\t\t\t\tresult.dx = vec4( submerged ? r : ray.d, lod );\n\t\t\t\tresult.t = t;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( mode == MODE_INSCATTER && !submerged )\n\t\t\t{\n\t\t\t\t\/\/ in-scatter along ray direction (terrain hit)\n\t\t\t\tresult.mode = MODE_INSCATTER;\n\t\t\t\tresult.x0 = vec4( ray.o, 0 );\n\t\t\t\tresult.dx = vec4( r - ray.o, lod * t );\n\t\t\t\tresult.infinite = false;\n\t\t\t\tresult.t = t;\n\t\t\t}\n\t\t\telse\n\t\t\tif( mode == MODE_REFLECTION && !submerged && h - FRACT_1_64 < 4. * dh )\n\t\t\t{\n\t\t\t\tvec3 N = ndist( Z, 1.5 * PD.ocn.Tds2.z, trn_ripplemap( r + 0.002 * iTime * Z ) );\n\t\t\t\tN = N + .35 * PD.ocn.Tds2.z * ( Z + V ) * parabolstep( 0., .250, t - t * dot( V, Z ) );\n\t\t\t\tN = normalize( N + V * mu_stretch( -dot( N, V ), .03125 ) );\n\t\t\t\tvec3 R = 2. * dot( N, V ) * N - V;\n\t\t\t\tR = normalize( R + Z * mu_stretch( -dot( R, Z ), .03125 ) );\n\t\t\t\tvec3 H = normalize( R + V );\n\t\t\t\tfloat fr = fresnel_schlick( .02, max( 0., dot( R, H ) ) );\n\t\t\t\t\/\/ reflection sample in view direction (ocean hit)\n\t\t\t\tfloat inva = .25 \/ PD.ocn.Tds2.z * inversesqrt( .0003 * inversesqrt( g_pixelscale ) \/ t + 1. ) ;\n\t\t\t\tresult.mode = MODE_REFLECTION;\n\t\t\t\tresult.x0 = vec4( r, lod * t );\n\t\t\t\tresult.dx = vec4( R, inva );\n\t\t\t\tresult.low_cloud_phase = true;\n\t\t\t\tresult.scale = fr;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nvec4 render( Ray ray, int mode, vec2 fcoord )\n{\n\tRenderParams params = get_render_params( ray, mode, fcoord );\n\tvec4 result = vec4( ZERO, 1 );\n\n\tif( params.dx != vec4(0) )\n\t{\n\t\tvec3 T = ONE, I = ZERO;\n\t#if WITH_ATMOSPHERE\n\t\tfloat Tc = atm_compute_scatter(\n\t\t\tT,\n\t\t\tI,\n\t\t\tparams.x0,\n\t\t\tparams.dx,\n\t\t\tparams.infinite,\n\t\t\tparams.low_aerosol_phase,\n\t\t\tparams.low_cloud_phase );\n\t#else\n\t\tfloat Tc = 1.;\n\t#endif\n\t\tswitch( params.mode )\n\t\t{\n\t\tcase MODE_INSCATTER:\n\t\t\tresult.xyz = I;\n\t\t\tresult.w = Tc;\n\t\t#if WITH_ATM_BILATERAL_UPSAMPLE\n\t\t\tif( params.t != 0. )\n\t\t\t{\n\t\t\t\tresult.xz = clamp( result.xz + FRACT_1_16777216, FRACT_1_16777216, 254.617452 );\n\t\t\t\tresult.xz = round( log2( result.xz ) * 128. + 3072. );\n\t\t\t\tresult.x = result.x + result.z \/ 4096.;\n\t\t\t\tresult.z = log2( params.t );\n\t\t\t}\n\t\t#endif\n\t\t\tbreak;\n\t\tcase MODE_SKYLIGHT:\n\t\t\tresult.xyz = I * params.scale + T * LE.starlight;\n\t\t#if WITH_CLOUDS\n\t\t\tresult.w = clamp( ( exp2pp( -cld_tau50( params.x0, vec4( LE.L, sqrt( LE.sundisk ) ), ATM_CLOUD_SHADOW_MIN_TAU, false ) * ( 1. - cld_f ) ) - ATM_CLOUD_T_CUTOFF ) \/ ( 1. - ATM_CLOUD_T_CUTOFF ), 0., 1. );\n\t\t#endif\n\t\t\tbreak;\n\t\tcase MODE_REFLECTION:\n\t\t\tresult.xyz = ( I + T * LE.starlight ) * params.scale;\n\t\t\tresult.w = params.scale;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint get_render_mode( vec2 fcoord, inout vec2 sc )\n{\n\tvec2 halfres = iResolution.xy \/ 2.;\n\tint mode = MODE_NONE;\n\n\tif( fcoord.y < halfres.y )\n\t{\n\t\tvec2 uv = g_vrmode ? ( fcoord - unViewport.xy ) \/ unViewport.zw : fcoord \/ iResolution.xy;\n\t\tif( uv.x < .5 )\n\t\t{\n\t\t\tsc = 2. * SCN_ATM_SUBSAMPLE_RATIO * g_subsample * uv - 1.;\n\t\t\tmode = MODE_INSCATTER;\n\t\t}\n\t\telse\n\t\tif( uv.x >= .5 && fcoord.y < halfres.y )\n\t\t{\n\t\t\tuv.x -= .5;\n\t\t\tsc = 2. * SCN_ATM_SUBSAMPLE_RATIO * g_subsample * uv - 1.;\n\t\t\tmode = MODE_REFLECTION;\n\t\t}\n\t}\n\telse\n\tif( fcoord.x < halfres.y )\n\t{\n\t\tbool mustupdate = bool( texelFetch( iChannel1, ivec2( iResolution.y, 2 ), 0 ).x );\n\t\tmode = mustupdate ? MODE_SKYLIGHT : MODE_PRESERVE;\n\t}\n\telse\n\tif( fcoord.x >= iResolution.x - 8. )\n\t\tmode = MODE_OBJECTS;\n\treturn mode;\n}\n\nbool get_render_ray( int mode, vec2 sc, inout Ray ray )\n{\n\tif( g_vrmode )\n\t{\n\t\tvec2 subframe_uv = ( sc + 1. ) \/ ( 2. * g_subsample );\n\t\tvec3 cc = ( mix( mix( unCorners[0], unCorners[1], subframe_uv.x ),\n\t\t\t\t\t\t mix( unCorners[3], unCorners[2], subframe_uv.x ), subframe_uv.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 ) * g_vrframe;\n\t\tif( dot( cc.yz, cc.yz ) >= 1.55 \/ GS.camzoom * cc.x * cc.x )\n\t\t\treturn false;\n\t\tcc.yz \/= GS.camzoom;\n\t\tcc = normalize( cc );\n\t\tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y \/ cc.x ) * dFdy( cc.z \/ cc.x ) );\n\t\tvec3 dp = unCorners[4].zxy * vec3( -1, 1, -1 ) \/ 1000.;\n\t\tray.o = GS.campos + GS.camframe * dp;\n\t\tray.d = GS.camframe * g_vrframe * cc;\n\t}\n\telse\n\t{\n\t\tvec2 ec = sc * vec2( 1, iResolution.y \/ iResolution.x );\n\t\tvec3 cc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) \/ GS.camzoom, CAM_DISTORT ) ) );\n\t\tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y \/ cc.x ) * dFdy( cc.z \/ cc.x ) );\n\t\tray.o = GS.campos;\n\t\tray.d = GS.camframe * cc;\n\t}\n\treturn true;\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n\tfcolor = vec4( ZERO, 1 );\n\n#if BUFFER_RUNLEVEL >= 3\n\n\tGS = gs_load( iChannel0, ADDR_GAME_STATE );\n\tLE = le_load( iChannel0, ADDR_LOCAL_ENV );\n\tTS = ts_load( iChannel0, ADDR_LOCAL_TS );\n\tAC = ac_load( iChannel0, ac_addr(1) );\n\tPD = pd_load( iChannel0, pd_addr(1) );\n\tcld_alt = PD.cld.akg.x;\n\tcld_k50max = PD.cld.akg.y;\n\tcld_g = PD.cld.akg.z;\n\tcld_f = cld_g * cld_g;\n\tcld_noise = PD.cld.noise;\n\tcld_size = PD.cld.size;\n\tcld_fluff = PD.cld.fluff;\n\tcld_move = PD.cld.move;\n\n\t\/\/ int localplanetindex = 1;\n\t\/\/ g_ps = ps_load( iChannel0, ADDR_PLANETS + ivec2( localplanetindex, 0 ) );\n\n\tg_subsample\t = gs_get_subsample( GS );\n\n\tif( ( GS.switches & GS_TRMAP ) == 0u )\n\t{\n\t\tvec2 sc = vec2(0);\n\t\tint mode = get_render_mode( fcoord, sc );\n\n\t\tif( mode == MODE_PRESERVE )\n\t\t\tfcolor = texelFetch( iChannel2, ivec2( fcoord - .5 ), 0 );\n\t\telse\n\t\tif( mode > 0 && sc.x < 1. && sc.y < 1. )\n\t\t{\n\t\t\tvec2 sct = sincospi( GS.timer * cld_move.w );\n\t\t\tcld_fluff_rot = mat2( sct.yx, -sct.x, sct.y );\n\t\t\tRay ray = Ray( ZERO, ZERO );\n\t\t\tbool ok = get_render_ray( mode, sc, ray );\n\t\t\tif( ok )\n\t\t\t\tfcolor = render( ray, mode, fcoord );\n\t\t}\n\t}\n#endif \/\/ RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n\t{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n\tg_vrmode = true;\n\tvec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tg_vrframe[1] = normalize( horz );\n\tg_vrframe[2] = normalize( down );\n\tg_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n\tmain_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *\t\t\t\t\t\t (c) 2001 - 2020\n *\n * Part 5 of 6: Buffer D shader (main rendering)\n * This software comes with no warranty. Use it at your own risk.\n * v 42\n *\/\n\n\/\/ ----------------------------------------------------------------------------\n\nGameState GS;\nVehicleState VS;\nLocalEnv LE;\nTrnSampler TS;\nAtmContext AC;\nPlanetData PD;\n\nfloat g_subsample = SCN_SUBSAMPLE;\nfloat g_pixelscale = 1.;\nvec3 g_ocn_beta50 = vec3(1);\nvec3 g_ocn_omega = vec3(1);\nbool g_vrmode = false;\nmat3 g_vrframe = mat3(0);\nvec4 g_vrfocus = vec4(0);\n\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MATERIALS\n\/\/ ----------------------------------------------------------------------------\n\nfloat phase_curve( float cosphase )\n\t{ return .85 + .15 * ( 8. + 1. ) * pow( max( 0., .5 - .5 * cosphase ), 8. ); }\n\nvec3 lunar_lambert( vec3 omega, float mu, float mu_0 )\n{\n\t\/\/ non-lambertian diffuse shading used for terrain land masses\n\t\/\/ mix Lambert and Lommel-Seeliger based on single scattering albedo omega_0,\n\n\t\/\/ return omega \/ ( mu + mu_0 );\n\t\/\/ return omega;\n\n\t\/*\n\tvec3 omega_0 = 4. * omega \/ ( 3. * omega + 1. );\n\treturn omega_0 * ( omega + .25 * ( 1. - omega ) \/ max( 0.0001, mu + mu_0 ) );\n\t\/*\/\n\tvec3 omega_0 = 244. * omega \/ ( 184. * omega + 61. );\n\treturn omega_0 * ( ( 1. + sqrt( mu * mu_0 ) ) \/ 2. * omega + .25 \/ max( 0.0001, mu + mu_0 ) );\n\t\/\/*\/\n}\n\n\t\/\/\t\tomega\t\t\t1\t\t\t\t\t\t\t\t\t0.7\t\t\t\t\t\t\t\t\t0.2\n\t\/\/\t\tomega_0\t\t\t1\t\t1\t\t\t1\t\t\t\t0.9\t\t0.9\t\t0.975\t\t\t\t0.5\t\t0.5\t\t\t0.7\n\t\/\/\n\t\/\/\t\tmu + mu_0\t\tV1\t\tV2\t\t\texact\t\t\tV1\t\tV2\t\texact\t\t\t\tV1\t\tV2\t\t\texact\n\t\/\/\n\t\/\/\t\t0.2\t\t\t\t1.00\t1.75..1.80\t1.81..1.95\t\t1.08\t1.60..1.64\t1.71..1.83\t\t1.20\t1.35..1.36\t1.42..1.49\n\t\/\/\t\t0.5\t\t\t\t1.00\t1.00..1.13\t1.01..1.20\t\t0.85\t0.85..0.94\t0.88..1.04\t\t0.60\t0.60..0.63\t0.66..0.73\n\t\/\/\t\t1.0\t\t\t\t1.00\t0.75..1.00\t0.73..1.02\t\t0.78\t0.60..0.78\t0.57..0.78\t\t0.40\t0.35\t\t0.36..0.43\n\t\/\/\t\t1.5\t\t\t\t1.00\t1.02..1.06\t0.98..1.01\t\t0.75\t0.76..0.79\t0.67..0.69\t\t0.33\t0.34\t\t0.32\n\t\/\/\t\t2.0\t\t\t\t1.00\t1.13\t\t1.05\t\t\t0.74\t0.83\t\t0.64\t\t\t0.30\t0.33\t\t0.26\n\t\/\/\n\t\/\/\t\tmu + mu_0\n\t\/\/\n\t\/\/\t\t0.2\t\t\t   -48.7\t-7.7\t\t\t\t\t   -59.0   -10.4\t\t\t\t\t   -19.5\t-8.7\n\t\/\/\t\t0.5\t\t\t   -16.7\t-5.8\t\t\t\t\t   -18.2\t-9.6\t\t\t\t\t   -17.8   -13.7\n\t\/\/\t\t1.0\t\t\t\t37.0\t 2.3\t\t\t\t\t\t36.8\t 5.2\t\t\t\t\t\t11.1   -18.6\n\t\/\/\t\t1.5\t\t\t\t 2.0\t 4.9\t\t\t\t\t\t11.9\t13.4\t\t\t\t\t\t 3.1\t 6.3\n\t\/\/\t\t2.0\t\t\t\t-4.7\t 7.6\t\t\t\t\t\t15.6\t29.7\t\t\t\t\t\t15.3\t26.9\n\n\nfloat NDFphase( float xi, float a )\n{ return 1. \/ ( ( LN2 + a ) * ( 1. + exp( -a ) - xi ) ); }\n\nfloat NDF( float xi, float a )\n{ return 1. \/ ( max( SQRTTWO, a - SQRTHALF ) * ( 1. + exp( -a ) - xi ) ); }\n\nfloat NDFintegral( float xi0, float xi1, float a )\n{\n\tfloat k0 = 1. + exp( -a ) - xi0;\n\tfloat k1 = 1. + exp( -a ) - xi1;\n\treturn ( ( k0 > 0. ? log( k0 ) : -a ) - ( k1 > 0. ? log( k1 ) : -a ) ) \/ max( SQRTTWO, a - SQRTHALF );\n}\n\nfloat NDFdisk( float xi, float a, float b )\n{\n\t\/\/ disk-integrated normal distribution function\n\t\/\/ using the distribution 1\/((a-1)*(1+exp(-a)-xi))\n\tfloat xi0 = xi - b \/ 2.;\n\tfloat xi1 = xi + b \/ 2.;\n\treturn ( NDFintegral( max( 0., xi0 ), min( 1., xi1 ), a ) +\n\t\t( xi1 >= 1. ? NDFintegral( 2. - xi1, 1., a ) : 0. ) ) \/ b;\n}\n\nstruct MaterialData\n{\n\tvec4 omega;\n};\n\nMaterialData[] g_matdata = MaterialData[](\n\t\/\/ 0\n\tMaterialData( vec4(0) ),\n\tMaterialData( vec4( .455, .439, .393, .45 ) ),\t\t\/\/ concrete 1\n\tMaterialData( vec4( .367, .349, .326, .43 ) ),\t\t\/\/ concrete 2\n\tMaterialData( vec4( .281, .272, .260, .41 ) ),\t\t\/\/ concrete 3\n\tMaterialData( vec4( .226, .217, .215, .37 ) ),\t\t\/\/ concrete 4\n\t\/\/ 5\n\tMaterialData( vec4( .274, .222, .112, .47 ) ),\t\t\/\/ sandy grass\n\tMaterialData( vec4( .443, .320, .240, .42 ) ),\t\t\/\/ sandy concrete\n\tMaterialData( vec4( .339, .228, .115, .35 ) ),\t\t\/\/ dark sand\n\tMaterialData( vec4( .088, .079, .101, .12 ) ),\t\t\/\/ asphalt\n\tMaterialData( vec4( .204, .206, .084, .60 ) ),\t\t\/\/ light grass\n\t\/\/ 10\n\tMaterialData( vec4( .3918, .0616, .0180, .71 ) ),\t\/\/ RAL 3020 traffic red\n\tMaterialData( vec4( .5832, .5931, .5815, .65 ) ),\t\/\/ RAL 7035 light grey\n\tMaterialData( vec4( .1579, .0805, .0469, .29 ) ),\t\/\/ RAL 8024 beige brown\n\tMaterialData( vec4( .8852, .8827, .8532, .77 ) ),\t\/\/ RAL 9016 traffic white\n\tMaterialData( vec4( .0440, .0820, .1473, .56 ) ),\t\/\/ RAL 5000 violet blue\n\t\/\/ 15\n\tMaterialData( vec4( .0069, .0827, .2402, .52 ) ),\t\/\/ RAL 5002 ultramarine blue\n\tMaterialData( vec4( .3600, .0531, .0332, .42 ) ),\t\/\/ RAL 3000 fire red\n\tMaterialData( vec4( .6000, .3245, .0472, .55 ) ),\t\/\/ RAL 1005 honey yellow\n\tMaterialData( vec4( .2414, .3557, .1122, .39 ) ),\t\/\/ RAL 6018 yellow green\n\tMaterialData( vec4( .0838, .2669, .1433, .41 ) ),\t\/\/ RAL 6024 traffic green\n\t\/\/ 20\n\tMaterialData( vec4( .3079, .2515, .1929, .32 ) ),\t\/\/ RAL 7002 olive grey\n\tMaterialData( vec4( .3259, .3259, .3290, .31 ) ),\t\/\/ RAL 7004 signal grey\n\tMaterialData( vec4( .0609, .2021, .2066, .35 ) ),\t\/\/ RAL 5021 water blue\n\tMaterialData( vec4(0) ),\n\tMaterialData( vec4(0) ),\n\t\/\/ 25\n\tMaterialData( vec4( .115, .064, .011, .26 ) ),\t\t\/\/ dark wood\n\tMaterialData( vec4( .167, .118, .055, .36 ) ),\t\t\/\/ medium wood\n\tMaterialData( vec4( .731, .733, .734, .25 ) ),\t\t\/\/ compressed snow\n\tMaterialData( vec4( .357, .243, .168, .43 ) ),\t\t\/\/ sandstone\n\tMaterialData( vec4( .152, .115, .111, .21 ) ),\t\t\/\/ muddy grass\n\t\/\/ 30\n\tMaterialData( vec4( .73, .73, .72, .33 ) ),\n\tMaterialData( vec4(0) )\n);\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ TERRAIN\n\/\/ ----------------------------------------------------------------------------\n\nvec4 texturenoise( vec3 r )\n{\n\tvec3 uvw = r \/ iChannelResolution[3];\n\treturn texture( iChannel3, uvw ) * 2. - 1.;\n}\n\nfloat trn_detailmap( vec3 pos )\n{\n\treturn 1. + .10 * texturenoise( pos \/ .01 ).x +\n\t\t.12 * texturenoise( pos \/ .003 ).x +\n\t\t.15 * texturenoise( pos \/ .001 ).x +\n\t\t.17 * texturenoise( pos \/ .0003 ).x;\n}\n\nfloat trn_blendmask( vec3 pos )\n{\n\tpos *= PD.trn.slope.x;\n\treturn clamp( .40 * texturenoise( pos \/ 10. ).x +\n\t\t\t\t  .50 * texturenoise( pos \/ 3. ).x +\n\t\t\t\t  .40 * texturenoise( pos \/ 1. ).x +\n\t\t\t\t  .30 * texturenoise( pos \/ 0.3 ).x + .5, 0., 1. );\n}\n\nvec3 trn_ripplemap( vec3 pos )\n{\n\treturn .20 * texturenoise( pos \/ .01 ).xyz +\n\t\t   .30 * texturenoise( pos \/ .003 ).xyz +\n\t\t   .30 * texturenoise( pos \/ .001 ).xyz +\n\t\t   .20 * texturenoise( pos \/ .0003 ).xyz;\n}\n\nvec4 texturenoiseLod( vec3 r, float lod )\n{\n\tvec3 uvw = r \/ iChannelResolution[3];\n\treturn textureLod( iChannel3, uvw, lod ) * 2. - 1.;\n}\n\nfloat trn_detailmapLod( vec3 pos, float scale )\n{\n\tfloat lod = log2( scale \/ 0.001 );\n\treturn 1. + .05 * texturenoiseLod( pos \/ .01, lod - 3.322 ).x +\n\t\t\t\t.07 * texturenoiseLod( pos \/ .003, lod - 1.585 ).x +\n\t\t\t\t.09 * texturenoiseLod( pos \/ .001, lod ).x +\n\t\t\t\t.11 * texturenoiseLod( pos \/ .0003, lod + 1.585 ).x;\n}\n\nfloat trn_blendmaskLod( vec3 pos, float scale )\n{\n\tfloat lod = log2( scale );\n\treturn clamp( .40 * texturenoiseLod( pos \/ 10., lod - 3.322 ).x +\n\t\t\t\t  .50 * texturenoiseLod( pos \/ 3., lod - 1.585 ).x +\n\t\t\t\t  .40 * texturenoiseLod( pos \/ 1., lod ).x +\n\t\t\t\t  .30 * texturenoiseLod( pos \/ 0.3, lod + 1.585 ).x, -.5, .5 );\n}\n\nvec3 trn_ripplemapLod( vec3 pos, float scale )\n{\n\tfloat lod = log2( scale \/ 0.001 );\n\treturn .20 * texturenoiseLod( pos \/ .01, lod - 3.322 ).xyz +\n\t\t.30 * texturenoiseLod( pos \/ .003, lod - 1.585 ).xyz +\n\t\t.30 * texturenoiseLod( pos \/ .001, lod ).xyz +\n\t\t.20 * texturenoiseLod( pos \/ .0003, lod + 1.585 ).xyz;\n}\n\nvec3 trn_normalmapLod( vec3 pos, float scale )\n{\n\tfloat lod = log2( scale \/ 0.001 );\n\treturn .15 * texturenoiseLod( pos \/ 0.01, lod - 3.322 ).xyz +\n\t\t.35 * texturenoiseLod( pos \/ 0.003, lod - 1.585 ).xyz +\n\t\t.35 * texturenoiseLod( pos \/ 0.001, lod ).xyz +\n\t\t.15 * texturenoiseLod( pos \/ 0.0003, lod + 1.585 ).xyz;\n}\n\nvec3 trn_albedo( vec3 r, float Krwidth, float alt, float slope, vec2 sigmares, float sinlat, const bool detail )\n{\n\tfloat coslat = sqrt( max( 0., 1. - sinlat * sinlat ) );\n\tfloat cos2lat = coslat * coslat * 2. - 1.;\n\tfloat cos3lat = cos2lat * coslat * 2. - coslat;\n\tfloat cos3lat2 = cos3lat * cos3lat;\n\tfloat sin3lat = sqrt( max( 0., 1. - cos3lat * cos3lat ) );\n\n\tbool ir = ( GS.switches & GS_IRCAM ) == GS_IRCAM;\n\tfloat m1 = detail ? trn_detailmapLod( r, Krwidth ) : 1.;\n\tfloat m4 = detail ? trn_detailmapLod( r \/ 4., Krwidth \/ 4. ) : 1.;\n\n\tconst vec2 LEGACYFACTORS = vec2(\n\t\t( 1.8 + 5.2 \/ TRN_SCALE * 0.3 ) \/ 7.,\n\t\tSCN_SCALE \/ ( 0.833333333 * TRN_SCALE ) );\n\n\tvec4 factors = vec4(\n\t\tcoslat,\n\t\tcos3lat2,\n\t\talt * LEGACYFACTORS.x,\n\t\tslope * LEGACYFACTORS.y );\n\n\tfloat Kb = Krwidth * .2511972 \/ SCN_SCALE;\n\tfloat b = trn_blendmaskLod( r * .2511972 \/ SCN_SCALE, Kb );\n\tfloat s = 8.;\n\n\tvec3 col = ZERO;\n\n\tfor( int i = 0; i < 6; ++i )\n\t{\n\t\tTrnLayer tl = tl_load( iChannel0, pd_addr(1) + ivec2( 0, pd_layer_addr(i) ) );\n\t\tif( detail )\n\t\t{\n\t\t\tTrnLayer tl2 = tl_load( iChannel0, pd_addr(1) + ivec2( 0, pd_layer_addr( int( tl.detail.x ) ) ) );\n\t\t\ttl.color = m1 * mix( tl.color, tl.detail.y * tl2.color, parabolstep( tl.detail.z, tl.detail.w, m4 ) );\n\t\t}\n\t\tfloat u = dot( tl.weights, factors ) + tl.offset;\n\t\tfloat c = clamp( .5 + u, tl.lower, tl.upper );\n\t\tfloat v = mix( b, c - .5, s );\n\t\tfloat K = dot( tl.weights.zw, sigmares * LEGACYFACTORS );\n\t\tfloat t = i == 0 ? 1. : saturate( .5 + v \/ max( 1., 1.48260222 * abs( s * K ) ) );\n\t\tcol = mix( col, irselect( tl.color, ir ), t );\n\t}\n\n\tif( alt >= 10.3135 )\n\t\tcol = irselect( vec4( COL_PRIMARYRED, .35 ), ir );;\n\n\treturn col;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ ATMOSPHERE\n\/\/ ----------------------------------------------------------------------------\n\nvec4 atm_inscatter_sample( sampler2D ch, vec2 uv, float t )\n{\n\tuv = uv \/ SCN_ATM_SUBSAMPLE_RATIO;\n\tuv.x = g_vrmode ? uv.x : min( uv.x, 1. - .4999 \/ float( textureSize( ch, 0 ).x ) );\n#if WITH_ATM_BILATERAL_UPSAMPLE\n\tvec2 tc = vec2( textureSize( ch, 0 ).xy ) * uv;\n\tvec2 rtc = round( tc );\n\tivec2 itc = ivec2( rtc ) - 1;\n\tvec4 sa = texelFetchOffset( ch, itc, 0, ivec2( 0, 0 ) );\n\tvec4 sb = texelFetchOffset( ch, itc, 0, ivec2( 1, 0 ) );\n\tvec4 sc = texelFetchOffset( ch, itc, 0, ivec2( 0, 1 ) );\n\tvec4 sd = texelFetchOffset( ch, itc, 0, ivec2( 1, 1 ) );\n\tfloat wx0 = abs( rtc.x + .5 - tc.x );\n\tfloat wx1 = abs( rtc.x - .5 - tc.x );\n\tfloat wy0 = abs( rtc.y + .5 - tc.y );\n\tfloat wy1 = abs( rtc.y - .5 - tc.y );\n\tfloat wta = abs( t - sa.z ) + .25;\n\tfloat wtb = abs( t - sb.z ) + .25;\n\tfloat wtc = abs( t - sc.z ) + .25;\n\tfloat wtd = abs( t - sd.z ) + .25;\n\tfloat wa = wx0 * wy0 * wtb * wtc * wtd;\n\tfloat wb = wx1 * wy0 * wta * wtc * wtd;\n\tfloat wc = wx0 * wy1 * wta * wtb * wtd;\n\tfloat wd = wx1 * wy1 * wta * wtb * wtc;\n\tsa.xz = exp2( vec2( floor( sa.x ) \/ 128., fract( sa.x ) * 32. ) - 24. ) - FRACT_1_16777216;\n\tsb.xz = exp2( vec2( floor( sb.x ) \/ 128., fract( sb.x ) * 32. ) - 24. ) - FRACT_1_16777216;\n\tsc.xz = exp2( vec2( floor( sc.x ) \/ 128., fract( sc.x ) * 32. ) - 24. ) - FRACT_1_16777216;\n\tsd.xz = exp2( vec2( floor( sd.x ) \/ 128., fract( sd.x ) * 32. ) - 24. ) - FRACT_1_16777216;\n\treturn ( sa * wa + sb * wb + sc * wc + sd * wd ) \/ ( wa + wb + wc + wd + FRACT_1_16777216 );\n#else\n\treturn textureLod( ch, uv, 0. );\n#endif\n}\n\nvec4 atm_reflection_sample( sampler2D ch, vec2 uv )\n{\n\tuv = uv \/ SCN_ATM_SUBSAMPLE_RATIO;\n\tuv.x = g_vrmode ? uv.x + .25 : max( uv.x, .5001 \/ float( textureSize( ch, 0 ).x ) ) + .5;\n#if WITH_ATM_BILATERAL_UPSAMPLE\n\tvec2 tc = vec2( textureSize( ch, 0 ).xy ) * uv;\n\tvec2 rtc = round( tc );\n\tivec2 itc = ivec2( rtc ) - 1;\n\tvec4 sa = texelFetchOffset( ch, itc, 0, ivec2( 0, 0 ) );\n\tvec4 sb = texelFetchOffset( ch, itc, 0, ivec2( 1, 0 ) );\n\tvec4 sc = texelFetchOffset( ch, itc, 0, ivec2( 0, 1 ) );\n\tvec4 sd = texelFetchOffset( ch, itc, 0, ivec2( 1, 1 ) );\n\tfloat wx0 = abs( rtc.x + .5 - tc.x );\n\tfloat wx1 = abs( rtc.x - .5 - tc.x );\n\tfloat wy0 = abs( rtc.y + .5 - tc.y );\n\tfloat wy1 = abs( rtc.y - .5 - tc.y );\n\tfloat wa = wx0 * wy0 * float( sa != vec4(0,0,0,1) );\n\tfloat wb = wx1 * wy0 * float( sb != vec4(0,0,0,1) );\n\tfloat wc = wx0 * wy1 * float( sc != vec4(0,0,0,1) );\n\tfloat wd = wx1 * wy1 * float( sd != vec4(0,0,0,1) );\n\treturn ( sa * wa + sb * wb + sc * wc + sd * wd ) \/ ( wa + wb + wc + wd + FRACT_1_16777216 );\n#else\n\treturn textureLod( ch, uv, 0. );\n#endif\n}\n\nvec4 atm_skylight_sample( TrnSampler ts, sampler2D ch, vec3 x )\n\t{ return ts_lookup( ts, ch, ts_box_skylight( ch ), normalize(x) ); }\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ SCENE\n\/\/ ----------------------------------------------------------------------------\n\nfloat scene_primitive_sphere( Ray ray, float R, inout float t, inout vec3 N )\n{\n\tvec2 sph = sphere_impact( ray.o, ray.d );\n\tif( sph.x < R * R )\n\t{\n\t\tfloat to = sphere_limits( R, sph ).x;\n\t\tif( to >= 0. && to < t )\n\t\t{\n\t\t\tt = to;\n\t\t\tN = normalize( ray.o + t * ray.d );\n\t\t}\n\t}\n\tfloat shadow = 1.;\n\tif( sph.y < 0. )\n\t{\n\t\tfloat K = -2. * sph.y * sqrt( LE.sundisk );\n\t\tfloat u = sqrt( sph.x );\n\t\tshadow = 1. - aaa_interval( K, u, 2. * R );\n\t}\n\treturn shadow;\n}\n\nfloat scene_primitive_cube( Ray ray, vec3 size, inout float t, inout vec3 N )\n{\n\tvec3 dn = ray.o + sign( ray.d ) * size;\n\tvec3 to = -dn \/ ray.d;\n\tif( to.x >= 0. && to.x < t &&\n\t\thmax( abs( ray.o.yz + ray.d.yz * to.x ) - size.yz ) < 0. )\n\t{\n\t\tt = to.x;\n\t\tN = sign( ray.o.x ) * UNIT_X;\n\t}\n\tif( to.y >= 0. && to.y < t &&\n\t\thmax( abs( ray.o.zx + ray.d.zx * to.y ) - size.zx ) < 0. )\n\t{\n\t\tt = to.y;\n\t\tN = sign( ray.o.y ) * UNIT_Y;\n\t}\n\tif( to.z >= 0. && to.z < t &&\n\t\thmax( abs( ray.o.xy + ray.d.xy * to.z ) - size.xy ) < 0. )\n\t{\n\t\tt = to.z;\n\t\tN = sign( ray.o.z ) * UNIT_Z;\n\t}\n\tfloat shadow = 1.;\n\tif( hmax( to ) >= 0. )\n\t{\n\t\tvec3 K = 2. * max( ZERO, max( to.yzx, to.zxy ) ) * sqrt( LE.sundisk );\n\t\tvec3 R = size.yzx * abs( ray.d ).zxy + size.zxy * abs( ray.d ).yzx;\n\t\tvec3 u = cross( ray.o, ray.d );\n\t\tshadow = 1. - aaa_interval( K.x, u.x, 2. * R.x )\n\t\t\t* aaa_interval( K.y, u.y, 2. * R.y )\n\t\t\t* aaa_interval( K.z, u.z, 2. * R.z );\n\t}\n\treturn shadow;\n}\n\nfloat scene_primitive_cylinder( Ray ray, vec2 size, inout float t, inout vec3 N )\n{\n\tfloat R = size.x;\n\tfloat omzz = max( 0., 1. - ray.d.z * ray.d.z );\n\tfloat ooomzz = 1. \/ omzz;\n\tfloat od = dot( ray.o.xy, ray.d.xy );\n\tfloat u = square( dot( ray.o.xy, perp( ray.d.xy ) ) ) * ooomzz;\n\tfloat v = max( 0., R * R - u );\n\tfloat to = -od * ooomzz - sqrt( v * ooomzz );\n\tfloat dz = ray.o.z + sign( ray.d.z ) * size.y;\n\tfloat tz = -dz \/ ray.d.z;\n\tif( u < R * R )\n\t{\n\t\tif( to >= 0. && to < t && abs( ray.o.z + ray.d.z * to ) < size.y )\n\t\t{\n\t\t\tt = to;\n\t\t\tN = vec3( normalize( ray.o.xy + t * ray.d.xy ), 0. );\n\t\t}\n\t\tvec2 xy = ray.o.xy + ray.d.xy * tz;\n\t\tif( tz >= 0. && tz < t && dot( xy, xy ) < R * R )\n\t\t{\n\t\t\tt = tz;\n\t\t\tN = sign( ray.o ) * UNIT_Z;\n\t\t}\n\t}\n\tfloat shadow = 1.;\n\tif( ( od < 0. || -sign( ray.d.z ) * ray.o.z >= size.y ) &&\n\t\t\t\t\t  sign( ray.d.z ) * ray.o.z < size.y * 0.95 )\n\t{\n\t\tfloat somzz = sqrt( omzz );\n\t\tfloat K = 2. * max( 0., max( to, tz ) * sqrt( LE.sundisk ) );\n\t\tfloat u1 = sqrt( u );\n\t\tfloat u2 = ( od * ray.d.z * ooomzz - ray.o.z ) * somzz;\n\t\tfloat R2 = sqrt( v ) * abs( ray.d.z ) + size.y * somzz;\n\t\tshadow = 1. - aaa_interval( K, u1, 2. * R ) *\n\t\t\taaa_interval( K, u2, 2. * R2 );\n\t}\n\treturn shadow;\n}\n\nfloat scene_obj_primitive( SceneObj obj, Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )\n{\n\tfloat to = t, shadow = 1.;\n\tvec3 N = ZERO;\n\tswitch( int( obj.paramsA.w ) )\n\t{\n\tcase SCNOBJ_PRIMITIVE_SPHERE:\n\tshadow = scene_primitive_sphere( ray, obj.paramsB.x, to, N );\n\tbreak;\n\tcase SCNOBJ_PRIMITIVE_CUBE:\n\tshadow = scene_primitive_cube( ray, obj.paramsB.xyz, to, N );\n\tbreak;\n\tcase SCNOBJ_PRIMITIVE_CYLINDER:\n\tshadow = scene_primitive_cylinder( ray, obj.paramsB.xy, to, N );\n\tbreak;\n\t}\n\tif( to < t )\n\t{\n\t\tt = to;\n\t\tout_N = N;\n\t\tbool ir = ( GS.switches & GS_IRCAM ) != 0u;\n\t\tif( obj.paramsA.x == -99. )\n\t\t{\n\t\t\tfloat u = ray.o.z + ray.d.z * t;\n\t\t\tfloat Ku = 2. * sqrt( g_pixelscale ) * t * mix( 1., 1. \/ dot( -ray.d.xy, N.xy ), square( ray.d.z ) );\n\t\t\talbedo = mix( irselect( g_matdata[ int( obj.paramsA.y ) ].omega, ir ),\n\t\t\t\t\t\t irselect( g_matdata[ int( obj.paramsA.z ) ].omega, ir ),\n\t\t\t\t\t\t aaa_stipple( Ku, u - .001, .004, .5 ) );\n\t\t}\n\t\telse\n\t\t\talbedo = irselect( g_matdata[ int( abs( obj.paramsA.x ) ) ].omega, ir );\n\t}\n\n\treturn shadow;\n}\n\nint scene_raycast_objects( Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )\n{\n\tint result = -1;\n\tfor( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n\t{\n\t\tfloat to = t;\n\t\tvec3 N = ZERO;\n\t\tSceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );\n\t\tRay localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );\n\t\tswitch( int( obj.tybr.x ) )\n\t\t{\n\t\tcase SCNOBJ_TYPE_PRIMITIVE:\n\t\tscene_obj_primitive( obj, localray, to, albedo, N );\n\t\tbreak;\n\t\t}\n\t\tif( to < t )\n\t\t\tresult = i, t = to, out_N = obj.B * N;\n\t}\n\treturn result;\n}\n\nfloat scene_raycast_object_shadows( Ray ray )\n{\n\tfloat result = 1.;\n\tfloat t = SCN_ZFAR;\n\tvec3 albedo, N;\n\tfor( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n\t{\n\t\tSceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );\n\t\tRay localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );\n\t\tswitch( int( obj.tybr.x ) )\n\t\t{\n\t\tcase SCNOBJ_TYPE_PRIMITIVE:\n\t\tresult *= scene_obj_primitive( obj, localray, t, albedo, N );\n\t\tbreak;\n\t\t}\n\t}\n\treturn max( 0., result );\n}\n\nvec3 scene_object_lighting( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,\n\t\t\t\t\t\t\tvec3 skyZ, vec3 skyL, vec3 skyR, vec3 ground )\n{\n\tfloat mu_0 = mu_stretch( dot( N, L ), .01 );\n\tfloat mu = mu_stretch( dot( N, V ), .01 );\n\tfloat cosi = dot( N, Z );\n\tfloat cosp = dot( L, V );\n\tfloat cost = dot( normalize( reject( N, Z ) ), normalize( reject( L, Z ) ) );\n\tvec3 kd = lunar_lambert( albedo, mu, mu_0 );\n\tfloat kl = phase_curve( cosp );\n\tvec3 E = F * mu_0;\n\t\/\/*\n\tvec3 sky = mix( mix( skyR, skyL, .5 + .5 * cost ), skyZ, cosi * .3333 + .6667 );\n\treturn E * kd * kl + albedo * mix( ground, sky, cosi * .5 + .5 );\n\t\/*\/\n\tfloat cosi2 = cosi * cosi;\n\tvec3 skyH = ( skyL + skyR ) \/ 2.;\n\tvec3 skyJ = ( skyL - skyR ) \/ 2.;\n\tvec3 sky = skyZ \/ 8. * ( 2.6667 + cosi * ( 3.5 + cosi2 * ( -0.3333 + cosi2 * ( -0.5 + cosi2 ) ) ) ) +\n\t\t\t   skyH \/ 8. * ( 1.3333 + cosi * ( 0.5 + cosi2 * ( +0.3333 + cosi2 * ( +0.5 + cosi2 ) ) ) ) +\n\t\t\t   skyJ * cost \/ ( 105. * PI ) * ( 30. - cosi2 * ( 6. + cosi2 * ( 8. + cosi2 * 16. ) ) );\n\treturn E * kd * kl + albedo * ( sky + ground * ( 1. - cosi ) \/ 2. );\n\t\/\/*\/\n}\n\nvec4 scene_ocean_normal_and_lensing( vec3 r, float t, float h, float d, vec3 V, vec3 Z )\n{\n\tvec3 A = normalize( V - Z * dot( V, Z ) );\n\tvec3 B = cross( A, Z );\n\tvec3 M = normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z, d ) );\n\tfloat dMdA = dot( A, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * A, d ) ) - M );\n\tfloat dMdB = dot( B, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * B, d ) ) - M );\n\tfloat lens = 1. + h \/ d * ( dMdA + dMdB );\n\treturn vec4( M, 1. \/ max( FRACT_1_64, lens * lens ) );\n}\n\nvec3 scene_object_color( vec3 r, mat2x3 Kr, float t, float r0, vec3 N, vec3 V, vec3 albedo,\n\t\t\t\t\t\t bool submerged, int index )\n{\n\tfloat h = length( r ) - r0;\n\tvec3 Z = normalize( r );\n\tvec3 skyL = texelFetch( iChannel2, ivec2( iResolution.x - 6., int( iResolution.y ) \/ 2 + 2 * index ), 0 ).xyz;\n\tvec3 skyR = texelFetch( iChannel2, ivec2( iResolution.x - 4., int( iResolution.y ) \/ 2 + 2 * index ), 0 ).xyz;\n\tvec4 skyZ = texelFetch( iChannel2, ivec2( iResolution.x - 2., int( iResolution.y ) \/ 2 + 2 * index ), 0 );\n\tvec3 TL = ac_transmittance( AC, Z * max( PD.radius, length( r ) ), LE.L, true );\n\tvec3 F = LE.sunlight;\n\tvec3 L = LE.L;\n\tif( submerged )\n\t{\n\t\tfloat d = max( 0.001, -.25 * h );\n\t\tvec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );\n\t\tF = F * M.w;\n\t\tF = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );\n\t\tL = normalize( -simple_refract( -L, Z ) );\n\t}\n\tfloat trnshadow = ts_shadow_sample( TS, iChannel1, length_normalize(r) ).x;\n\tF *= trnshadow * TL * skyZ.w;\n\tfloat objshadow = scene_raycast_object_shadows( Ray( r, L ) );\n\tfloat slope = length( N \/ dot( N, Z ) - Z );\n\tvec3 ground = trn_albedo( r, 4. * h, h, slope, vec2(0), Z.z, false ) * ( F * mu_stretch( dot( L, Z ), .01 ) + skyZ.xyz );\n\tif( submerged )\n\t{\n\t\tskyZ.xyz = .75 * skyZ.xyz + .125 * skyL + .125 * skyR;\n\t\tskyL = .125 * skyL + .375 * ( skyZ.xyz + ground );\n\t\tskyR = .125 * skyR + .375 * ( skyZ.xyz + ground );\n\t}\n\treturn scene_object_lighting( albedo, N, L, V, Z, F * objshadow, skyZ.xyz, skyL, skyR, ground );\n}\n\nfloat scene_obj_runway_centerline( mat2 K, vec2 uv, vec2 size )\n{\n\tfloat l = floor( size.x \/ 60. - 1.5 ) * 60.;\n\treturn aaa_stipple( Linfinity( K[0] ), uv.x, 60., .5 ) *\n\t\taaa_box( K, uv, vec2( l, .7 ), vec2( 0 ) );\n}\n\nfloat scene_obj_runway_threshold_markers( mat2 K, vec2 uv, vec2 size )\n{\n\tuv = abs( uv ) - size \/ 2. + vec2( 30, size.y \/ 4. );\n\tfloat w = floor( size.y \/ 9. ) * 3.;\n\treturn aaa_stipple( Linfinity( K[1] ), uv.y - fract( w \/ 6. ) * 3., 3., .5 ) *\n\t\taaa_box( K, uv, vec2( 30., w ), vec2( 0 ) );\n}\n\nvec4 scene_obj_runway( vec4 col, SceneObj obj, vec3 r, mat2x3 Kr )\n{\n\tvec3 dr = 1000. * ( r - obj.r );\n\tif( dot( dr, dr ) < 2. * dot( obj.paramsB.xy, obj.paramsB.xy ) )\n\t{\n\t\tvec2 uv = ( dr * obj.B ).xy;\n\t\tmat2 K = 1000. * mat2( obj.B[0] * Kr, obj.B[1] * Kr );\n\n\t\t\/\/ tarmac\n\t\tfloat d;\n\t\td = aaa_box( K, uv, obj.paramsB.xy, obj.paramsB.zw );\n\t\tvec3 albedo = irselect( g_matdata[int( abs( obj.paramsA.x ) )].omega, ( GS.switches & GS_IRCAM ) != 0u );\n\t\tcol = mix( col, vec4( albedo, 1 ), d );\n\n\t\t\/\/ paintings\n\t\tif( obj.paramsA.w > 0. )\n\t\t{\n\t\t\td = ( scene_obj_runway_centerline( K, uv, obj.paramsB.xy ) +\n\t\t\t\t  scene_obj_runway_threshold_markers( K, uv, obj.paramsB.xy ) );\n\t\t\tcol = mix( col, vec4( obj.paramsA.www, 1 ), d );\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 scene_surface_albedo( vec3 r, mat2x3 Kr, float h, float slope, vec2 sigmares, float sinlat, bool detail )\n{\n\tvec4 col = vec4( 0 );\n\tfor( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n\t{\n\t\tivec2 addr = ADDR_SCENE_OBJECTS + ivec2( i, 0 );\n\t\tSceneObj obj = so_load( iChannel0, addr );\n\t\tswitch( int( obj.tybr.x ) )\n\t\t{\n\t\tcase SCNOBJ_TYPE_RUNWAY:\n\t\tcol = scene_obj_runway( col, obj, r, Kr );\n\t\tbreak;\n\t\t}\n\t\tif( col.w >= 1. )\n\t\t\tbreak;\n\t}\n\tfloat Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );\n\treturn trn_albedo( r, Krwidth, h, slope, sigmares, sinlat, detail ) * ( 1. - col.w ) + col.xyz;\n}\n\nvec3 scene_lighting_terrain( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,\n\t\t\t\t\t\t\t vec3 sky, vec2 shadow )\n{\n#if WITH_ILLUM_TEST\n\tfloat mu0 = max( 0., dot( N, L ) );\n\treturn F * mu0 + sky;\n#else\n\tfloat mu_0 = mu_stretch( dot( N, L ), .01 );\n\tfloat mu = mu_stretch( dot( N, V ), .01 );\n\tfloat cosi = dot( N, Z );\n\tfloat cosp = dot( L, V );\n\tvec3 kd = lunar_lambert( albedo, mu, mu_0 );\n\tfloat kl = phase_curve( cosp );\n\tfloat kj = cosi * .5 + .5;\n\tvec3 E = F * mu_0 * shadow.x;\n\tvec3 backbounce = .5 * albedo * F * shadow.y * mu_stretch( dot( N, -L ), .125 )\n\t\t* mu_stretch( dot( L, Z ), .005 );\n\treturn E * kd * kl + albedo * ( sky * kj + backbounce );\n#endif\n}\n\nvec3 scene_lighting_ocean( vec3 albedo, vec3 Z, vec3 N, vec3 M, vec3 L, vec3 V, vec3 F,\n\t\t\t\t\t\t   float a, vec3 sky,\n\t\t\t\t\t\t   vec4 refl, float extra_T )\n{\n#if WITH_ILLUM_TEST\n\tfloat mu0 = max( 0., dot( N, L ) );\n\treturn F * mu0 + refl.xyz;\n#else\n\t\/\/ variation of the KSK microfacet model\n\tvec3 L_refract = normalize( -simple_refract( -L, Z ) );\n\tfloat mu0_refract = max( 0., dot( N, L_refract ) ) * max( 0., dot( L, Z ) );\n\tfloat mu0 = max( 0., dot( M, L ) );\n\tvec3 H = normalize( L + V );\n\tfloat cosxi = max( 0., dot( M, H ) );\n\tfloat cospsi = max( .0625, dot( L, H ) );\n\tfloat fr_mu = refl.w;\n\tfloat fr_psi = fresnel_schlick( .02, cospsi );\n\tfloat kd = ( 1. - fr_mu );\n\tfloat ks = extra_T * NDFdisk( cosxi, a, .5 * LE.sundisk ) \/ ( 4. * cospsi * cospsi );\n\treturn F * mix( mu0_refract * albedo * kd, mu0 * vec3( ks ), fr_psi ) + albedo * sky * ( 1. - fr_mu ) + refl.xyz;\n#endif\n}\n\nvec3 ndist( vec3 Z, float k, vec3 dZ )\n{\n\tfloat b = dot( Z, dZ );\n\treturn normalize( Z * square( 1. - k + k * b ) + k * ( dZ - Z * b ) );\n}\n\nvec3 scene_surface_color( vec3 r, mat2x3 Kr, float t, vec3 V, vec2 uv, bool submerged,\n\t\t\t\t\t\t  inout vec3 albedo, inout vec3 N )\n{\n\tfloat Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );\n\tvec2 sigmares = vec2(0);\n\tvec4 rn = length_normalize(r);\n\tvec4 tsample = ts_sample_fine( TS, iChannel1, rn.xyz, PD, Krwidth, sigmares );\n\tvec2 tshadow = ts_shadow_sample( TS, iChannel1, rn );\n\tN = normalize( tsample.xyz );\n\tvec3 Z = rn.xyz;\n\tfloat h = tsample.w;\n\tfloat pshadow = atm_planet_shadow( dot( LE.L, Z ), sqrt( max( 0., 1. - LE.radius * LE.radius \/ dot( r, r ) ) ), sqrt( LE.sundisk ) );\n\tvec4 sky = atm_skylight_sample( TS, iChannel2, r );\n\tvec3 TL = ac_transmittance( AC, Z * max( PD.radius, rn.w ), LE.L, true );\n\tvec3 F = LE.sunlight * TL * sky.w * pshadow;\n\tfloat slope = length( N \/ dot( N, Z ) - Z );\n\talbedo = scene_surface_albedo( r, Kr, h, slope, sigmares, Z.z, h >= 0. || submerged );\n\tfloat d = submerged ?\n\t\tmax( 0.001, -.25 * h ) :\n\t\tmax( max( 0.001, 125. * h * h ), 4. * t * sqrt( g_pixelscale ) );\n\tvec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );\n\tvec3 L = LE.L;\n\tif( submerged )\n\t{\n\t\tF = F * M.w;\n\t\tF = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );\n\t\tL = normalize( -simple_refract( -L, Z ) );\n\t}\n\tfloat oshadow = scene_raycast_object_shadows( Ray( r, L ) );\n\tvec3 col = ZERO;\n\tif( h < 0. && !submerged )\n\t{\n\t\t\/\/ water surface\n\t\tvec3 To = exp2pp( 1000. * h * g_ocn_beta50 );\n\t\tvec4 rsmpl = atm_reflection_sample( iChannel2, uv );\n\t\tvec3 albedo = mix( g_ocn_omega, To * albedo, To );\n\t\tF = F * M.w;\n\t\tF = F * mix( ONE, vec3( tshadow.x * oshadow ), To );\n\t\tconst float cld_g = 0.85;\n\t\tconst float cld_f = cld_g * cld_g;\n\t\tfloat extra_T = pow( sky.w, inversesqrt( 1. - cld_f ) - 1. );\n\t\tfloat a = sqrt( .0003 * inversesqrt( g_pixelscale ) \/ t + 1. ) * .8 \/ PD.ocn.Tds2.z;\n\t\tvec3 M = ndist( Z, 1.5 * PD.ocn.Tds2.z, trn_ripplemap( r + 0.002 * iTime * Z ) );\n\t\tM = M + .35 * PD.ocn.Tds2.z * ( Z + V ) * parabolstep( 0., .250, t - t * dot( V, Z ) );\n\t\tM = normalize( M + V * mu_stretch( -dot( M, V ), .03125 ) );\n\t\tcol = scene_lighting_ocean( albedo, Z, N, M, LE.L, V, F, a, sky.xyz, rsmpl, extra_T );\n\t}\n\telse\n\tif( t < SCN_ZFAR )\n\t{\n\t\t\/\/ land surface\n\t\tcol = scene_lighting_terrain( albedo, N, L, V, Z, F * oshadow, sky.xyz, tshadow.xy );\n\t}\n\treturn col;\n}\n\nfloat scene_raycast_terrain( Ray ray, float wlevel, float tmax2nd, inout float t0, inout vec3 r, bool submerged )\n{\n\tfloat t = 0., h = 0., alt = 0.;\n\tfloat lasth = 0., lastt = 0., lasta = 0.;\n\tvec4 tsmpl = vec4(0);\n\tfloat t_switch = pow( 0.0000005 * square( PD.radius ), .333333333 );\n\tfloat C0 = length( ray.o ) - PD.radius;\n\tfloat C1 = dot( ray.o, ray.d ) \/ length( ray.o );\n\tfloat C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) \/ ( length( ray.o ) * lensq( ray.o ) );\n\tfor( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; i++ )\n\t{\n\t\tr = ray.o + t * ray.d;\n\t\ttsmpl = ts_sample( TS, iChannel1, normalize(r) );\n\t\tlasta = alt;\n\t\talt =\n\t\t#if WITH_TRN_HIGHP_RAYCAST\n\t\t\tt < t_switch ? C0 + t * C1 + t * t * C2 :\n\t\t#endif\n\t\t\tlength( r ) - PD.radius;\n\t\tlasth = h;\n\t\th = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );\n\t\tif( h < 0. )\n\t\t{\n\t\t\tt = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );\n\t\t\tr = ray.o + t * ray.d;\n\t\t\treturn t;\n\t\t}\n\t\telse\n\t\tif( submerged && alt >= wlevel )\n\t\t{\n\t\t\tif( t0 > 0. )\n\t\t\t\tbreak;\n\t\t\tt = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );\n\t\t\tr = ray.o + t * ray.d;\n\t\t\tvec3 Z = normalize( r );\n\t\t\tvec3 N = ndist( Z, 1.5 * PD.ocn.Tds2.z, trn_ripplemap( r + 0.002 * iTime * Z ) );\n\t\t\tray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );\n\t\t\tray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );\n\t\t\tray.o = r;\n\t\t\tt0 = t;\n\t\t\tt = 0.;\n\t\t#if WITH_TRN_HIGHP_RAYCAST\n\t\t\tC0 = length( ray.o ) - PD.radius;\n\t\t\tC1 = dot( ray.o, ray.d ) \/ length( ray.o );\n\t\t\tC2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) \/ ( length( ray.o ) * lensq( ray.o ) );\n\t\t#endif\n\t\t\talt = wlevel;\n\t\t\th = wlevel - ts_sample( TS, iChannel1, Z ).w;\n\t\t}\n\t\tlastt = t;\n\t\tt += max( TRN_SAFE_SLOPE_FACTOR * ( 1. + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );\n\t\tif( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + PD.radius >= PD.radius * ( 1. + PD.trn.levels.y ) ) || ( t0 > 0. && t + t0 >= tmax2nd ) )\n\t\t\tbreak;\n\t}\n\treturn SCN_ZFAR;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ STARFIELD \/ SUNDISK\n\/\/ ----------------------------------------------------------------------------\n\nvec3 starfield_worker( vec4 params, float pixelscale )\n{\n\t\/\/ about 336 visible cells, 27 stars per cell = 9072 stars\n\t\/\/ simulate the actual magnitude distribution up to 6.5 mag as a power law\n\n\tconst float power = -0.7684;\n\tconst float powersum = 31.8768;\t\t\t\t\t\t\/\/ = sum( i^-0.7684, i=1..9072 )\n\n\tfloat n = min( 8344508., 2. \/ pixelscale );\n\tfloat scale = 2. * ( n + 2. ) \/ powersum * pow( length( params.xyz ), -n );\n\tvec3 cell = vec3( floor( asin( params.xy ) * 5.09393754 ), params.w + sign( params.z ) );\n\tvec3 col = ZERO; \/\/ vec3( cell.xy \/ 7. + .5, cell.z \/ 5. );\n\tint k = 1 + int( mod( 233. * dot( cell, vec3( 1, 8, 64 ) ), 384. ) );\n\tuint rnd = uint( 13 * k );\n\tfor( int i = 0, N = 27; i < N; ++i )\n\t{\n\t\tvec2 phi = sin( ( cell.xy + vec2( rnd *= 3934873077u, rnd *= 3934873077u ) \/ 4294967296. ) \/ 5.09393754 );\n\t\tvec3 dir = vec3( phi, sign( params.z ) * sqrt( 1. - dot( phi, phi ) ) );\n\t\tcol += scale * pow( float( k + 384 * i ), power ) * pow( dot( dir, params.xyz ), n );\n\t}\n\treturn LE.starlight * mix( col, ONE, COL_STARLIGHT_ISL );\n}\n\nvec3 starfield( vec3 raydir, float pixelscale )\n{\n\tPlanetState ps = ps_load( iChannel0, ps_addr(1) );\n\traydir = ps.B * raydir;\n\n#if WITH_STARS\n\tvec3 absdir = abs( raydir );\n\tvec4 params = absdir.x < absdir.y ?\n\t\tabsdir.y < absdir.z ?\n\t\tvec4( raydir.xyz, 0 ) :\n\t\tvec4( raydir.zxy, 2 ) :\n\t\tabsdir.z < absdir.x ?\n\t\tvec4( raydir.yzx, 4 ) :\n\t\tvec4( raydir.xyz, 0 );\n\treturn starfield_worker( params, pixelscale );\n#else\n\treturn ZERO;\n#endif\n}\n\nvec3 sundisk( float cosangle )\n{\n\tfloat cosbeta = sqrt( max( 0., 1. - LE.sundisk ) );\n\tfloat shape = 1.333 * parabolstep( cosbeta, ( 1. + cosbeta ) \/ 2., cosangle );\n\treturn shape * LE.sunlight \/ LE.sundisk;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAP MODE\n\/\/ ----------------------------------------------------------------------------\n\nvec2 vr_unproject( vec3 r )\n\t{ return unViewport.zw * ( g_vrfocus.xy + .5 * g_vrfocus.zw * r.yz \/ r.x * vec2( 1, -1 ) ); }\n\nvec2 fix_fcoord_for_vr( vec2 fcoord )\n{\n\tif( g_vrmode )\n\t{\n\t\tvec2 xy = vr_unproject( vec3( 1.35, -1, +iResolution.y \/ iResolution.x ) );\n\t\tvec2 zw = vr_unproject( vec3( 1.35, +1, -iResolution.y \/ iResolution.x ) );\n\t\tfcoord = ( fcoord - unViewport.xy - xy ) * iResolution.xy \/ ( zw - xy );\n\t}\n\treturn fcoord;\n}\n\nfloat map_expand_flatten( float h )\n{\n\tfloat flevel = PD.trn.flatten.x * PD.radius;\n\tfloat frange = PD.trn.flatten.y * PD.radius;\n\tfloat fstrenth = PD.trn.flatten.z;\n\tfloat compress = ( fstrenth \/ 3. - fstrenth + 1. );\n\tfloat compressed_top = flevel + frange * compress;\n\tfloat compressed_bottom = flevel - frange * compress;\n\tfloat expanded_top = flevel + frange;\n\tfloat expanded_bottom = flevel - frange;\n\tfloat minh = PD.trn.levels.x * PD.radius;\n\tfloat maxh = PD.trn.levels.y * PD.radius;\n\tif( h > compressed_top )\n\t\treturn ( h - compressed_top ) \/ ( maxh - compressed_top ) * ( maxh - expanded_top ) + expanded_top;\n\telse\n\t\tif( h < compressed_bottom )\n\t\t\treturn ( h - minh ) \/ ( compressed_bottom - minh ) * ( expanded_bottom - minh ) + minh;\n\t\telse\n\t\t\treturn ( h - compressed_bottom ) \/ ( compressed_top - compressed_bottom ) * ( expanded_top - expanded_bottom ) + expanded_bottom;\n}\n\nfloat map_grid_coverage( vec3 r, mat2x3 Kr, float zoom )\n{\n\tvec3 north = normalize( reject( UNIT_Z, r ) );\n\tvec3 east = cross( north, r );\n\tfloat lat = degrees( atan( r.z, length( r.xy ) ) );\n\tfloat lng = degrees( atan( r.y, r.x ) );\n\tfloat sz = sqrt( 1. - r.z * r.z );\n\tfloat Ku = degrees( Linfinity( north * Kr ) );\n\tfloat Kv = degrees( Linfinity( east * Kr ) ) \/ sz;\n\tconst float n = 5.;\n\tconst float log2n = log2( n );\n\tfloat levels[] = float[]( 90., 30., 5., 1., .2 );\n\tint l = zoom < 1. ? 0 : zoom < 6. ? 1 : zoom < 30. ? 2 : 3;\n\tfloat grid1 = levels[l];\n\tfloat grid2 = levels[l + 1];\n\tint m = min( l, abs( lat ) >= 90. - grid2 ? 0 :\n\t\t\t\t\tabs( lat ) >= 90. - grid1 ? 1 :\n\t\t\t\t\tabs( lat ) >= 85. ? 2 : 3 );\n\tfloat grid1h = levels[m];\n\tfloat grid2h = levels[m + 1];\n\tfloat latitudes = aaa_stipple( Ku, grid1 \/ 2. + lat, grid1, .25 * Ku \/ grid1 );\n\tfloat meridians = aaa_stipple( Kv, grid1h \/ 2. + lng, grid1h, .25 * Kv \/ grid1h );\n\tfloat sub_latitudes = aaa_stipple( Ku, grid2 \/ 2. + lat, grid2, .0625 * Ku \/ grid2 );\n\tfloat sub_meridians = aaa_stipple( Kv, grid2h \/ 2. + lng, grid2h, .0625 * Kv \/ grid2h );\n\tfloat meridian_mask = aaa_interval( Ku, lat, 180. - 2. * grid2 \/ 5. );\n\n\treturn max(\n\t\tlatitudes, max(\n\t\t\tmeridians * meridian_mask, max(\n\t\t\t\tsub_latitudes,\n\t\t\t\tsub_meridians * meridian_mask ) ) );\n}\n\nfloat map_isocontour_coverage( float h, float Kh )\n{\n\tfloat grid1 = 1.;\n\tfloat grid2 = .1;\n\tfloat grid3 = .01;\n\tfloat super_contours = aaa_stipple( Kh, grid1 \/ 2. + h, grid1, min( .25, Kh \/ grid1 ) );\n\tfloat contours = aaa_stipple( Kh, grid2 \/ 2. + h, grid2, min( .125, .5 * Kh \/ grid2 ) );\n\tfloat sub_contours = aaa_stipple( Kh, grid3 \/ 2. + h, grid3, min( .0625, .25 * Kh \/ grid3 ) );\n\tfloat result = max( super_contours, max( contours, sub_contours ) );\n\treturn result;\n}\n\nvec3 map_display( vec2 fcoord )\n{\n\tvec2 fc = fix_fcoord_for_vr( fcoord );\n\tif( any( greaterThanEqual( abs( fc - iResolution.xy \/ 2. ), iResolution.xy \/ 2. ) ) )\n\t\treturn ZERO;\n\tvec3 drdx = ZERO, drdy = ZERO;\n\tvec4 r = gs_map_unproject_d( GS, fc, iResolution.xy, drdx, drdy );\n\tmat2x3 Kr = mat2x3( drdx, drdy );\n\tvec2 c = mix( iResolution.xy \/ 2., fc, 1. \/ g_subsample );\n\tvec4 tsmpl = texture( iChannel1, c \/ iResolution.xy, 0. );\n\tvec2 sigmares = vec2(0);\n#if WITH_TRN_SURFACE_AA && !WORKAROUND_11_MAP_CRASH\n\t{\n\t\tTrnSampler ts;\n\t\tts.rn = r.xyz;\n\t\tts.TB[0] = normalize( reject( UNIT_Z, ts.rn ) );\n\t\tts.TB[1] = cross( ts.rn, ts.TB[0] );\n\t\tint zoneindex = int( tsmpl.z );\n\t\ttsmpl = ts_unpack_normal( ts, tsmpl );\n\t\tfloat detail = log2( iResolution.y * GS.camzoom ) - TRN_LOD_BIAS - 2.5 * float( g_vrmode );\n\t\tfloat Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) ) * g_subsample;\n\t\tvec4 zone = ld_load( iChannel1, ld_addr_b( zoneindex ) ).zone;\n\t\ttrn_elevation_refine(\n\t\t\tr.xyz,\n\t\t\tdetail,\n\t\t\tPD,\n\t\t\tzone,\n\t\t\tdetail,\n\t\t\ttsmpl,\n\t\t\tsigmares );\n\t}\n#endif\n\tfloat h = tsmpl.w;\n\tfloat Kh = Linfinity( vec2( dFdx(h), dFdy(h) ) );\n\tfloat s = degrees( acos( dot( tsmpl.xyz, r.xyz ) ) ) \/ 100.;\n\tfloat Ks = Linfinity( vec2( dFdx(s), dFdy(s) ) );\n\tfloat z = 0.;\n\tfloat Kz = 0.;\n\tfloat cut = 0.;\n\tif( abs( r.w ) >= 1. )\n\t\treturn ZERO;\n\ttsmpl.w += PD.radius;\n\tvec3 col = ZERO;\n\n\tint mode = int( ( GS.switches & GS_MMODE_MASK ) >> GS_MMODE_SHIFT );\n\tvec3 oceanI = 3.5 * mix( square( PD.ocn.omega.xyz ), ( PD.ocn.omega.xyz ), exp2( -h * 5. \/ ( PD.radius * PD.trn.levels.x ) ) );\n\tvec3 oceanT = h < 0. ? 0.95 * exp2pp( min( 0., h ) * PD.ocn.beta50.xyz * 1000. ) : ONE;\n\tvec3 gridcol = ZERO;\n\tif( mode == GS_MAP_PHYSICAL )\n\t{\n\t\tvec3 N = tsmpl.xyz;\n\t\tvec3 Z = r.xyz;\n\t\tfloat slope = length( N \/ dot( N, Z ) - Z );\n\t\tvec3 albedo = scene_surface_albedo( tsmpl.w * r.xyz, tsmpl.w * Kr * g_subsample, h, slope, sigmares, r.z, true );\n\t\tcol = mix( oceanI, oceanT * albedo, oceanT );\n\t\tgridcol = col.y < .5 ? ONE : ZERO;\n\t\tcut = .125;\n\t}\n\telse\n\tif( mode == GS_MAP_ELEVATION )\n\t{\n\t\tfloat e = map_expand_flatten(h) \/ ( PD.radius * PD.trn.slope.x * abs( h < 0. ? PD.trn.levels.x : PD.trn.levels.y ) );\n\t\tcol = vec3( cos( e * 3. - PI \/ 2. ), cos( e * 3. ), cos( e * 3. + PI \/ 2. ) ) * .3 * saturate( 4. * abs( h ) ) + .4;\n\t\tcol = mix( oceanI, col, .5 + .5 * oceanT );\n\t\t\/\/ col = vec3( -.5 * h \/ ( PD.radius * PD.trn_slope.x * PD.trn_levels.x ) + .5 );\n\t\tz = h;\n\t\tKz = Kh;\n\t\tcut = .25;\n\t}\n\telse\n\tif( mode == GS_MAP_SLOPE )\n\t{\n\t\tcol = vec3( cos( s * 9. ), cos( s * 9. + PI * 0.6667 ), cos( s * 9. + PI * 1.3333 ) ) * .3 * saturate( 4. * s ) + .4;\n\t\tcol = mix( oceanI, col, .5 + .5 * oceanT );\n\t\t\/\/ col = vec3( max( 0., log2( tan( radians( 100. * s ) ) ) \/ 8. + 1. ) );\n\t\t\/\/ col = vec3( clamp( 100. \/ 8. * s, 0., 1. ) );\n\t\tz = max( s, Ks );\n\t\tKz = Ks;\n\t\tcut = .75;\n\t}\n\n\t\/\/*\n\tif( mode != GS_MAP_PHYSICAL )\n\t\tcol = mix( col, ZERO, map_isocontour_coverage( z, Kz ) );\n\tvec3 L = normalize( r.xyz - normalize( Kr[0] ) + normalize( Kr[1] ) );\n\tcol = col * max( cut, 1.5 * dot( tsmpl.xyz, L ) ) * mix( COL_RODVISION, COL_SUNLIGHT.xyz, parabolstep( -.01, .01, dot( r.xyz, LE.L ) ) );\n\tcol = mix( col, gridcol, map_grid_coverage( r.xyz, Kr, GS.camzoom ) );\n\t\/\/*\/\n\n\t\/\/ TODO: display outline of apparent horizon\n\t\/*\n\t{\n\t\tif( tsmpl.w < PD.radius && r.w < PD.radius )\n\t\t{\n\t\t\ttsmpl.w = PD.radius;\n\t\t\ttsmpl.xyz = normalize( r.xyz );\n\t\t}\n\t\tfloat c = dot( r.xyz, VS.localr );\n\t\tvec3 dwdr = tsmpl.xyz \/ dot( tsmpl.xyz, r.xyz ) - r.xyz;\n\t\tfloat Kc = 2. * Linfinity( ( abs(c) * VS.localr + length( VS.localr ) * tsmpl.w * dwdr ) * Kr );\n\t\tcol += vec3( 1, .5, 0 ) * aaa_interval( Kc, ( tsmpl.w + abs(c) ) * ( tsmpl.w - c ), .5 * Kc );\n\t}\n\t\/\/*\/\n\n\treturn col;\n}\n\n\/\/ ----------------------------------------------------------------------------\n\/\/ MAIN\n\/\/ ----------------------------------------------------------------------------\n\nvec4 render( Ray ray, vec2 uv, bool submerged )\n{\n\tfloat t0 = 0., Tc = 1.;\n\tfloat r0 = PD.radius;\n\tvec3 r = ray.o, N = ZERO, col = ZERO, albedo = ZERO, I = ZERO;\n\t\/\/ todo: (1)\n\tfloat t = scene_raycast_terrain( ray, 0., 12. \/ ( 1000. * hmin( PD.ocn.beta50 ) ), t0, r, submerged );\n\tfloat tx = t0 > 0. ? t0 : t;\n\tint index = scene_raycast_objects( ray, tx, albedo, N );\n\tmat2x3 Kr = mat2x3( dFdx(r), dFdy(r) );\n\n\tif( index >= 0 )\n\t{\n\t\t\/\/ object hit:\n\t\t\/\/ get atmosphere samples and color for object\n\t\tvec4 objsmpl = texelFetch( iChannel2, ivec2( iResolution.x - 8., int( iResolution.y ) \/ 2 + 2 * index ), 0 );\n\t\tTc = objsmpl.w, I = objsmpl.xyz, t = tx, r = ray.o + t * ray.d;\n\t\tcol = scene_object_color( r, Kr, t, PD.radius, N, -ray.d, albedo, submerged, index );\n\t}\n\telse\n\t{\n\t\t\/\/ not object hit:\n\t\t\/\/ get atmosphere samples and color for sky and terrain\n\t\tvec4 asmpl = atm_inscatter_sample( iChannel2, uv, log2( max( FRACT_1_4096, t ) ) );\n\t\tTc = asmpl.w, I = asmpl.xyz;\n\t\tif( t < SCN_ZFAR )\n\t\t{\n\t\t\tvec3 V = t0 > 0. ? normalize( r - ray.o ) : -ray.d;\n\t\t\tcol = scene_surface_color( r, Kr, t, V, uv, submerged, albedo, N );\n\t\t}\n\t}\n\n\tif( t >= SCN_ZFAR && !submerged )\n\t{\n\t\t\/\/ sky hit:\n\t\t\/\/ add contribution of celestial bodies\n\t\t\/\/ compute aerial perspective for an infinite ray\n\t\tconst float cld_g = 0.85;\n\t\tconst float cld_f = cld_g * cld_g;\n\t\tfloat extra_T = pow( Tc, inversesqrt( 1. - cld_f ) - 1. );\n\t\tfloat cosphase = saturate( dot( ray.d, LE.L ) );\n\t\tcol = starfield( ray.d, g_pixelscale )\n\t\t\t+ extra_T * irselect( COL_SUNLIGHT, ( GS.switches & GS_IRCAM ) != 0u ) * sundisk( cosphase );\n\t\tvec3 Ta = ac_transmittance( AC, ray.o, ray.d, false );\n\t\tcol = col * Tc * Ta + I;\n\t}\n\telse\n\t{\n\t\t\/\/ not sky hit:\n\t\t\/\/ add landing light contribution, if switched on\n\t\tvec3 collight = ZERO;\n\t\tif( ( VS.switches & VS_LIGHT ) == VS_LIGHT )\n\t\t{\n\t\t\t\/\/ Xenon arc lamp 3 MCd with double beam pattern\n\t\t\tvec3 axis = normalize( VS.localB[0] + .05 * VS.localB[2] );\n\t\t\tvec3 L = normalize( VS.localr - r );\n\t\t\tvec3 V = normalize( ray.o - r );\n\t\t\tfloat beam1 = square( saturate( 2. * dot( -axis, L ) - 1. ) );\n\t\t\tfloat beam2 = square( saturate( 20. * dot( -axis, L ) - 19. ) );\n\t\t\tfloat mu0 = max( 0., dot( N, L ) );\n\t\t\tfloat mu = max( 0., dot( N, V ) );\n\t\t\tfloat cosphase = dot( L, V );\n\t\t\t\/*\n\t\t\tvec3 omega0 = 4. * albedo \/ ( 3. * albedo + 1. );\n\t\t\tvec3 kd = ( albedo + .25 * ( 1. - albedo ) \/ max( 0.0001, mu + mu0 ) );\n\t\t\t\/*\/\n\t\t\tvec3 omega0 = 244. * albedo \/ ( 184. * albedo + 61. );\n\t\t\tvec3 kd = ( albedo * ( 1. + sqrt( mu * mu0 ) ) \/ 2. + .25 \/ max( 0.0001, mu + mu0 ) );\n\t\t\t\/\/*\/\n\t\t\tfloat kl = phase_curve( cosphase );\n\t\t\tfloat d = max( .002, distance( VS.localr, r ) );\n\t\t\tvec3 col = irselect( COL_XENONARC, ( GS.switches & GS_IRCAM ) != 0u );\n\t\t\tvec3 E = .00011 * col \/ pow( d, 1.67 ) * mu0;\n\t\t\tif( submerged )\n\t\t\t\tE *= exp2pp( -d * g_ocn_beta50 * 1000. );\n\t\t\tcollight += omega0 * E * kd * kl * mix( beam1, beam2, .75 );\n\t\t}\n\n\t\tif( submerged )\n\t\t{\n\t\t\t\/\/ underwater:\n\t\t\t\/\/ modify color by underwater scattering\n\t\t\tvec3 surfacepoint = normalize( ray.o ) * PD.radius;\n\t\t\tvec3 surfacelight = LE.sunlight\n\t\t\t\t* ac_transmittance( AC, surfacepoint, LE.L, true )\n\t\t\t\t* ( 1. - fresnel_schlick( .02, dot( normalize( surfacepoint ), LE.L ) ) )\n\t\t\t\t* texelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).w\n\t\t\t\t+ texelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).xyz;\n\t\t\tfloat z0 = PD.radius - length( ray.o );\n\t\t\tfloat z1 = max( 0., PD.radius - length(r) );\n\t\t\tvec3 W0 = exp2pp( -z0 * g_ocn_beta50 * 1000. );\n\t\t\tvec3 W1 = exp2pp( -z1 * g_ocn_beta50 * 1000. );\n\t\t\tif( t0 > 0. && index == -1 )\n\t\t\t{\n\t\t\t\tvec3 r0 = ray.o + t0 * ray.d;\n\t\t\t\tvec3 Z = normalize( r0 );\n\t\t\t\tvec3 M = ndist( Z, 1.5 * PD.ocn.Tds2.z, trn_ripplemap( r0 + 0.002 * iTime * Z ) );\n\t\t\t\tvec3 refrac = normalize( simple_refract( ray.d, M ) );\n\t\t\t\tfloat pixelscale_refrac = 4. * g_pixelscale;\n\t\t\t\tfloat cosxi = dot( M, normalize( simple_refract_inv( ray.d, LE.L, Z ) ) );\n\t\t\t\tfloat a = sqrt( .0003 * inversesqrt( pixelscale_refrac ) \/ t0 + 1. ) * .8 \/ PD.ocn.Tds2.z;\n\t\t\t\tvec3 Ta = ac_transmittance( AC, surfacepoint, refrac, false );\n\t\t\t\tvec3 outercol = I + Tc * Ta * (\n\t\t\t\t\tstarfield( refrac, pixelscale_refrac ) +\n\t\t\t\t\tLE.sunlight * max( 0., NDFdisk( cosxi, a, .5 * LE.sundisk ) ) * max( 0., dot( Z, LE.L ) ) );\n\t\t\t\tvec3 WX = exp2pp( -t0 * g_ocn_beta50 * 1000. );\n\t\t\t\tvec3 WI = t0 - z0 >= 0.0001 ? W0 - ( W0 - WX ) * t0 \/ ( t0 - z0 ) : W0 - W0 * t0 * g_ocn_beta50 * 1000. * LN2;\n\t\t\t\tvec3 WY = exp2pp( -t * g_ocn_beta50 * 1000. );\n\t\t\t\tvec3 WJ = WY * t \/ ( t + z1 );\n\t\t\t\tfloat fr = max( 0., 1. - pow( 1.6666667 - dot( M, ray.d ), 8. ) );\n\t\t\t\tcol = WX * mix( WY * ( collight + W1 * col ), outercol, fr ) + ( W0 - WI * WJ ) * g_ocn_omega * surfacelight;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec3 WT = exp2pp( -t * g_ocn_beta50 * 1000. );\n\t\t\t\tvec3 WI = ( W0 - WT * W1 ) * t \/ ( t + z1 - z0 );\n\t\t\t\tcol = WT * ( collight + W1 * col ) + WI * g_ocn_omega * surfacelight;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\/\/ not underwater:\n\t\t\t\/\/ compute aerial perspective for a finite ray\n\t\t\tvec3 Ta = ac_transmittance_finite( AC, ray.o, r );\n\t\t\tcol = ( collight + col ) * Tc * Ta + I;\n\t\t}\n\t}\n\n\tif( uv.y * g_subsample >= 1. - VS.canopy )\n\t\tcol *= irselect( COL_CANOPY_TINT, ( GS.switches & GS_IRCAM ) == GS_IRCAM );\n\n\treturn vec4( col, t0 > 0. && ( index == -1 || t0 < t ) ? 1. : t > 0. ? t \/ ( 1. + t ) : 1. );\n}\n\nvoid hmd_night_vision( inout vec3 col, vec2 coord, vec3 cc )\n{\n\tvec2 uv = coord \/ iResolution.xy;\n\tif( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x )\n\t{\n\t\tfloat y = COL_NVISNGAIN * dot( col, irselect( COL_NVISNSENS, ( GS.switches & GS_IRCAM ) != 0u ) );\n\t\tcol += COL_P43PHOSPHOR * COL_NVISNSAT * y \/ ( COL_NVISNSAT + y );\n\t}\n}\n\nbool get_render_ray( vec2 fcoord, inout vec2 uv, inout vec3 cc, inout Ray ray )\n{\n\tif( g_vrmode )\n\t{\n\t\tuv = ( fcoord - unViewport.xy ) \/ unViewport.zw;\n\t\tcc = ( mix( mix( unCorners[0], unCorners[1], uv.x ),\n\t\t\t\t\tmix( unCorners[3], unCorners[2], uv.x ), uv.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 ) * g_vrframe;\n\t\tif( dot( cc.yz, cc.yz ) >= 1.55 \/ GS.camzoom * cc.x * cc.x )\n\t\t\treturn false;\n\t\tcc.yz \/= GS.camzoom;\n\t\tcc = normalize( cc );\n\t\tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y \/ cc.x ) * dFdy( cc.z \/ cc.x ) );\n\t\tif( fcoord.x * 2. >= iResolution.x )\n\t\t\tuv.x += SCN_ATM_SUBSAMPLE_RATIO;\n\t\tuv.x \/= 2.;\n\t\tvec3 dp = unCorners[4].zxy * vec3( -1, 1, -1 ) \/ 1000.;\n\t\tray.o = GS.campos + GS.camframe * dp;\n\t\tray.d = GS.camframe * g_vrframe * cc;\n\t}\n\telse\n\t{\n\t\tuv = fcoord \/ iResolution.xy;\n\t\tvec2 sc = 2. * g_subsample * uv - 1.;\n\t\tif( sc.x >= 1. || sc.y >= 1. )\n\t\t\treturn false;\n\t\tvec2 ec = sc * vec2( 1, iResolution.y \/ iResolution.x );\n\t\tcc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) \/ GS.camzoom, CAM_DISTORT ) ) );\n\t\tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y \/ cc.x ) * dFdy( cc.z \/ cc.x ) );\n\t\tray.o = GS.campos;\n\t\tray.d = GS.camframe * cc;\n\t}\n\treturn true;\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n\tfcolor = vec4( ZERO, 1. );\n\n#if BUFFER_RUNLEVEL >= 4\n\n\tGS = gs_load( iChannel0, ADDR_GAME_STATE );\n\tVS = vs_load( iChannel0, ADDR_VEHICLE_STATE );\n\tLE = le_load( iChannel0, ADDR_LOCAL_ENV );\n\tTS = ts_load( iChannel0, ADDR_LOCAL_TS );\n\tAC = ac_load( iChannel0, ac_addr(1) );\n\tPD = pd_load( iChannel0, pd_addr(1) );\n\n\tg_subsample = gs_get_subsample( GS );\n\n\tbool ir = ( GS.switches & GS_IRCAM ) != 0u;\n\tg_ocn_beta50 = irselect( PD.ocn.beta50, ir );\n\tg_ocn_omega = irselect( PD.ocn.omega, ir );\n\n\tvec2 uv = vec2(0);\n\tvec3 cc = ZERO;\n\tRay ray = Ray( ZERO, ZERO );\n\tbool ray_ok = get_render_ray( fcoord, uv, cc, ray );\n\n\tbool submerged = length( ray.o ) < PD.radius;\n\tivec2 sc = ivec2( fcoord );\n\n\t\/\/ feed forward of effective text resolution\n\tif( sc.x >= ADDR_D_TEXTSCALE && sc.y < 2 )\n\t\tfcolor = texelFetch( iChannel1, ivec2( ADDR_B_WAYPOINT_SAMPLE, 0 ), 0 ) \/ IMG_MIPMAP_HIDE;\n\n\t\/\/ direct sun visibility and vr flag\n\telse\n\tif( sc.x >= ADDR_D_SUN_VISIBILITY && sc.y < 2 )\n\t{\n\t\tvec3 T =\n\t\t\tac_transmittance( AC, GS.campos, LE.L, true ) *\n\t\t\ttexelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).w;\n\t\tfloat shadow =\n\t\t\tts_shadow_sample( TS, iChannel1, length_normalize( GS.campos ) ).x *\n\t\t\tscene_raycast_object_shadows( Ray( GS.campos, LE.L ) ) *\n\t\t\tatm_planet_shadow( dot( LE.L, normalize( GS.campos ) ), sqrt( max( 0., 1. - LE.radius * LE.radius \/ dot( GS.campos, GS.campos ) ) ), sqrt( LE.sundisk ) );\n\t\tfcolor.xyz = submerged ? ZERO : T * max( 0., 2. * shadow - 1. ) \/ IMG_MIPMAP_HIDE;\n\t\tfcolor.w = float( g_vrmode );\n\t}\n\n\t\/\/ feed forward of text formatting data\n\telse\n\tif( fcoord.y >= iResolution.y - 2. )\n\t\tfcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 ) \/ IMG_MIPMAP_HIDE;\n\n\t\/\/ terrain map\n\telse\n\tif( ( GS.switches & GS_TRMAP ) == GS_TRMAP )\n\t{\n\t\tfcolor.xyz = map_display( fcoord );\n\t}\n\n\t\/\/ main image\n\telse\n\tif( ray_ok )\n\t{\n\t\t\/\/ Buffer A\n\t\t\/\/ fcolor.xyz = saturate( .25 + .125 * texelFetch( iChannel0, ivec2( fcoord \/ 4. ), 0 ).xyz );\n\t\t\/\/ return;\n\n\t\t\/\/ Buffer B\n\t\t\/\/ fcolor.xyz = saturate( ts_unpack_normal( TS, texelFetch( iChannel1, ivec2( fcoord ), 0 ) ).xyz * .5 + .5 );\n\t\t\/\/ fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord ), 0 ).zzz \/ 16. );\n\t\t\/\/ fcolor.xyz = saturate( ( texelFetch( iChannel1, ivec2( fcoord ), 0 ).xyz \/ PD.radius - 1. ) \/ PD.trn.levels.y );\n\t\t\/\/ fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord ), 0 ).www \/ ( PD.radius * PD.trn.levels.y ) );\n\t\t\/\/ fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord.x, fcoord.y \/ 16. + iResolution.y * 15. \/ 16. ), 0 ).xyz );\n\t\t\/\/ return;\n\n\t\t\/\/ Buffer C\n\t\t\/\/ fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord \/ SCN_ATM_SUBSAMPLE_RATIO ), 0 ).xyz;\n\t\t\/\/ #if WITH_ATM_BILATERAL_UPSAMPLE\n\t\t\/\/\t  fcolor.xz = exp2( vec2( floor( fcolor.x ) \/ 128., fract( fcolor.x ) * 32. ) - 24. );\n\t\t\/\/ #endif\n\t\t\/\/ fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord \/ SCN_ATM_SUBSAMPLE_RATIO + vec2( 0, iResolution.y \/ 2. ) ), 0 ).xyz;\n\t\t\/\/ fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord \/ SCN_ATM_SUBSAMPLE_RATIO + vec2( iResolution.x \/ 2., 0 ) ), 0 ).xyz;\n\t\t\/\/ fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord \/ SCN_ATM_SUBSAMPLE_RATIO + iResolution.xy \/ 2. ), 0 ).xyz;\n\t\t\/\/ return;\n\n\t\tvec4 col = render( ray, uv, submerged );\n\t\tif( ( GS.switches & GS_TRMAP ) == 0u && ( GS.switches & GS_NVISN ) == GS_NVISN )\n\t\t\thmd_night_vision( col.xyz, g_vrmode ? fcoord.xy - unViewport.xy : fcoord.xy, cc );\n\t\tif( g_vrmode )\n\t\t\tcol \/= GS.camzoom;\n\t\tfcolor = clamp( col \/ max( 1., hmax( col ) \/ IMG_EXPOSURE_MAX ), 0., IMG_EXPOSURE_MAX );\n\t}\n#endif \/\/ RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n\t{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n\tg_vrmode = true;\n\tvec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n\tvec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tg_vrframe[1] = normalize( horz );\n\tg_vrframe[2] = normalize( down );\n\tg_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n\tvec3 cent = g_vrframe[0] * dot( forw, g_vrframe[0] ) - 2. * ( unCorners[0] - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n\tg_vrfocus.xy = vec2( dot( cent, g_vrframe[1] ) \/ dot( horz, g_vrframe[1] ), dot( cent, g_vrframe[2] ) \/ dot( -down, g_vrframe[2] ) );\n\tg_vrfocus.zw = dot( forw, g_vrframe[0] ) \/ vec2( dot( horz, g_vrframe[1] ), dot( down, g_vrframe[2] ) );\n\tmain_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dfGz4","date":"1363194052","viewed":8054,"name":"Voxel Tyre","username":"Dave_Hoskins","description":"Ray casting into a voxel scene, with reflections and shadows.","likes":101,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Voxel tyre\n\/\/ By       Dave Hoskins\n\n\n#define REFLECTIONS_ON\n\t\t\t\t\t\t\t\n#define PI  3.1415926535\n\nvec3 areaPlane = normalize(vec3(-1.0, 1.0, 1.0));\nvec3 lightDir = normalize(vec3(-337.0, 743.0, 330.0));\nmat3 rotateMat;\nfloat height;\n\n\n\nfloat deTorus( vec3 p, vec2 t )\n{\n\tp.y -= height;\n\tp = rotateMat * p;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat deTorusWarped( vec3 p, vec2 t, out int material)\n{\n\tp.y -= height;\n\tp = rotateMat * p;\n\tfloat l = length(p.xz);\n\tl= pow(l, 4.0) * .00008;\n\tvec2 q = vec2(l-t.x,p.y);\n\tif (q.x < -3.5) material = 2;\n\telse material = 3;\n\treturn length(q)-t.y;\n}\n\nfloat Scene(vec3 p, out int material)\n{\t\n    float d;\n\td = deTorusWarped(p, vec2(10.2,8.0), material);\n\tfloat d2 = deTorus(p, vec2(13.3, 4.5));\n\td = max(d, -d2);\n\td = min(d, p.y+4.0);\n\t\n    return d;\n}\n\n\/\/----------------------------------------------------------------------------\n\/\/ Voxel grid search that I found in 1994 in Graphics Gems IV - \"Voxel Traversal along a 3D Line\"!\n\/\/ This (Amanatides & Woo) varient is from another shader on here.\nfloat VoxelTrace(vec3 ro, vec3 rd, out bool hit, out vec3 hitNormal, out vec3 pos, out int material)\n{\n    const int maxSteps = 100;\n    vec3 voxel = floor(ro)+.501;\n    vec3 step = sign(rd);\n\t\/\/voxel = voxel + vec3(rd.x > 0.0, rd.y > 0.0, rd.z > 0.0);\n    vec3 tMax = (voxel - ro) \/ rd;\n    vec3 tDelta = 1.0 \/ abs(rd);\n    vec3 hitVoxel = voxel;\n\tint mat = 0;\n\t\n    hit = false;\n\t\n    float hitT = 0.0;\n    for(int i=0; i < maxSteps; i++)\n\t{\n\t\tif (!hit)\n\t\t{\n\t\t\tfloat d = Scene(voxel, mat);        \n\t\t\tif (d <= 0.0 && !hit)\n\t\t\t{\n\t\t\t\thit = true;\n\t\t\t\thitVoxel = voxel;\n\t\t\t\tmaterial = mat;\n                break;\n\t\t\t}\n\t\t\tbool c1 = tMax.x < tMax.y;\n\t\t\tbool c2 = tMax.x < tMax.z;\n\t\t\tbool c3 = tMax.y < tMax.z;\n\t\t\tif (c1 && c2) \n\t\t\t{ \n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(-step.x, 0.0, 0.0);\n\t\t\t\t\thitT = tMax.x;\n\t\t\t\t}\n\t\t\t\tvoxel.x += step.x;\n\t\t\t\ttMax.x += tDelta.x;\n\t\n\t\t\t} else if (c3 && !c1) \n\t\t\t{\n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(0.0, -step.y, 0.0);\t\n\t\t\t\t\thitT = tMax.y;\n\t\t\t\t}\n\t\t\t\tvoxel.y += step.y;\n\t\t\t\ttMax.y += tDelta.y;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(0.0, 0.0, -step.z);\t\t\n\t\t\t\t\thitT = tMax.z;\n\t\t\t\t}\n\t\t\t\tvoxel.z += step.z;\n\t\t\t\ttMax.z += tDelta.z;\n\t\t\t}\n\t\t}\n    }\n\tif (hit && (hitVoxel.x > 27.0 || hitVoxel.x < -27.0 || hitVoxel.z < -27.0 || hitVoxel.z > 27.0))\n\t{\n\t\thit = false;\n\t\treturn 1000.0;\n\t}\n\t\n\tpos = ro + hitT * rd;\n\treturn hitT;\n}\n\n\/\/----------------------------------------------------------------------------\n\/\/ Do all the ray casting for voxels...\nfloat TraceEverything(vec3 ro, vec3 rd, out int material, out vec3 hitNormal, out vec3 pos)\n{\n\tbool hit1;\n\tint hit2;\n\tvec3 pos2;\n    float dist = VoxelTrace(ro, rd, hit1, hitNormal, pos, material);\n\tif (hit1)\n\t{\n\t\tif (pos.y < -3.45)\n\t\t{\n\t\t\tmaterial = 1;\n\t\t}\t\t\n\t}else\n\t{\n\t\tmaterial = 0;\n\t}\n\treturn dist;\n}\n\n\/\/----------------------------------------------------------------------------\nbool TraceShadow(vec3 ro, vec3 rd)\n{\n\tbool hit;\n\tvec3 pos;\n\tvec3 hitNormal;\n\tint mat;\n\tfloat dist2 = VoxelTrace(ro+rd*0.6, rd, hit, hitNormal, pos, mat);\n\treturn hit;\n}\n\n\/\/----------------------------------------------------------------------------\nvec3 DoMaterialRGB(int m, vec3 pos, vec3 norm, vec3 rd, vec3 ro)\n{\n\tvec3 rgb;\n\tfloat diff = dot(norm, lightDir);\n    diff = max(diff, 0.0);\n    \/\/return diff *areaColor;\t\n\tif (m == 1)\n\t{\n\t\trgb = diff * vec3(0.1, 0.1, 0.1);\n\t\t\n\t}else\n\tif (m == 2)\n\t{\n\t\trgb = diff * vec3(1.0, 1.0, 1.0);\n\t\t\n\t}else\n\tif (m == 3)\n\t{\n\t\trgb = diff * vec3(0.2, 0.2, 0.2);\n\t\t\n\t}else\n\t{\n\t\trgb = mix(vec3(.0, .05, .1), vec3(0.4, 0.3, .6), abs(sin(rd.y*3.0)));\n    }\n\treturn rgb;\n}\n\n\/\/----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixel = (fragCoord.xy \/ iResolution.xy)*2.0-1.0;\n    float asp = iResolution.x \/ iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y-1.3, -3.0));\n    vec3 ro = vec3(0.0, 50.0, 90.0);\n\tmat3 matZ, matY;\n\n    float time = iTime * 3.1+230.0;\n\n\ttime = (cos(time \/ PI) + 1.0);\n\t\/\/ Rotate Z\n\tfloat z = time * .8;\n\tfloat sz = sin(z);\n\tfloat cz = cos(z);\n\tmatZ[0] = vec3(cz,\t\t-sz,\t0.0);\n\tmatZ[1] = vec3(sz,\t\tcz,\t\t0.0);\n\tmatZ[2] = vec3(0.0,\t0.0,\t1.0);\n\theight = (sz) *  14.0+4.0;\n\t\n\t\/\/ Rotate Y\n\tfloat y = time * 4.0*PI + PI*.5;\n\tfloat sy = sin(y);\n\tfloat cy = cos(y);\n\tmatY[0] = vec3(cy,\t\t0.0,\t-sy);\n\tmatY[1] = vec3(0.0,\t\t1.0,\t0.0);\n\tmatY[2] = vec3(sy,\t\t0.0,\t cy);\n\t\n\trotateMat = matZ * matY;\n\n\tvec3 rgb;\n    vec3 norm, pos;\n\tint material; \n\n\tTraceEverything(ro+rd*70.0, rd, material, norm, pos);\n\trgb = DoMaterialRGB(material, pos, norm, rd, ro);\n\t\n\t\/\/ Do the shadow casting...\n\tif (material > 0 && TraceShadow(pos+lightDir*.04, lightDir) == true)\n\t{\n\t\trgb *= .35;\n\t}\n\t\n\t\t\n#ifdef REFLECTIONS_ON\n\tif (material > 0 && material != 3)\n\t{\n\t\tro = pos;\n\t\trd = ((-2.0*(dot(rd, norm))*norm)+rd);\n\t\tTraceEverything(ro+rd*0.04, rd, material, norm, pos);\n\t\trgb = mix(rgb, DoMaterialRGB(material, pos, norm, rd, ro), .2);\n\t}\n#endif\n\n\t\/\/ Curve the brightness a little...\n\trgb = pow(rgb, vec3(.65, .65, .65));\n    fragColor=vec4(rgb, 1.0);\n}\n\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t   ","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldfXzS","date":"1403188726","viewed":8023,"name":"Wet Sand","username":"TekF","description":"Trying the nice surface shading tricks from my  on a landscape.>\nToggle Ambient Occlusion: A, Toggle Reflection Occlusion: S. View modes:Q,W,L","likes":81,"published":3,"flags":16,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Hazel Quantock 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ artefacts from noise texture interpolation\n\/\/#define FAST\n\n\/\/ keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n\/\/ TOGGLES:\n\n\/\/ demo mode - cycle through the effects\nconst int kDemoMode = kD;\n\n\/\/ aesthetic toggles\nint kAnimate = kA;  float pauseTime = 3.6;\n\/\/int kPrintedPaper = kP;\nint kLensFX = kL;\n\n\/\/ lighting\n\/\/int kLighting = k0; \/\/ turn all diffuse illumination on\/off (to see reflections better)\n\/\/int kAlbedo = k1;\n\/\/int kShadow = k2;\n\/\/int kDirectLight = k3;\n\/\/int kAmbientGradient = k4;\nint kAmbientOcclusion = kA;\nint kShowAmbientOcclusion = kQ;\n\n\/\/ specular\n\/\/int kSpecular = k9; \/\/ turn all specular on\/off (to see diffuse better)\n\/\/int kSpecularHighlight = kQ;\n\/\/int kFresnel = kW;\nint kReflectionOcclusion = kS;\n\/\/int kReflections = kR;\nint kShowSpecularOcclusion = kW;\n\n\n\/\/ key is javascript keycode: http:\/\/www.webonweboff.com\/tips\/js\/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)\/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val, int index )\n{\n\/\/ Toggles are breaking the compile! AARGH!\n\/\/ try removing a few of them, or something\n\/\/ mostly want to see spec\/amb occ\n\t\n\/*\tfloat cut = fract(iTime\/30.0)*11.0;\n\tif ( !ReadKey( kDemoMode, true ) && float(index) > cut )\n\t{\n\t\treturn false;\n\t}*\/\n\t\n\t\/\/ default everything to \"on\"\n\treturn !ReadKey( val, true );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n\t\/\/ On Chrome 36 I get an artefact where the texture wraps, so do the wrap manually\t\n\tuv = fract(uv\/256.0)*256.0;\n\n#ifdef FAST\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)\/256.0, 0.0 );\n#else\n\t\/\/ high precision interpolation, if needed\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+0.5)\/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (floor(uv)+1.5)\/256.0, 0.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nfloat Granite( in vec3 x )\n{\n\treturn (\n\t\t\t abs(Noise(x* 1.0).x-.5)\/1.0\n\t\t\t+abs(Noise(x* 2.0).x-.5)\/2.0\n\t\t\t+abs(Noise(x* 4.0).x-.5)\/4.0\n\t\t\t+abs(Noise(x* 8.0).x-.5)\/8.0\n\t\t\t+abs(Noise(x*16.0).x-.5)\/16.0\n\t\t)*32.0\/31.0;\n\/\/\t\t\t+abs(Noise(x*32.0).x-.5)\/32.0\n\/\/\t\t\t+abs(Noise(x*64.0).x-.5)\/64.0\n\/\/\t\t)*128.0\/127.0;\n}\n\n\nfloat DistanceField( vec3 p, float t )\n{\n\t\/\/return p.y;\n\t\/\/return (p.y - max(.0,Granite(p.xzy*vec3(1,1,0))-.5)) \/ 1.2;\n\n\/\/ this doesn't get good occlusion, because the lumps don't have a gradient to their sides\n\t\/\/return min(p.y, ( p.y - (Granite(p.xzy*vec3(1,1,0))-.5) ) \/ 1.2);\n\n\treturn min(p.y, ( p.y - (Granite(p)-.5) ) * (.65-.2*2.0\/max(2.0,t)) ); \/\/ adjust accuracy with depth\n}\n\nfloat DistanceField( vec3 p )\n{\n\treturn DistanceField( p, 0.0 );\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\n{\n\tvec3 ambient = vec3(.5);\n\/\/\tif ( Toggle(kAmbientGradient,2) )\n\t\tambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n\/\/\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); \/\/ ambient\n\t\/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\/\/\tocclusion = min( 1.0, occlusion ); \/\/ prevent excessive occlusion\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n\/\/\tocclusion *= mix(.5,1.0,pow(grainq,.2));\n\tif ( Toggle(kAmbientOcclusion,1) )\n\t\tambient *= occlusion;\n\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);\/\/pow(ndotl,2.0);\n\tvec3 light = vec3(0);\n\n\/\/\tif ( Toggle(kDirectLight,3) )\n\t\t\tlight += lightCol*shadowMask*ndotl;\n\n\tlight += ambient;\n\n\n\t\/\/ And sub surface scattering too! Because, why not?\n\tfloat transmissionRange = .1;\/\/distance\/5.0;\n\tfloat transmission = max( 0.0, DistanceField( pos + lightDir*transmissionRange )\/transmissionRange );\n\tvec3 subsurface = vec3(1,.8,.5) * .5 * lightCol * transmission;\n\/\/\tcommented out because it's a little buggy with small distances, and sand shouldn't have a lot of sss\n\/\/\tlight += subsurface;\n\n\n\tfloat specularity = smoothstep( .5,1.0, texture( iChannel0, pos.xz\/256.0 ).r )\n\t\t\t\t\t\t*pow(smoothstep( 0.05, 0.0, pos.y ),2.0); \/\/ don't let the lumps be too shiny\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tfloat specPower = exp2(3.0+6.0*specularity);\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower\/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = vec3(0);\n\t\n\/\/\tif ( Toggle(kReflections,6) )\n\t\treflection = Sky( rray );\n\t\n\t\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .05, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\t\n\/\/\tif ( !Toggle(kFresnel,8) )\n\/\/\t\tfresnel = 1.0; \/\/ chrome\n\t\n\tvec3 albedo = vec3(.5,.3,.13);\n\t\n\/\/\tif ( !Toggle(kAlbedo,5) ) albedo = vec3(1);\n\t\n\tvec3 result = vec3(0);\n\/\/\tif ( Toggle(kLighting,-1) )\n\t\tresult = light*albedo;\n\n\/\/\tif ( Toggle(kSpecular,6) )\n\t{\n\t\tresult = mix( result, reflection, fresnel );\n\t\n\/\/\t\tif ( Toggle(kSpecularHighlight,9) )\n\t\t\tresult += specular;\n\t}\n\n\tif ( !Toggle(kShowAmbientOcclusion,-1) )\n\t\tresult = vec3(occlusion);\n\n\tif ( !Toggle(kShowSpecularOcclusion,-1) )\n\t\tresult = vec3(specOcclusion);\n\t\n\treturn result;\n}\n\n\n\n\n\/\/ Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )\/\/|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tMin = min(h,Min);\n\t\tif ( \/*h < .001 ||*\/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t\/\/ in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .5 * t \/ iResolution.x;\n#ifdef FAST\n\t\/\/ don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0,t);\n\tfloat f1 = DistanceField(p1,t);\n\tfloat f2 = DistanceField(p2,t);\n\tfloat f3 = DistanceField(p3,t);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n\/\/ Camera\n\nvec3 Ray( float zoom, in vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible, float sky, in vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy\/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (((pow(l,30.0)+.05)*dirt*.1 + 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0, fragCoord);\n\t\n\tif ( Toggle(kLensFX,10) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(0);\n\tif ( iMouse.z > 0.0 )\n\t\tmouse = .5-iMouse.yx\/iResolution.yx;\n\t\t\n\tfloat T = iTime*.1;\n\tvec3 pos = 2.0*Rotate( ray, vec2(.2,2.8-T)+vec2(-.5,-6.3)*mouse );\n\tpos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tfloat top = .5, bottom = .0;\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,1,-2));\n\t\n\tfloat topIntersection = (top-pos.y)\/ray.y;\n\tfloat bottomIntersection = (bottom-pos.y)\/ray.y;\n\t\n\tfloat traceStart = .5;\n\tfloat traceEnd = 40.0;\n\t\n\tif ( ray.y > 0.0 )\n\t\ttraceEnd = min(traceEnd,topIntersection);\n\telse if ( ray.y < 0.0 )\n\t{\n\t\ttraceEnd = min(traceEnd,bottomIntersection);\n\t\tif ( pos.y > top )\n\t\t\ttraceStart = min(traceEnd,topIntersection);\n\t}\n\t\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t\/\/ shadow test\n\t\tfloat s = 0.0;\n\/\/\t\tif ( Toggle(kShadow,4) )\n\t\t\ts = Trace( p, lightDir, .05, (top-p.y)\/lightDir.y );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, vec3(1.1,1,.9), (s>.0)?0.0:1.0, t );\n\t\t\n\t\t\/\/ fog\n\t\tfloat f = 80.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX,10) )\n\t{\n\t\t\/\/ lens flare\n\t\tfloat sun = 1.0;\/\/TraceMin( pos, lightDir, .5, 40.0 );\n\t\tcol += LensFlare( ray, lightDir, smoothstep(-.04,.1,sun), step(t,.0),fragCoord );\n\t\n\t\t\/\/ vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t\/\/ compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); \/\/ soft abs\n\t\tcol = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\t\n\t\t\/\/ grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv\/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t}\n\t\n\tfragColor = vec4(pow(col,vec3(1.0\/2.6)),1);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dccR4","date":"1517976853","viewed":8022,"name":"Prism","username":"jpyepez","description":"The light that burns twice as bright burns for half as long, and you have burned so very, very brightly, yo.","likes":20,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 red = vec3(10., 2.5, 0.);\nconst vec3 green = vec3(0., 10., 2.5);\nconst vec3 blue = vec3(2.5, 0., 10.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy\/iResolution.xy;\n  st.x *= iResolution.x\/iResolution.y;\n  vec3 color = vec3(0.0);\n  vec3 color2 = vec3(0.0);\n  vec3 color3 = vec3(0.0);\n  vec3 color4 = vec3(0.0);\n  vec3 color5 = vec3(0.0);\n  vec3 color6 = vec3(0.0);\n\n  float off = (iResolution.x\/iResolution.y - 1.0)\/2.;\n  vec2 pos = vec2(0.5, 0.5)-vec2(st.x-off, st.y);\n\n  float r = length(pos)*2.0;\n  float a = atan(pos.y,pos.x) - iTime;\n  float f = 0.5*sin(12.*a)*cos(30.*a) + 0.25*tan(3.*a - 1.5);\n\n  float a2 = atan(pos.y,pos.x) - iTime*0.9;\n  float f2 = 0.5*sin(12.*a2)*cos(30.*a2) + 0.25*tan(3.*a2 - 1.5);\n\n  float a3 = atan(pos.y,pos.x) - iTime*0.8;\n  float f3 = 0.5*sin(12.*a3)*cos(30.*a3) + 0.25*tan(3.*a3 - 1.5);\n\n  float a4 = atan(pos.y,pos.x) - iTime*0.95;\n  float f4 = 0.5*sin(12.*a4)*cos(30.*a4) + 0.25*tan(3.*a4 - 1.5);\n\n  float a5 = atan(pos.y,pos.x) - iTime*0.85;\n  float f5 = 0.5*sin(12.*a5)*cos(30.*a5) + 0.25*tan(3.*a5 - 1.5);\n\n  float a6 = atan(pos.y,pos.x) - iTime*0.75;\n  float f6 = 0.5*sin(12.*a6)*cos(30.*a6) + 0.25*tan(3.*a6 - 1.5);\n\n  float func = 1.-smoothstep(f-1.,f+1.,r);\n  float func2 = 1.-smoothstep(f2-1.,f2+1.,r);\n  float func3 = 1.-smoothstep(f3-1.,f3+1.,r);\n  float func4 = 1.-smoothstep(f4-1.,f4+1.,r);\n  float func5 = 1.-smoothstep(f5-1.,f5+1.,r);\n  float func6 = 1.-smoothstep(f6-1.,f6+1.,r);\n\n  color = mix(vec3(0.), red, func);\n  color2 = mix(vec3(0.), green, func2);\n  color3 = mix(vec3(0.), blue, func3);\n  color4 = mix(vec3(0.), red, func4);\n  color5 = mix(vec3(0.), green, func5);\n  color6 = mix(vec3(0.), blue, func6);\n\n  float mixAmt = pow(distance(vec2(0.5), st), .707);\n\n  color = mix(color, color2, mixAmt);\n  color = mix(color, color3, mixAmt);\n  color = mix(color, color4, mixAmt);\n  color = mix(color, color5, mixAmt);\n  color = mix(color, color6, mixAmt);\n\n  color = mix(vec3(.1, 0., .2), color, smoothstep(0., 1.4142, 1.-length(pos)*2.));\n\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XtsXRX","date":"1438554186","viewed":8018,"name":"Crazy Waves","username":"Alkama","description":"A more hectic (and simpler) version of \"waves by bonniem\" https:\/\/www.shadertoy.com\/view\/4dsGzH","likes":55,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 wave_color = vec3(0.0);\n\n\tfloat wave_width = 0.0;\n\tuv  = -3.0 + 2.0 * uv;\n\tuv.y += 0.0;\n\tfor(float i = 0.0; i <= 28.0; i++) {\n\t\tuv.y += (0.2+(0.9*sin(iTime*0.4) * sin(uv.x + i\/3.0 + 3.0 *iTime )));\n        uv.x += 1.7* sin(iTime*0.4);\n\t\twave_width = abs(1.0 \/ (200.0*abs(cos(iTime)) * uv.y));\n\t\twave_color += vec3(wave_width *( 0.4+((i+1.0)\/18.0)), wave_width * (i \/ 9.0), wave_width * ((i+1.0)\/ 8.0) * 1.9);\n\t}\n\n\tfragColor = vec4(wave_color, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dl3W8","date":"1369089194","viewed":7994,"name":"Phoning Home","username":"movAX13h","description":"E.T. The Extra Terrestrial finally phoning home. Mouse enabled. Background \"warp speed\" shader by Dave Hoskins.","likes":59,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ \"phoning home\" fragment shader by movAX13h, May 2013\n\n\/\/ A fragment shader heavily inspired by T-Shirt artwork (I dont know the artist):\n\/\/ http:\/\/empoz.com\/shopping\/images\/medium\/mpd\/GP019-BLK-Funny-ET-Telephone-tee-shirt_MED.jpg\n\n\/\/ This was my first raymarching shader.\n\n\/\/ Using some of iqs distance functions.\n\/\/ Fragments of code borrowed from all over ShaderToy.\n\n\/\/ There is no real lighting in this scene, transparency and illumination is\n\/\/ based on the distance of the ray inside the main box and is not accurate because\n\/\/ the value is incremented inside the marcher which does not march the same number\n\/\/ of steps for all pixels. This effect fits the flat style of E.T and the cell, so I kept it.\n\/\/ Anyways, by commenting the following line, everything \"light\" is off.\n#define ILLUMINATION\n\n\/\/ Uncomment the following define to enable Dave Hoskins' \"Warp speed\" shader \n\/\/ in the background (https:\/\/www.shadertoy.com\/view\/Msl3WH)\n\/\/ Daves shader is based on Kalis \"Cosmos\" shader (https:\/\/www.shadertoy.com\/view\/MssGD8)\n\/\/ I liked it so much, I had to see how it combines :)\n#define WARP_SHADER\n\n\nfloat udBox( vec3 p, vec3 b ) \n{\t\n\treturn length(max(abs(p)-b,0.0)); \n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length(pa - ba*h) - r;\n}\n\nfloat time;\n\nvec4 scene(vec3 p, inout float t, inout vec3 tcol)\n{\n\tfloat d, d1, d2, d3, d4, d5, f, v;\n\t\n\t#ifdef ILLUMINATION\n\tvec3 col = vec3(0.06, 0.06, 0.16);\n\t#else\n    vec3 col = vec3(1.0);\n\t#endif\n\t\n\t\/\/ cell\n\td1 = sdBox(p, vec3(0.6, 1.2, 0.5));\n\tv = sdBox(p-vec3(0.0, 0.01, 0.0), vec3(0.58, 1.1, 0.48)); \/\/ along y\n\td3 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.58, 0.97, 0.7)); \/\/ along z\n\td4 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.7, 0.97, 0.48)); \/\/ along x\n\td = max(-d4, max(-d3, max(-v, d1)));\n\t\n\t\/\/ sash bars\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, 0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, -0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.58, 0.05, 0.0), vec3(0.01, 0.01, 0.48)));\n\td = min(d, udBox(p-vec3(0.58, 0.02, 0.0), vec3(0.01, 1.0, 0.01)));\n\n\t\/\/ inner life\n\tif (v < 0.0) \n\t{\n\t\t\/\/ phone & handset\n\t\t\/\/d1 = 100.0;\n\t\t\/\/d2 = 100.0;\n\t\td1 = udRoundBox(p-vec3(-0.493, 0.1, 0.22), vec3(0.05, 0.3, 0.16), 0.02);\n\t\td2 = udRoundBox(p-vec3(-0.475, 0.2, 0.22), vec3(0.07, 0.26, 0.16), 0.02);\n\t\td3 = sdSegment(p, vec3(0.03 , -0.1 , 0.2), vec3(-0.1 , 0.02 , 0.16), 0.03);\n\t\td4 = udRoundBox(p-vec3(0.03 , -0.14 , 0.2), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td5 = udRoundBox(p-vec3(-0.12 , 0.0 , 0.16), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\t\n\t\t\/\/ cable\n\t\tif (abs(p.x+0.16) < 0.22) \n\t\t{\n\t\t\td = min(d, sdSegment(p, vec3(p.x     , -0.23 + sin( p.x     *12.0)*0.2, 0.2), \n\t\t\t\t\t\t \t\t    vec3(p.x-0.1 , -0.23 + sin((p.x-0.1)*12.0)*0.2, 0.2), 0.01));\n\t\t}\n\t\t\n\t\t\/\/ E.T.\n\t\t\n\t\t\/\/ head\t\n\t\td1 = sdSegment(p, vec3(0.11  , 0.42 , 0.12), vec3(0.11  , 0.43 , -0.12), 0.1); \/\/ eyes\n\t\td2 = sdSegment(p, vec3(0.05  , 0.34 , 0.0), vec3(0.38 , 0.3 ,  0.0), 0.1); \/\/ mouth area\n\t\td3 = sdSegment(p, vec3(0.17 , 0.44 , 0.0),  vec3(0.38 , 0.3 ,  0.0), 0.13); \/\/ skull\n\t\td4 = sdSegment(p, vec3(0.35  , 0.31 , 0.0),  vec3(0.38 , -0.2  ,  0.0), 0.06); \/\/ neck\n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\/\/ pointing arm\/hand\n\t\td1 = sdSegment(p, vec3( 0.2 , -0.18 , -0.18),  vec3(-0.08  , -0.04 , 0.0), 0.05);\n\t\td2 = sdSegment(p, vec3(-0.1 , -0.04  ,  0.0), vec3(-0.13 , 0.29 , 0.11), 0.03);\n\t\td = min(d, min(d2,d1));\n\t\t\n\t\t\/\/ fingers\n\t\td1 = sdSegment(p, vec3(-0.13 , 0.32 , 0.11), vec3(-0.4  , 0.5+p.x*0.3 , 0.14), 0.012); \/\/ pointing\n\t\td2 = sdSegment(p, vec3(-0.12 , 0.31 , 0.12), vec3(-0.24 , 0.33  , 0.1), 0.014); \/\/ angled\n\t\td3 = sdSegment(p, vec3(-0.25 , 0.33  , 0.1), vec3(-0.26 , 0.28  , 0.1), 0.012);\n\t\td4 = sdSegment(p, vec3(-0.13 , 0.31 , 0.13), vec3(-0.25 , 0.3 , 0.15), 0.014); \/\/ thumb\n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\/\/ other arm\n\t\td1 = sdSegment(p, vec3(0.2, -0.14, 0.18), vec3(0.21, -0.3, 0.2), 0.05);\n\t\td2 = sdSegment(p, vec3(0.21, -0.3, 0.2), vec3(0.03, -0.1, 0.2), 0.04);\n\t\td = min(d, min(d2, d1));\n\t\t\n\t\t\/\/ body & legs\n\t\td1 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, 0.1), 0.23);\n\t\td2 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, -0.1), 0.23);\n\t\td3 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.18, -0.72, 0.0), 0.23);\n\t\td4 = sdSegment(p, vec3(0.27, -0.72, 0.16), vec3(0.28, -1.0, 0.14), 0.1);\n\t\td5 = sdSegment(p, vec3(0.28, -0.72, -0.16), vec3(0.28, -1.0, -0.14), 0.1);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\n\t\t\/\/ finger tip light\n\t\tfloat blink = mod(floor(time*10.0), 2.0);\n\t\tf = length(vec3(-0.4, 0.38, 0.14)-p);\n\t\ttcol += blink*0.04*smoothstep(0.2, 0.0, f)*vec3(0.2, 0.08, 0.0);\n\t\ttcol = mix(tcol, vec3(0.9, 0.08, 0.0), blink*smoothstep(0.06, 0.0, f));\n\t\tt += blink*0.1*smoothstep(0.2, 0.0, f);\n\t\t\n\t\t\/\/ glass\n\t\tt = max(0.2, t + 0.04 + 0.02*sin(p.y*5.0+time));\n\t\ttcol += smoothstep(0.1, 1.2, p.y*0.3)*(1.0-tcol);\n\t\t\n\t\t\/\/ flies\n\t\tf = length(0.3*vec3(sin(time*0.2+66.0), 3.2+sin(time*0.7)*0.5, cos(time*0.6))-p);\n\t\td = min(d, f - 0.01);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.4*vec3(sin(-time*0.4), 3.3+sin(-t*0.5)*cos(t+100.0), sin(time*0.34+32.0))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.36*vec3(sin(time*0.6), 3.4+sin(time*0.5)*sin(-time*0.2), sin(-time*0.3))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\n\t\t\/\/ swirl\n\t\t\/*\n\t\td1 = 0.1*sin((p.y+time)*8.0);\n\t\td2 = 0.1*cos((p.y+time)*8.0);\n\t\td3 = sdSegment(p, vec3(d1 , mod(time*6.0, 8.0) - 4.0, d2),  \n\t\t\t\t\t\t  vec3(d1 , mod(time*6.0, 8.0) - 2.0, d2), 0.47);\n\t\t\n\t\ttcol = mix(tcol, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(-0.5,0.0, d3));\n\t\tif (d3 < 0.0) t += 0.1;\n\t\t*\/\n\t}\t\n\t\n\treturn vec4(col, d);\n}\n\nvec3 Dave_Hoskins_Warp_Shader(in vec2 fragCoord)\n{\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tfloat t = time*0.005;\n\tuv.x = (uv.x * iResolution.x \/ iResolution.y) + sin(t)*.5;\n\tfloat si = sin(t+2.17); \/\/ ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p= vec3(0.3, 0.2, floor(time) * 0.0008) + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z,2.0);\n\t\tfor (int i=0; i < 10; i++) p = abs(p*2.04) \/ dot(p, p) - 0.75;\n\t\tv += length(p*p)*smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t#ifdef WARP_SHADER\n\ttime = (iTime+2.4) * 60.0;\n\tvec3 col = Dave_Hoskins_Warp_Shader(fragCoord);\n\t#endif\n\t\n\ttime = iTime + 7.3;\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n\t\n    float focus = 3.0;\n    float far = 9.0;\n\t\n\tfloat atime = time*0.4;\n\tvec3 cp = vec3(2.0+sin(atime)*3.0, 0.6+sin(atime)*0.6, 5.0+cos(atime)); \/\/ anim perspective\n  \t\/\/vec3 cp = vec3(sin(iTime)*6.0, .0, cos(iTime)*6.0);\n  \t\/\/vec3 cp = vec3(sin(iTime)*4.0, sin(iTime*2.0)*0.7, cos(iTime)*7.0); \n\t\n\tif (iMouse.z > 0.0)\n\t{\n\t\tfloat d = (iResolution.y-iMouse.y)*0.01+3.0;\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, .0, cos(iMouse.x*0.01)*d);\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(sin(time), 1.0, cos(time));\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\n\t\n    vec3 ray = cp;\n\tfloat dist = 0.0;\n    vec4 s;\n\t\n\tfloat t = 0.06;\n\tvec3 tcol = vec3(0.0, 0.5, 0.7);\n\t\n    for(int i=0; i < 40; i++) \n\t{\n        s = scene(ray, t, tcol);\n\t\t\n        dist += s.w;\n        ray += dir * s.w;\n\t\t\n        if(s.w < 0.01) break;\n\t\t\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\t\n\t#ifndef ILLUMINATION\n\tt = 0.0;\n\t#endif\n\t\n    float b = 1.0 - dist\/far;\n\tvec3 c = mix(vec3(b * s.rgb), tcol, t);\n\t\n\t#ifdef WARP_SHADER\n\tcol = mix(c, col, smoothstep(0.5, 0.99, min(0.7-b, 1.0-t))); \/\/ mix shaders\n    fragColor = vec4(col, 1.0);\n\t#else\n\tfragColor = vec4(c, 1.0);\n\t#endif\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MlSSR1","date":"1441531936","viewed":7990,"name":"Metaeaux - Sunset","username":"metaeaux","description":"My first procedural world :)\nMountains, sunset, stars, wind, clouds.. I think perhaps it needs a lake next!","likes":93,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p\/256.0, -100. ).x;\n    return f\/0.9375;\n}\n\nvec2 map (in vec3 p) {\n\tfloat mountains = 19. * fbm(p.xz*0.091);\n    float trees = -.35 * fbm(p.xz*10.);\n    float rocks = -.002 * fbm(p.xz*100.);\n    float result = p.y + mountains + trees; \/\/ + rocks;\n    \n    return vec2(result, 1.0);\n}\n\nvec3 mapColour (in vec3 pos, in vec3 nor) {    \n    float darken = (1.0 - 0.5 * length(normalize(pos)));\n\tvec3 tint = vec3(.7, .7, .6);\n    vec3 texture = texture( iChannel1, 0.006125*pos.xz, -100. ).xyz;\n    \n    return  texture * tint;\n}\n\nvec2 raymarch (in vec3 ro, in vec3 rd) {\n    vec2 h = vec2(0.001, 0.);\n    float t = 0.;\n    float tmax = 100.;\n    \n    for (int i = 0; i < 100; i++){\n        if (abs(h.x) < 0.001*t || t > tmax) break;\n        h = map(ro + t * rd);\n        t += 0.25 * h.x;\n    }\n    \n    if(t > tmax) h.y = -1.;\n    \n    return vec2(t, h.y);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h\/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    \/\/ show more detail the closer we are to the object\n    vec3  eps = vec3(0.002 * t,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\n    \/\/ camera\n\tfloat an1 = 0.2*iTime-6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6*sin(2.2+iTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 10.0*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1) ));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv - 1.4*ww );\n\n    \/\/ raymarch\n    vec3 col =  vec3(0.);\/\/texture( iChannel0, rd ).xyz;\n    vec2 march = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(0.9, 0.1, 0.9));\n    vec3 ambient = 5. * vec3(0.1, 0.15, 0.2);\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 pos = ro + march.x * rd;\n    \n    \/\/ if we hit geometry\n    if(march.y > 0.) {\n        vec3 nor = calcNormal(pos, march.x);\n        \n        float lambert = clamp(dot(nor, light), 0., 1.);\n        col = mapColour(pos, nor);\n        col = mix( col, mapColour(pos, nor) * lambert, 0.8);\n        \n        \/\/snow\n        \/\/float snow = clamp(dot(normalize(nor), vec3(0., 1., 0.)), 0., 1.);\n        \/\/snow = pow(snow, 5.);\n        \/\/col = mix(col, vec3(1.)*snow, clamp(rd.y + 1., 0., 1.)*0.5);\n        \n        \/\/ fog\n        float fo = 1.-exp(-0.04*march.x );\n        vec3 fco = 0.9*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n        \n        float sh = shadow( pos, light, 10.);\n    \tcol = 0.8*col + 0.2* col* sh ;\/\/ + ambient * (1.0 - sh);\n    }\n    \n    \/\/ sky\n    if(march.y < 0.){\n        \/\/ sky colour        \n        vec3 blueSky = vec3(0.3,.55,0.8);\n        vec3 redSky = vec3(0.8,0.8,0.6);\n        \n        vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n        \n        col =  sky*(1.0-0.8*rd.y);\n        \n        \/\/ stars\n        float s = texture( iChannel0, rd.xz * 1.25, -100. ).x;\n        s += texture( iChannel0, rd.xz* 4., -100. ).x;\n        \n        s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n        if (s > .0)\n        {\n            vec3 backStars = vec3(s);\n            col += backStars;\n        }\n        \n        \/\/ sun\n        col += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n        col += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n        col += 0.95*vec3(1.)*pow(sundot, 256.);\n        \n        \/\/ clouds\n        float cloudSpeed = 0.01;\n        float cloudFlux = 0.5;\n        \n        \/\/ layer 1\n        vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n        \n\t\tvec2 sc = cloudSpeed * 50.*iTime * ro.xz + rd.xz*(1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        \/\/ cloud layer 2\n        sc = cloudSpeed * 30.*iTime * ro.xz + rd.xz*(500.0-ro.y)\/rd.y;\n\t\tcol = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        \/\/ horizon        \n        col = mix( col, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n        \n    }\n    \/\/ contrast\n    col = clamp(col, 0., 1.);\n    col = col*col*(3.0-2.0*col);\n    \n    \n    \/\/ saturation (amplify colour, subtract grayscale)\n    float sat = 0.2;\n    col = col * (1. + sat) - sat*dot(col, vec3(0.33));\n    \n    \/\/ vignette\n    col = col * (1.0 - dot(p, p) * 0.1);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Md23Wz","date":"1386531457","viewed":7968,"name":"Mars Jetpack","username":"Dave_Hoskins","description":"Uses sphere tracing to accumulate normals across the landscape. Materials are calculated after the tracing loop, so only the normal can be used as reference. Sphere diameter to create depth of field is distance squared.  http:\/\/youtu.be\/2eSb8zB4dBo","likes":78,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sl3Rr","filepath":"https:\/\/soundcloud.com\/etokaminiature\/zzzzra-vertige-version-excessive","previewfilepath":"https:\/\/soundcloud.com\/etokaminiature\/zzzzra-vertige-version-excessive","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Mars Jetpack. By David Hoskins, December 2013.\n\/\/ https:\/\/www.shadertoy.com\/view\/Md23Wz\n\n\/\/ YouTube:-\n\/\/ http:\/\/youtu.be\/2eSb8zB4dBo\n\n\/\/ Uses sphere tracing to accumulate direction normals across the landscape.\n\/\/ Materials are calculated after the tracing loop,\n\/\/ so only the normal can be used as reference.\n\/\/ Sphere diameter to create depth of field is distance squared.\n\n\/\/ For red\/cyan 3D. Red on the left.\n\/\/ #define STEREO\n\n\/\/ Uncomment this for a faster landscape that uses a texture for the fractal:-\n#define FASTER_LANDSCAPE\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .75, .5);\nvec2 coord;\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*33753.545383);\n}\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)\/(b-a),0.,1.);\n\n}\n\n#ifdef FASTER_LANDSCAPE\n\/\/--------------------------------------------------------------------------\n\n#define STEP (1.0\/256.0)\nvec3 NoiseD( in vec2 p )\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    vec2 u = f*f*(1.5-f)*2.0;\n    vec4 n;\n\tn.x = textureLod( iChannel0, (p+vec2(0.5,0.5))*STEP, 0.0 ).x;\n\tn.y = textureLod( iChannel0, (p+vec2(1.5,0.5))*STEP, 0.0 ).x;\n\tn.z = textureLod( iChannel0, (p+vec2(0.5,1.5))*STEP, 0.0 ).x;\n\tn.w = textureLod( iChannel0, (p+vec2(1.5,1.5))*STEP, 0.0 ).x;\n\n    \/\/ Normally you can make a texture out of these 4 so\n    \/\/ you don't have to do any of it again...\n    n.yzw = vec3(n.x-n.y-n.z+n.w, n.y-n.x, n.z-n.x);\n    vec2 d = 6.0*f*(f-1.0)*(n.zw+n.y*u.yx);\n    \n\treturn vec3(n.x + n.z * u.x + n.w * u.y + n.y * u.x * u.y, d.x, d.y);\n}\n#else\n\n\n\n\/\/--------------------------------------------------------------------------\nvec3 NoiseD( in vec2 x )\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\t\/\/vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    float n = p.x + p.y*57.0;\n\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n#endif\n\/\/--------------------------------------------------------------------------\n#define START_HEIGHT 400.0\n#define WARP  .15\n#define SCALE  .002\n#define HEIGHT 40.0\n#define LACUNARITY 1.83\nconst mat2 rotate2D = mat2(1.732, 1.543, -1.543, 1.782);\nfloat Terrain( in vec2 p)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 5; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n\t\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Terrain2( in vec2 p, in float sphereR)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 8; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp * .5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Terrain3( in vec2 p)\n{\n\tp *= SCALE;\n\t float sum = 0.0;\n\t float freq = 1.0;\n\tfloat amp = 3.5;\n\t vec2 dsum = vec2(0,0);\n\n\t for(int i=0; i < 3; i++)\n\t {\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT+20.0;\n\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n    return p.y - h;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.015,0.0,.01), vec3(.42, .2, .1), v);\n\t\/\/sky *= smoothstep(-0.3, .0, rd.y);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(float t)\n{\n\tt = abs(t-250.0);\n\tt *= 0.01;\n\treturn clamp(t*t, 50.0\/iResolution.y, 80.0);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0));\n\tmat += vec3(0.04, .02,.02) * max(normal.y, 0.0);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 j = vec2(sphereR, 0.0);\n\tvec3 nor  \t= vec3(0.0,\t\tTerrain2(p.xz, sphereR), 0.0);\n\tvec3 v2\t\t= nor-vec3(j.x,\tTerrain2(p.xz+j, sphereR), 0.0);\n\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain2(p.xz-j.yx, sphereR), -j.x);\n\tnor = cross(v2, v3);\n\treturn normalize(nor);\n}\n\n\/\/--------------------------------------------------------------------------\nvec4 Scene(in vec3 rO, in vec3 rD)\n{\n    \/\/float t = 0.0;\n\tfloat t = 20.0 * texture(iChannel0, coord.xy \/ iChannelResolution[0].xy).y;\n\tfloat alpha;\n\tvec4 normal = vec4(0.0);\n\tvec3 p = vec3(0.0);\n\tfloat oldT = 0.0;\n\tfor( int j=0; j < 105; j++ )\n\t{\n\t\tif (normal.w >= .8 || t > 1400.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the normals...\n\t\t\t\/\/vec3 nor = GetNormal(rO + BinarySubdivision(rO, rD, t, oldT, sphereR) * rD, sphereR);\n\t\t\tvec3 nor = GetNormal(p, sphereR);\n\t\t\talpha = (1.0 - normal.w) * ((sphereR-h) \/ sphereR);\n\t\t\tnormal += vec4(nor * alpha, alpha);\n\t\t}\n\t\toldT = t;\n\t\tt +=  h*.5 + t * .003;\n\t}\n\tnormal.xyz = normalize(normal.xyz);\n\t\/\/ Scale the alpha up to 1.0...\n\tnormal.w = clamp(normal.w * (1.0 \/ .8), 0.0, 1.0);\n\t\/\/ Fog...   :)\n\tnormal.w \/= 1.0+(smoothstep(300.0, 1400.0, t) * 2.0);\n\treturn normal;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec2 p = vec2(400.0 * sin(3.54*t), 400.0 * cos(2.0*t) );\n\treturn vec3(p.x+440.0,  0.0, p.y+10.0);\n} \n\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.2\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.4\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Noise...\n\t\/\/ rgb = clamp(rgb+Hash(xy*iTime)*.1, 0.0, 1.0);\n\t\/\/ Vignette...\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*300.0;\n\tfloat gTime = (iTime*8.0+m+2321.0)*.006;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    coord = fragCoord \/ iChannelResolution[0].xy;\n\tvec3 camTar;\n\t\n\tfloat hTime = mod(gTime+1.95, 2.0);\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos = CameraPath(gTime + 0.0);\n\n\t\/\/float height = 300.-hTime*24.0;\n\tfloat height = (smoothstep(.3, 0.0, hTime) + smoothstep(1.7, 2.0, hTime)) * 400.0;\n\tcamTar\t = CameraPath(gTime + .3);\n\tcameraPos.y += height;\n\t\n\tfloat t = Terrain3(CameraPath(gTime + .009).xz)+20.0;\n\tif (cameraPos.y < t) cameraPos.y = t;\n\tcamTar.y = cameraPos.y-clamp(height-40.0, 0.0, 100.0);\n\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += 1.5*cu*isRed; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tvec4 normal;\n\tnormal = Scene(cameraPos, dir);\n\t\n\tcol = mix(vec3(.4, 0.5, 0.5), vec3(.7, .35, .1),smoothstep(0.8, 1.1, (normal.y)));\n\tcol = mix(col, vec3(0.17, 0.05, 0.0), clamp(normal.z+.2, 0.0, 1.0));\n\tcol = mix(col, vec3(.8, .8,.5), clamp((normal.x-.6)*1.3, 0.0, 1.0));\n\n\tif (normal.w > 0.0) col = DoLighting(col, normal.xyz, dir);\n\n\tcol = mix(GetSky(dir), col, normal.w);\n\n\t\/\/ bri is the brightness of sun at the centre of the camera direction.\n\t\/\/ Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.7;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t\/\/ glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t\/\/ glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t\/\/ glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, .5, 0.5) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldsGDn","date":"1367873261","viewed":7965,"name":"Just snow","username":"baldand","description":"Simple (but not cheap) snow made from multiple parallax layers with randomly positioned flakes and directions. \nAlso includes a DoF effect. Pan around with mouse.","likes":99,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Copyright (c) 2013 Andrew Baldwin (twitter: baldand, www: http:\/\/thndl.com)\n\/\/ License = Attribution-NonCommercial-ShareAlike (http:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/deed.en_US)\n\n\/\/ \"Just snow\"\n\/\/ Simple (but not cheap) snow made from multiple parallax layers with randomly positioned \n\/\/ flakes and directions. Also includes a DoF effect. Pan around with mouse.\n\n#define LIGHT_SNOW \/\/ Comment this out for a blizzard\n\n#ifdef LIGHT_SNOW\n\t#define LAYERS 50\n\t#define DEPTH .5\n\t#define WIDTH .3\n\t#define SPEED .6\n#else \/\/ BLIZZARD\n\t#define LAYERS 200\n\t#define DEPTH .1\n\t#define WIDTH .8\n\t#define SPEED 1.5\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uv = iMouse.xy\/iResolution.xy + vec2(1.,iResolution.y\/iResolution.x)*fragCoord.xy \/ iResolution.xy;\n\tvec3 acc = vec3(0.0);\n\tfloat dof = 5.*sin(iTime*.1);\n\tfor (int i=0;i<LAYERS;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uv*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime\/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)\/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\ts += .01*abs(2.*fract(10.*q.yx)-1.); \n\t\tfloat d = .6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .005+.05*min(.5*abs(fi-5.-dof),1.);\n\t\tacc += vec3(smoothstep(edge,-edge,d)*(r.x\/(1.+.02*fi*DEPTH)));\n\t}\n\tfragColor = vec4(vec3(acc),1.0);\n}","name":"","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=852&num=12">72</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=864&num=12">73</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=876&num=12">74</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=888&num=12">75</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=900&num=12">76</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=852&num=12">72</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=864&num=12">73</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=876&num=12">74</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=888&num=12">75</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=900&num=12">76</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
