<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (82) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XdG3zd","date":"1455903572","viewed":7379,"name":"Where the River Goes (+ PostFX)","username":"P_Malin","description":"Modification of https:\/\/www.shadertoy.com\/view\/Xl2XRW \nNow using multipass to add depth of field and (a small amount of) bloom.\nPlus a couple of other tweaks","likes":117,"published":3,"flags":97,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsX3DN","filepath":"https:\/\/soundcloud.com\/soundholder\/subtle-river-flow-stereo-ms","previewfilepath":"https:\/\/soundcloud.com\/soundholder\/subtle-river-flow-stereo-ms","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Where the River Goes (+PostFX)\n\/\/ @P_Malin\n\n\/\/ Modification of https:\/\/www.shadertoy.com\/view\/Xl2XRW \n\/\/ Now using multipass to add depth of field and (a small amount of) bloom\n\/\/ plus a couple of other tweaks\n\n\/\/ Image shader - final postprocessing (Bloom + tonemap)\n\n#define KERNEL_SIZE 6\n#define BLOOM_STRENGTH 80.0\n\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n#define KERNEL_SIZE_F float(KERNEL_SIZE)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fY = -KERNEL_SIZE_F;\n    for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n    {\n        float fX = -KERNEL_SIZE_F;\n\t    for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n        {            \n\n            vec2 vOffset = vec2( fX, fY );\n            vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) \/ iResolution.xy;\n\n            vec4 vTapSample = texture( iChannel0, vTapUV ).rgba;\n            \n            vec2 vDelta = vOffset \/ KERNEL_SIZE_F;\n            \n            float f = dot( vDelta, vDelta );\n            float fWeight = exp2( -f * BLOOM_STRENGTH );\n            vResult += vTapSample.xyz * fWeight;\n            fTot += fWeight;\n            \n\t        fX += 1.0;\n        }\n        \n        fY += 1.0;\n    }\n    vResult \/= fTot;\n        \n\tvec2 vUV = fragCoord\/ iResolution.xy;\n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.75;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vFinal = ApplyVignetting( vUV, vInput );\t\n\t\n\tvFinal = Tonemap(vFinal * 1.5);\n\t    \n\treturn vFinal;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Where the River Goes (+PostFX)\n\/\/ @P_Malin\n\n#define ENABLE_WATER\n#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n#define ENABLE_CONE_STEPPING\n\n\n\/\/ Textureless version\n\/\/#define ENABLE_NIMITZ_TRIANGLE_NOISE\n\n\/\/#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n\/\/#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#ifndef ENABLE_SCREENSHOT_MODE\nconst int k_raymarchSteps = 64;\nconst int k_fbmSteps = 3;\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fbmSteps = 5;\n#endif\n\nconst int k_fbmWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 8.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.6, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\nconst vec3 k_fogColour = (k_bgSkyColourUp + k_bgSkyColourDown) * 0.5;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nvec2 Hash2( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fbmSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<k_fbmWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 \/ (1.0 + fDist * 1.5);\n    vFlow *= 1.0 \/ (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    \/\/vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;\/\/ - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    \/\/fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    \/\/fFoam = fFoam \/ fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 \/ (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); \/\/ flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) \/ fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 \/ (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    \/\/weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); \/\/ represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG \/ fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        \/\/ into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y \/ vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n\/\/ https:\/\/www.shadertoy.com\/view\/4ts3z2\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat triNoise(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += dg;\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n           \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}    \n#endif\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal +triNoise(vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );    \n#else\n    #if 0\n    surface.m_albedo = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 samp;\n    samp = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    col += samp * samp * vWeights.y;\n    samp = texture( iChannel0, intersection.m_pos.xy ).rgb;\n    col += samp * samp * vWeights.z;\n    samp = texture( iChannel0, intersection.m_pos.yz ).rgb;\n    col += samp * samp * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    \n    float fBlend = clamp( surface.m_pos.y, 0.0f, 1.0f );\n    col.g = mix( col.g, sqrt(col.g) * 0.8, fBlend );\n    surface.m_albedo = col;\n    #endif\n#endif    \n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t\/\/vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir, float fCloudScale )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n\n    float fCloud = texture( iChannel1, vRayDir.xz * 0.01 \/ (vRayDir.y) ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    fCloud *= fCloudScale;\n    vSkyColour = mix( vSkyColour, vec3(8.0), fCloud );    \n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir, 1.0 );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir, out float fSceneDistance )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir, 1.0 );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            \/\/ lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) \/ vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 \/ 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); \/\/ note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            \/\/ add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); \/\/ would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);\/\/ * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif \/\/ #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            primarySurface.m_gloss = clamp( 0.9 - (primarySurface.m_albedo.g - primarySurface.m_albedo.r) * 5.0, 0.0, 1.0);\n\n            float fWaterLine = 0.08;\n            float fWetness = clamp( 1.0 - (vReflectRayOrigin.y + 0.04) \/ fWaterLine , 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_gloss, 0.95, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n            \n            \/\/primarySurface.m_albedo = mix( primarySurface.m_albedo, vec3(1.0, 0.0, 0.0), fWetness );\n\n            \n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n\n    float fCloudScale = 0.0;\n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n        fCloudScale = 1.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir, fCloudScale);    \n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    fSceneDistance = fFogDistance;\n    \n    return vResult;\n}\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.5;\n    float fFocalLength = 0.02;\n  \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_fTime = iTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t\/\/ Static camera locations\n    \/\/fCameraTime = 146.0; \/\/ some rocks\n    \n    vec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 \/ iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 \/ iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n    float fSceneDistance = 0.0;\n    \n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fSceneDistance);\n\t\n    vec3 vFinal = vResult;\n\n    vec3 vCameraForwards = normalize(vCameraTarget- vCameraPos);\n    float fPlaneInFocus = vCameraPos.y \/ -vCameraForwards.y;\n    \n    float fCoC = GetCoC( fSceneDistance, fPlaneInFocus );\n    \n\tfragColor = vec4(vFinal, fCoC);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    g_fTime = iTime;\n    \n    fragRayOri = fragRayOri.zyx;\n    fragRayDir = fragRayDir.zyx;\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 0.1;\n    \n    fragRayOri.y += 0.2;\n    \n    fragRayOri.x -= g_fTime * 0.1;\n    fragRayOri.z += GetRiverMeander( fragRayOri.x );\n    \n    float fSceneDistance = 0.0;\n    \n    vec3 vResult = GetSceneColour(fragRayOri, fragRayDir, fSceneDistance);\n    \t    \n\tfragColor = vec4(vResult, 0.0);    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Where the River Goes (+PostFX)\n\/\/ @P_Malin\n\n\/\/ Depth of field\n\n#define BLUR_TAPS 32\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n    vec4 vSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\tfloat fCoC = abs(vSample.w);\n\t        \n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n        \n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    vResult.rgb = vSample.rgb * fCoC;\n    fTot += fCoC;\n    \n    float fBlurTaps = float(BLUR_TAPS);\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = vUV;\n                \n        float fRand = f;\n        \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = fRand * fGolden * fBlurTaps;\n        float fRadius = fCoC * sqrt( fRand * fBlurTaps ) \/ sqrt( fBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n            float fWeight = max( 0.001, abs(vTapSample.a) );\n\n            vResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0 \/ fBlurTaps;\n        fIndex += 1.0;\n    }\n    vResult \/= fTot;\n        \n\tfragColor = vec4(vResult, 1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tslGz7","date":"1545636262","viewed":7373,"name":"Stateless Fight","username":"iq","description":"No simulation or history used, all instant and pure procedural. It's really a remix of [url=https:\/\/www.shadertoy.com\/view\/XdjXWK]Repelling[\/url], but doing the collisions in their own pass and adding motion blur.","likes":115,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2018 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 3\n#endif\n\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)\/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)\/(l*l*l), 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/filterableprocedurals\nfloat linesTextureGradBox( in float p, in float ddx, in float ddy, int id )\n{\n    float N = 12.0;\/\/float( 2 + 7*((id>>1)&3) );\n\n    float w = max(abs(ddx), abs(ddy)) + 0.01;\n    float a = p + 0.5*w;                        \n    float b = p - 0.5*w;           \n    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-\n                  floor(b)-min(fract(b)*N,1.0))\/(N*w);\n}\n\n\n\/\/-------------------------------------------------------------------------------------------\n\/\/ scene\n\/\/-------------------------------------------------------------------------------------------\nvec4 getSphere( int id, float t )\n{\n    #if AA>1\n    vec4 s1 = texelFetch( iChannel1, ivec2(id,0), 0 );        \n    vec4 s2 = texelFetch( iChannel1, ivec2(id,1), 0 );\n    return mix( s1, s2, t );\n    #else\n    return texelFetch( iChannel1, ivec2(id,0), 0 );\n    #endif\n}\n\n\nfloat occlusion( in vec3 pos, in vec3 nor, in float mb )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n    {\n        vec4 sph = getSphere( i, mb );\n\t    res *= 1.0 - sphOcclusion( pos, nor, sph ); \n    }\n    return res;\t\t\t\t\t  \n}\n\nvec3 trace( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in vec3 col, float mb )\n{\n    float tmin = 1e20;\n    \n    vec4 obj = vec4(0.0);\n\tfloat t  = tmin;\n\tint   id = -1;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tvec4 sph = getSphere(i, mb);\n\t    float h = sphIntersect( ro, rd, sph ); \n\t\tif( h>0.0 && h<t ) \n\t\t{\n\t\t\tt  = h;\n\t\t\tid = i;\n            obj = sph;\n\t\t}\n\t}\n\n    \/\/ shade\n    if( id!=-1 )\n    {\n\t\tvec3 pos  = ro + t*rd;\n        vec3 nor = sphNormal( pos, obj );\n        \/\/ manual ray differentials\n        vec3 dpdx = t*(rdx*dot(rd,nor)\/dot(rdx,nor) - rd);\n        vec3 dpdy = t*(rdy*dot(rd,nor)\/dot(rdy,nor) - rd);\n        \/\/vec3 posx = ro + rdx*t*dot(rd,nor)\/dot(rdx,nor);\n        \/\/vec3 posy = ro + rdy*t*dot(rd,nor)\/dot(rdy,nor);\n        \n        float occ = occlusion( pos, nor, mb );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        \/\/ color\n        col = 0.5 + 0.5*cos(float(id)*0.01 + vec3(5.3,4.3,3.3)  + (((id&7)<3)?vec3(0.5,1.0,1.5):vec3(0.0)) );\n        col += fre*0.3 - 0.08;\n        col = clamp(col,0.0,1.0);\n\n        \/\/ texture coords, with manual derivatives\n        vec3 dir = normalize(pos);\n        float u    = dot(pos-obj.xyz,dir)*8.0\/obj.w;\n        float dudx = dot(       dpdx,dir)*8.0\/obj.w;\n        float dudy = dot(       dpdy,dir)*8.0\/obj.w;\n        \/\/float ux = dot(posx-obj.xyz,normalize(posx))*8.0\/obj.w;\n        \/\/float uy = dot(posy-obj.xyz,normalize(posy))*8.0\/obj.w;\n        \/\/float dudx = u - ux;\n        \/\/float dudy = u - uy;\n\n        \/\/ texture\n        col *= 0.4 + 0.6*linesTextureGradBox( u, abs(dudx), abs(dudy), id );\n\n        \/\/ occlusion\n        col *= occ;\n\n        \n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n        \/\/ sub-pixel        \n        vec2 of = vec2( float(i), float(j))\/float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)\/iResolution.y;\n        \n        uint hh = uint(i+AA*int(fragCoord.x))*17U +\n                  uint(j+AA*int(fragCoord.y))*127U +\n                  uint(iFrame)*31U;\n        float mb = hash1(hh);\n    #else\n    {\n        \/\/ pixel        \n        vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n        float mb = 0.0;\n    #endif        \n\n        \/\/ camera\n        vec3 ro = vec3(0.0,0.0,4.0);\n        vec3 rd = normalize( vec3(p.xy,-2.5) );\n\n\n        \/\/ ray differentials\n        vec2 px = p + vec2(2.0,0.0)\/iResolution.y;\n        vec2 py = p + vec2(0.0,2.0)\/iResolution.y;\n        vec3 rdx = normalize( vec3(px.xy,-2.5) );\n        vec3 rdy = normalize( vec3(py.xy,-2.5) );\n\n        \/\/ render\n        vec3 col = vec3(0.15,0.22,0.25);\n        col = trace( ro, rd, rdx, rdy, col, mb );\n\n        \/\/ gama\n        col = pow( col, vec3(0.4545) );\n        \n        tot += col;\n    }\n    #if AA>1\n\ttot \/= float(AA*AA);\n    #endif\n    \n\n    \/\/ color correct\n    tot = 1.1*pow( tot, vec3(1.0,1.3,1.4) );   \n        \n    \/\/ vignetting\n    vec2 q = fragCoord \/ iResolution.xy;\n    tot *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    \/\/ dithering\n    \/\/tot += (1.0\/255.0)*hash3(uint(fragCoord.x) + 13U*uint(fragCoord.y));\n\n    fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUMPASES 3\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord-0.5);\n    \n    if( p.y>1 || p.x>NUMSPHERES ) return;\n\n    \/\/ compute current and previous frame    \n    float time = (iTime - 0.5*float(p.y)\/24.0);\n\n    vec4 sphere[NUMSPHERES];\n\n    \/\/ animate\n    for( int i=0; i<NUMSPHERES; i++ )\n    {\n        float rad = pow(float(i)\/float(NUMSPHERES-1),5.0);\n        vec3  pos = 1.0*cos( 6.2831*hash3(uint(i)*147U) + (1.0-0.7*rad)*time*0.7 );\n        rad = 0.25 + 0.4*rad;\n        sphere[i] = vec4( pos, rad );\n    }\n\n    \/\/ repell\n    for( int k=ZERO; k<NUMPASES; k++ )\n    for( int i=ZERO; i<NUMSPHERES; i++ )\n    for( int j=ZERO; j<NUMSPHERES; j++ )\n    {\n        if( i!=j )\n        {\n            vec3  di = sphere[i].xyz - sphere[j].xyz;\n            float rr = sphere[i].w   + sphere[j].w;\n            float di2 = dot(di,di);\n            if( di2 < rr*rr )\n            {\n                float l = sqrt(di2);\n                di = 0.5*di*(1.0-rr\/l);\n                sphere[i].xyz -= di;\n                sphere[j].xyz += di;\n            }\n        }\n    }\n    fragColor = sphere[p.x];\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUMSPHERES 40\n\n\n#define ZERO min(0,iFrame)\n\n\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)\/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    uvec3 k = n + uvec3(0,517U,8191U);\n\tk = (k << 13U) ^ n;\n    k = k * (k * k * 15731U + 789221U) + 1376312589U;\n    return 1.0 - vec3(k&0x7fffffffU)\/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"MdSGRc","date":"1391556832","viewed":7371,"name":"Voronoi - metrics","username":"iq","description":"Changing the distance metric in voronoi patterns to get different shapes","likes":132,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Copyright Inigo Quilez, 2014 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\n\n\nvec4 voronoi( in vec2 x, float mode )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfloat m2 = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n\n\t\t\/\/ animate\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n\n\t\tvec2 r = g - f + o;\n\n        \/\/ euclidean\t\t\n\t\tvec2 d0 = vec2( sqrt(dot(r,r)), 1.0 );\n        \/\/ manhattam\t\t\n\t\tvec2 d1 = vec2( 0.71*(abs(r.x) + abs(r.y)), 1.0 );\n        \/\/ triangular\t\t\n\t\tvec2 d2 = vec2( max(abs(r.x)*0.866025+r.y*0.5,-r.y), \n\t\t\t\t        step(0.0,0.5*abs(r.x)+0.866025*r.y)*(1.0+step(0.0,r.x)) );\n\n\t\tvec2 d = d0; \n\t\tif( mode<3.0 ) d=mix( d2, d0, fract(mode) );\n\t\tif( mode<2.0 ) d=mix( d1, d2, fract(mode) );\n\t\tif( mode<1.0 ) d=mix( d0, d1, fract(mode) );\n\t\t\n        if( d.x<m.x )\n        {\n\t\t\tm2 = m.x;\n            m.x = d.x;\n            m.y = hash1( dot(n+g,vec2(7.0,113.0) ) );\n\t\t\tm.z = d.y;\n        }\n\t\telse if( d.x<m2 )\n\t\t{\n\t\t\tm2 = d.x;\n\t\t}\n\n    }\n    return vec4( m, m2-m.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mode = mod(iTime\/5.0,3.0);\n\tmode = floor(mode) + smoothstep( 0.8, 1.0, fract(mode) );\n\t\n    vec2 p = fragCoord.xy\/iResolution.xx;\n    vec4 c = voronoi( 8.0*p, mode );\n\n    vec3 col = 0.5 + 0.5*sin( c.y*2.5 + vec3(1.0,1.0,1.9) );\n    col *= sqrt( clamp( 1.0 - c.x, 0.0, 1.0 ) );\n\tcol *= clamp( 0.5 + (1.0-c.z\/2.0)*0.5, 0.0, 1.0 );\n\tcol *= 0.4 + 0.6*sqrt(clamp( 4.0*c.w, 0.0, 1.0 ));\n\t\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4lVGRy","date":"1475237130","viewed":7362,"name":"Orbital Flights","username":"blackjero","description":"Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n\nIt is meant to be slow pace \/ viewed at normal speed, but right arrow lets you fast forward.\n\n","likes":125,"published":3,"flags":16,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Orbital Flight by Jerome Liard, August 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4lVGRy\n\n\/\/ Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n\/\/ It is meant to be slow pace, but right arrow lets you fast forward.\n\n\/\/ Some camera paths are kepler orbits, others are just lookats.\n\/\/ Atmosphere sections of the shader could be way faster using buffers, but I just brute forced instead.\n\/\/ Disclaimer: important physical constants use garbage values, also there is no gamma correction.\n\n\/\/ The shader tries to make the most of shadertoy's mushroom texture using layering,\n\/\/ tiling, bombing of vortex distortions and silly exaggerations to make clouds shine more in the penumbra zone.\n\n\/\/#define FORCE_CAMERA 2.0 \/\/ force camera, int values in [0,CAMERA_NUM[\n#define CAMERA_TIME_RESET \/\/ make camera predictable by resetting\n#define CAMERA_PERIOD 30.0 \/\/ time we stay on each camera, in seconds\n#define GLOBALTIME (iTime+0.0) \/\/ offset sets initial view\n\/\/#define GLOBALTIME (CAMERA_PERIOD*0.0+25.0)\n\n#define CAMERA_NUM 8.0\n\n\/\/ set camera order\n#define CAMERA_SPECULAR_CLOSE   0.0\n#define CAMERA_CLOUDS           1.0\n#define CAMERA_TAKE_OFF_BLUE    2.0\n#define CAMERA_ORBITING_FAR     3.0\n#define CAMERA_SPECULAR_FAR     4.0\n#define CAMERA_TAKE_OFF_SUNRISE 5.0\n#define CAMERA_ORBITING_CLOSE   6.0\n#define CAMERA_MOON_WIP         7.0 \/\/ moon has no surface shader yet...\n\n#define CLOUD_FLOW\n#define EARTH_ROTATION\n\/\/#define HD_BLACK_BANDS\n\/\/#define SUPER_SAMPLE_HORIZON\n\/\/#define NO_EXPOSE\n\n#define PI\t\t\t3.141592654\n#define FLT_MAX\t\t1000000.0\n\n#define RED\t\t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE\t\tvec3(0,0,1)\n#define WHITE\t\tvec3(1,1,1)\n#define BLACK\t\tvec3(0,0,0)\n#define MAGENTA\t\tvec3(1,0,1)\n#define YELLOW\t\tvec3(1,1,0)\n#define CYAN\t\tvec3(0,1,1)\n#define GREY50\t\tvec3(0.5,0.5,0.5)\n\n#define R01         vec2( 0.999847695, 0.017452406 )\n\n#define const\n\n\/\/ hash functions from David Hoskins's https:\/\/www.shadertoy.com\/view\/4djSRW\n\nfloat hash11( float p )\n{\n\tvec2 p2 = fract( vec2( p * 5.3983, p * 5.4427 ) );\n\tp2 += dot( p2.yx, p2.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( p2.x * p2.y * 95.4337 );\n}\n\nvec3 hash32( vec2 p )\n{\n\tp  = fract( p * vec2( 5.3983, 5.4427 ) );\n\tp += dot( p.yx, p.xy +  vec2( 21.5351, 14.3137 ) );\n\treturn fract( vec3( p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365 ) );\n}\n\nvec4 xyz1( vec3 v ) { return vec4( v, 1. ); }\nvec4 xyz0( vec3 v ) { return vec4( v, 0. ); }\nvec3 xy0( vec2 v ) { return vec3( v, 0. ); }\nvec4 xy01( vec2 v ) { return vec4( v, 0., 1. ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat smoothstep_unchecked_6( float x ) { return x * x * x * x * x * ( 6.0 - 5.0 * x ); }\nfloat smoothbump( float c, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - c ), r ) \/ r ); }\nfloat remap( float x, float a, float b ) { return clamp( ( x - a ) \/ ( b - a ), 0., 1. ); }\nfloat tri( float x, float spacing ) { return spacing - ( abs( ( spacing * fract( x \/ spacing ) - spacing * 0.5 ) ) + spacing * 0.5 ); }\nfloat tri( float x ) { return 1.0 - abs( fract( x * 0.5 ) - 0.5 ) * 2.0; }\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow3( float x ) { return x * x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow3( vec4 x ) { return x * x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat soft_max( float x, float y, float k ) { return log( exp( k * x ) + exp( k * y ) ) \/ k; }\nfloat soft_max( float x, float y, float z, float k ) { return log( exp( k * x ) + exp( k * y ) + exp( k * z ) ) \/ k; }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ));\n}\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n\/\/ theta is angle with the z axis, range [0,pi].\n\/\/ phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nmat4 zup_spherical_lookat2( float theta, float phi )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ));\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi )\n{\n\treturn zup_spherical_coords_to_vector( theta, phi ).yzx;\n}\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ));\n}\n\nmat4 z_rotation( float angle )\n{\n\tvec2 v = unit_vector2( angle );\n\treturn mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n\/\/ use with constants...\n#define POW0(x) 1.0\n#define POW1(x) (x)\n#define POW2(x) (POW1(x)*(x))\n#define POW3(x) (POW2(x)*(x))\n#define POW4(x) (POW3(x)*(x))\n#define POW5(x) (POW4(x)*(x))\n#define POW6(x) (POW5(x)*(x))\n\n\/\/ project this on line (O,d), d is assumed to be unit length\nvec3 project_on_line1( vec3 P, vec3 O, vec3 d ) { return O + d * dot( P - O, d ); }\n\n#define layered5_pass_scale(func,p,a)((func(p,POW0(2.0),a)*POW1(0.5)+func(p,POW1(2.0),a)*POW2(0.5)+func(p,POW2(2.0),a)*POW3(0.5)+func(p,POW3(2.0),a)*POW4(0.5)+func(p,POW4(2.0),a)*POW5(0.5))*(1.0\/(1.0-POW5(0.5))))\n\nstruct NoiseTiledParams\n{\n\tvec3 eye, n, p;\n\tfloat bias;\n};\n\nvec2 grid3( vec2 x, vec2 r ) { return smoothstep( r, vec2( 1.0 ), abs( ( fract( x ) - vec2( 0.5 ) ) * 2.0 ) ); }\n\nfloat tile_tex( in vec2 uv, float s, NoiseTiledParams ntp )\n{\n\tuv *= s;\n\n\tfloat bias = 0.0;\n\n\tfloat edge = 1.0 - dot( normalize( ntp.eye - ntp.p ), ntp.n );\n\tbias = -1.2 * edge; \/\/ bias the mipmap blur horror on edges\n\n\tbias += ntp.bias;\n\n\t\/\/ make the texture tilable\n\tfloat a0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.0 ), bias ).x; \/\/ main image\n\tfloat b0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.5 ), bias ).x; \/\/ fill seams\n\t\/\/ it's ok to fract on the seam filling lookups\n\t\/\/ without fract we are smooth tiled everywhere but at mipmap horror line\n\tfloat a1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.0 ), bias ).x; \/\/ fill seams\n\tfloat b1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.5 ), bias ).x; \/\/ fill seams\n\n\tfloat r = 1.0 - 0.2; \/\/ note: don't divide by s... 0,1 here\n\tuv = grid3( uv, vec2( r ) );\n\treturn mix( mix( a0, b0, uv.y ), mix( a1, b1, uv.y ), uv.x );\n}\n\nfloat fbm5_tiled_clouds( vec2 p, NoiseTiledParams ntp ) { return layered5_pass_scale( tile_tex, p, ntp ); }\n\n\/\/ just return the delta\nvec3 vortex( vec2 q, float max_twist, float aa_scale )\n{\n\tvec2 c = vec2( 0.5, 0.5 );\n\tfloat r0 = 0.5;\n\tvec2 v = ( q - c );\n\tfloat r = length( v );\n\tfloat x = min( r \/ r0, 1.0 );\n\tfloat aa = pow2( 1.0 - x );\n\treturn vec3( c + rotate_with_angle( q - c, aa * max_twist ) - q, aa * aa_scale );\n}\n\nvec3 vortex_bombing( vec2 p, float scale, float max_twist, float aa_scale, float probability )\n{\n\tp *= scale;\n\tvec2 pi = floor( p );\n\tvec2 pf = fract( p );\n\tvec3 x = vec3( 0.0, 0.0, 0.0 );\n\tfor ( int i = -1; i <= 1; ++i )\n\t{\n\t\tfor ( int j = -1; j <= 1; ++j )\n\t\t{\n\t\t\tvec2 o = vec2( float( i ), float( j ) );\n\t\t\tvec2 pj = pi + o;\n\t\t\tpj.x = mod( pj.x, scale ); \/\/ we are mapping a sphere so want same distortion at the u=0, u=1 limit\n\t\t\tvec3 rj = hash32( pj );\n\t\t\tif ( rj.z <= probability ) x += vortex( pf - o - rj.xy, max_twist * rj.z, aa_scale * rj.z ); \/\/p - ( pj + rj.xy ) == ( pi + pf ) - ( pj + rj.xy ) == pf - o - rj.xy\n\t\t}\n\t}\n\treturn x;\n}\n\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\n\nvec2 sphere_trace( Ray ray, float radius, vec3 C )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( C - O, d ); \/\/ P = project C on line (O,d)\n\tvec3 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); \/\/ ray missed the sphere\n\/\/\tbool start_inside = lensqr( O - C ) <= radius_sqr; \/\/ start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); \/\/ distance from P to In (near hit) and If (far hit)\n\/\/\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t\/\/ order In->O->If \/\/ record only far hit If\n\/\/\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); \/\/ order In->If->O \/\/ O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); \/\/ record 2 hits In, If\n}\n\n#define earth_center vec3(0.0,0.0,0.0)\n\/\/const float atm_scale=1e+3f; \/\/ 1=1m\n#define atm_scale 1.0 \/\/ 1=1km\n#define sun_direction vec3(0.0,1.0,0.0) \/\/ normalized please\nconst float earth_angular_velocity = ( 2.0 * PI \/ ( 24.0 * 60.0 * 60.0 ) );\nconst float earth_radius = 6378.15 * atm_scale;\nconst float sun_radius = 6.955e+5 * atm_scale; \/\/ for render only\n#define sun_dist (1.49e+8*atm_scale) \/\/ for render only\nconst float sun_cos = 0.999989; \/\/ for render only\nconst float sun_solid_angle = 0.0093355;  \/\/ sun view angle\nconst vec3 sun_center = earth_center + sun_direction * sun_dist;\n\/\/const vec3 moon_direction=sun_direction; \/\/ full sun eclipse\n#define moon_direction \/*normalize(*\/vec3(1.0,0.0,0.0)\/*)*\/\t\/\/ moon close to sun\n\/\/const vec3 moon_direction=normalize(vec3(0.01f,1.0,0.0)); \/\/ moon close to sun\n\/\/const vec3 moon_direction=normalize(vec3(0.015f,1.0,-0.02f));\t\/\/ moon close to sun, a bit far appart\n\/\/const vec3 moon_direction=normalize(vec3(0.0,-1.0,0.0)); \/\/ moon fully occluded\n\/\/const vec3 moon_direction=normalize(vec3(0.016f,-1.0,0.0)); \/\/ half moon\nconst float moon_radius = 1738.14 * atm_scale;\n#define moon_dist (384400.0*atm_scale)\nconst float moon_cos = 0.99999;\nconst vec3 moon_center = earth_center + moon_direction * moon_dist;\nconst float H0_r = 0.7994 * atm_scale; \/\/ normally this is 8km\nconst float H0_m = 1.2 * atm_scale;\nconst float atm_max = 20.0 * atm_scale; \/\/ as small as possible, large enough to accomodate H0_ values\nconst vec3 beta_r = 2.504 * ( 1e+3f \/ atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); \/\/ fudge factor & account for km\nconst vec3 beta_m = 2.504 * ( 1e+3f \/ atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); \/\/ beta_m is normally a scalar (2.10e-005\/m in \"Precomputed Atmospheric Scattering\" Fig7), but I tweaked this shader before fixing the constants\nconst vec3 Is = vec3( 1.0, 1.0, 1.0 ) * 35.0;\nconst vec3 earth_diffuse_reflection = vec3( 0.2 );\nconst float cloud_start = 1.0 * atm_scale;\nconst float cloud_end = 10.0 * atm_scale;\nconst float ie_cost_min = -0.3420; \/\/110deg\n\nfloat sunh( float viewdist )\n{\n\treturn viewdist * ( sun_radius \/ sun_dist );\n\/\/\treturn viewdist * tan( sun_solid_angle * 0.5 );\n}\n\n\/\/ params for Ie term manual fit\nstruct IeApproxS\n{\n\tfloat a;\n\tfloat k;\n\tfloat sx;\n\tfloat sy;\n\tfloat last_bit;\n};\n\nIeApproxS ie_params_r;\nIeApproxS ie_params_g;\nIeApproxS ie_params_b;\n\nvec2 calc_rho( float h ) { return exp( -vec2( h ) \/ vec2( H0_r, H0_m ) ); }\n\nstruct vec6 { vec3 r; vec3 m; };\n\nvec6 mkvec6( vec2 s ) { vec6 val; val.r = vec3( s.x ); val.m = vec3( s.y ); return val; }\nvec6 mkvec6( float s ) { return mkvec6( vec2( s, s ) ); }\n\nvoid add_vec6( inout vec6 od, vec6 value, float ds )\n{\n\tod.r += value.r * beta_r * ds;\n\tod.m += value.m * beta_m * ds;\n}\n\nvec6 opticalDepth( Ray ray, float t, float t2 )\n{\n\tvec6 ret = mkvec6( 0.0 );\n\t#define num_segments 20\n\tfloat dt = ( t2 - t ) \/ float( num_segments );\n\tfor ( int i = 0; i < num_segments + 1; ++i )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\tadd_vec6( ret, mkvec6( rho ), dt * ( ( i == 0 || i == num_segments ) ? 0.5 : 1.0 ) );\n\t\tt += dt;\n\t}\n\treturn ret;\n}\n\n\/\/ http:\/\/nishitalab.org\/user\/nis\/cdrom\/sig93_nis.pdf\nfloat CornetteSingleScatteringPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return 3.0 * ( 1.0 - g2 ) * ( 1.0 + pow2( cos_theta ) ) \/ ( 2.0 * ( 2.0 + g2 ) * pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ) ); }\n\n\/\/ == CornetteSingleScatteringPhaseFunction( cos_theta, 0.0 )\nfloat RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }\n\n\/\/ https:\/\/www.astro.umd.edu\/~jph\/HG_note.pdf HG, g in [-1,1]\nfloat HenyeyGreensteinPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return ( 1.0 \/ ( 4.0 * PI ) ) * ( 1.0 - g2 ) \/ pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ); }\n\nfloat calc_Fr_r( float cos_theta ) { return RayleighScattering( cos_theta  ); }\nfloat calc_Fr_m( float cos_theta, float g ) { return CornetteSingleScatteringPhaseFunction( cos_theta, g ); }\n\nbool in_earth_shadow( vec3 p )\n{\n\treturn ( dot( p, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius );\n}\n\nbool in_moon_shadow( vec3 p )\n{\n\treturn ( dot( p - moon_center, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, moon_center, sun_direction ) ) < moon_radius * moon_radius );\n}\n\n\/\/ this is a manual fit of the offline precalculated Ie 1d table (with various wrong physical constant) for each r,g,b, plus slight tweaks\nfloat ie_approx_S( float cos_alpha, IeApproxS params )\n{\n\tfloat y =\n\t\tsoft_max( cos_alpha * params.sx, params.a, params.k ) * params.sy\n\t\t- soft_max( 0.0, params.a, params.k ) * params.sy;\n\n\tfloat c = 0.98;\n\tif ( cos_alpha > c ) y *= ( 1.0 + params.last_bit * ( cos_alpha - c ) \/ ( 1.0 - c ) );\n\treturn max( 0.0, y );\n}\n\nvoid Ie_ie_params_init()\n{\n\tie_params_r.a = 1.07143104;\n\tie_params_r.k = 0.578571617;\n\tie_params_r.sx = 12.857152938;\n\tie_params_r.sy = 2.785715818;\n\tie_params_r.last_bit = 0.042857192;\n\n\tie_params_g.a = 5.250002384;\n\tie_params_g.k = 0.385714441;\n\tie_params_g.sx = 24.000009536;\n\tie_params_g.sy = 1.357144474;\n\tie_params_g.last_bit = 0.126428619;\n\n\tie_params_b.a = 7.285716533;\n\tie_params_b.k = 0.435714453;\n\tie_params_b.sx = 13.285723686;\n\tie_params_b.sy = 2.928573131;\n\tie_params_b.last_bit = 0.300000011;\n}\n\nvec3 calc_Ie_shaderfunc( float cos_alpha )\n{\n\tIe_ie_params_init();\n\tfloat bleed = 0.02; \/\/0.0 means no bleed, sunset cameras need enough bleeding to look interesting\n\tcos_alpha = 1.0 + ( cos_alpha - 1.0 ) * ( 1.0 - bleed ); \/\/ exaggerate Ie bleed a little bit\n\tcos_alpha = clamp( cos_alpha, ie_cost_min, 1.0 - 0.019 ); \/\/ cos alpha=1 has a weird blob, clamp a bit...\n\treturn vec3( ie_approx_S( cos_alpha, ie_params_r ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_g ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_b ) );\n}\n\nstruct LameTweaks\n{\n\tfloat earth_rot_time;\n\tfloat cloud_flow_time;\n\t\/\/ no PBR no life\n\tfloat specular_hack;\n\tvec3 cloud_hack;\n};\n\nfloat cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )\n{\n\tvec2 p0 = p;\n\n\tfloat pole = 0.1;\n\tp.y = ( p.y - pole ) \/ ( 1.0 - 2.0 * pole );\n\n\t\/\/ p0 is in x 0,1\n\t\/\/ q0 is in x 0,2\n\n\tvec3 q = vec3( p * vec2( 2, 1 ), 0.0 );\n\n\tvec3 q0 = q;\n\n\/\/\tq += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); \/\/ 1\n\/\/\tq += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); \/\/ 2\n\/\/\tq += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); \/\/ 3\n\tq += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); \/\/ 4\n\/\/\tq += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); \/\/ 5\n\tq += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); \/\/ 6\n\/\/\tq += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); \/\/ 7\n\n\tvec2 qoff = vec2( 0.0, 0 );\n#ifdef CLOUD_FLOW\n\tqoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; \/\/cloud flow (doesn't fix black line)\n#endif\n\n\tNoiseTiledParams ntp;\n\tntp.eye = camera[3].xyz;\n\tntp.n = n;\n\tntp.p = n * earth_radius;\n\tntp.bias = bias;\n\n\tfloat a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );\n\n\ta *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); \/\/ would like to do better than that...\n\n\tfloat a0 = a;\n\n\t{\n\t\t\/\/increase density on areas that have vortices\n\t\ta += length( q - q0 ) * 0.5;\n\t\ta += q.z * q.z * 5.0;\n\t}\n\n\t\/\/ add a little bit more oompf detail, helps overall + on cloud close ups\n\ta += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;\n\n\ta = contrast( a + 0.05, 2.75 ); \/\/ higher contrast = deeper blue if we keep negative cloud\n\ta = soft_max( a, 0.0, 15.0 );\n\treturn a;\n}\n\nfloat cloudMap( vec3 n, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tvec3 n0 = n;\n#ifdef EARTH_ROTATION\n\tn.xy = rotate_with_angle( n.xy, lame_tweaks.earth_rot_time * earth_angular_velocity );\n#endif\n\tfloat theta = acos( n.z );\n\tfloat phi = calc_angle( n.xy ) + PI; \/\/ assume range 0,1\n\n\treturn cloudSphereMap( vec2( phi * 0.5, theta ) * ( 1.0 \/ PI ), camera, n0, bias, lame_tweaks );\n}\n\nstruct CloudOut\n{\n\tvec3 sphere_point, sphere_normal;\n\tfloat cloud;\n\tbool hit;\n};\n\n\/\/ just one sphere lookup\nCloudOut cloudTraceFlat( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\tfloat cloud_height = mix( cloud_start, cloud_end, 0.5 ); \/\/ cloud alt should be a number in 0-1\n\/\/\tfloat cloud_height = mix( cloud_start, cloud_end, 10.0 ); \/\/ over the top shadow... fun\n\tvec2 tb = sphere_trace( ray, earth_radius, earth_center );\n\tvec2 tc = sphere_trace( ray, earth_radius + cloud_height, earth_center );\n\tif ( tc.x == FLT_MAX ) return ret; \/\/ no intersection with cloud sphere\n\tif ( tc.x < 0.0 && tb.x != FLT_MAX && tb.x >= 0.0 ) return ret;\n\tvec3 p = ray.o + ( tc.x < 0.0 ? tc.y : tc.x ) * ray.d;\n\tret.sphere_point = p;\n\tret.sphere_normal = normalize( p - earth_center );\n\tret.cloud = cloudMap( ret.sphere_normal, camera, bias, lame_tweaks );\n\tret.hit = true;\n\treturn ret;\n}\n\n\/\/ get a bit of volume\nCloudOut cloudTrace( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\n\tfloat hcs = mix( cloud_start, cloud_end, 0.55 );\n\tfloat hce = mix( cloud_start, cloud_end, 0.8 );\n\tvec2 ts = sphere_trace( ray, earth_radius + hcs, earth_center ); \/\/ start\n\tvec2 te = sphere_trace( ray, earth_radius + hce, earth_center ); \/\/ end\n\tif ( te.x == FLT_MAX ) return ret; \/\/ ray line doesn't intersect a (and therefore, b since b is inside a)\n\tif ( te.y <= 0.0 ) return ret; \/\/ ray line intersects a(atm) but behind us\n\tvec2 range;\n\tif ( ts.x == FLT_MAX )\n\t{\n\t\t\/\/ inside cloud altitude range, looking at upper cloud shell\n\t\t\/\/ ray line intersects a\n\t\t\/\/ ray line doesn't intersect b\n\t\trange.x = max( 0.0, te.x );\n\t\trange.y = te.y;\n\t}\n\telse\n\t{\n\t\t\/\/ ray line intersects a\n\t\t\/\/ ray line intersects b\n\t\tif ( te.x > 0.0 )\n\t\t{\n\t\t\t\/\/ hitting clouds from above\n\t\t\t\/\/ ray hitting a from outside\n\t\t\trange.x = te.x;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse if ( ts.x > 0.0 )\n\t\t{\n\t\t\t\/\/ below lower cloud layer, looking at lower cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\/\/ between cloud layers, looking at upper cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = te.y;\n\t\t}\n\t}\n\n\tfloat t = range.x;\n\tfloat dt = ( range.y - range.x ) * ( 1.0 \/ 8.0 );\n\tfloat min_dist = FLT_MAX;\n\tfloat hcdv = 1.0 \/ ( hce - hcs );\n\n\tfor ( int i = 0; i < 8; ++i )\n\t{\n\t\tvec3 p = ray.o + t * ray.d;\n\t\tfloat hr = length( p - earth_center );\n\t\tfloat hp = hr - earth_radius;\n\t\tvec3 n = ( p - earth_center ) \/ hr;\n\n\t\tfloat c = cloudMap( n, camera, bias, lame_tweaks );\n\t\tfloat hc = hcs + ( hce - hcs ) * saturate( c );\n\n\t\tfloat dh = hp - hc;\n\n\t\tif ( abs( dh ) < 0.4 && t <= range.y )\n\t\t{\n\t\t\tret.cloud = c;\n\t\t\tret.sphere_normal = n;\n\t\t\tret.hit = true;\n\n\t\t\tt += dt * 0.5; \/\/ note: don't break, keep homing\n\t\t}\n\t\telse t += dt;\n\t}\n\n\treturn ret;\n}\n\n\/\/ fade shadow term based on distance\nfloat shadow_falloff( vec3 pa, vec3 pb )\n{\n\tvec3 d = ( pa - pb );\n\treturn 1.0 \/ ( 1.0 + lensqr( d ) * 0.00005 );\n}\n\n\/\/ losely based on http:\/\/nishitalab.org\/user\/nis\/cdrom\/sig93_nis.pdf\n\nstruct AtmOut\n{\n\tvec3 vod_attn; \/\/view ray atm scattering\n\tvec3 earth_p;\n\tvec3 earth_n;\n\tbool earth_surface;\n\tvec3 Iv;\n};\n\nvec3 calc_Iv( Ray view_ray, inout AtmOut atm_out, mat4 camera, LameTweaks lame_tweaks )\n{\n\tvec2 te = sphere_trace( view_ray, earth_radius, earth_center );\n\tvec2 ta = sphere_trace( view_ray, earth_radius + atm_max, earth_center );\n\n\tatm_out.earth_surface = ( te.x > 0.0 && te.x != FLT_MAX );\n\tatm_out.vod_attn = vec3( 1.0 );\n\tatm_out.Iv = vec3( 0.0 );\n\n\/\/\tvec3 spacecolor = MAGENTA; \/\/ debug\n\tvec3 spacecolor = BLACK;\n\n\tif ( ta.x == FLT_MAX ) return spacecolor; \/\/ view_ray line doesn't intersect a (and therefore, e since e is inside a)\n\tif ( ta.y <= 0.0 ) return spacecolor; \/\/ return mix(SPACECOLOR,WHITE,0.7);\t\/\/ view_ray line intersects a(atm) but behind us\n\tif ( te.x <= 0.0 && te.y >= 0.0 ) return GREEN; \/\/ inside (e)earth\n\n\tvec2 range; \/\/ range segment we integrate things on along view_ray\n\t\n\tif ( te.x == FLT_MAX ) range = vec2( max( 0.0, ta.x ), ta.y ); \/\/ view_ray line intersects a, doesn't intersect e\n\t\/\/ view_ray line intersects a and e\n\telse if ( ta.x > 0.0 ) range = vec2( ta.x, te.x ); \/\/ ray hitting a from outside atm\n\telse if ( te.x > 0.0 ) range = vec2( 0.0, te.x ); \/\/ ray hitting e from inside atm\n\telse range = vec2( 0.0, ta.y ); \/\/ ray hitting a from inside atm\n\t\n\tRay sun_ray;\n\tsun_ray.d = sun_direction;\n\n\tfloat tp = range.x;\n\n\t#define num_view_ray_segments 50 \/\/ we have to bump this number quite a bit to get decent integration\n\tfloat dl = ( range.y - range.x ) \/ float( num_view_ray_segments );\n\tif ( dl < 0.0 )\treturn YELLOW;\n\t\n\tvec3 p;\n\tvec6 tppc = mkvec6( 0.0 ); \/\/ the last of those is a earth hit -> sun ray when earth_surface is true\n\tvec6 tppa = mkvec6( 0.0 ); \/\/ the last of those is a earth hit -> eye ray when earth_surface is true\n\tvec6 Iv_sum = mkvec6( 0.0 );\n\tfor ( int i = 0; i < num_view_ray_segments + 1; ++i )\n\t{\n\t\tp = view_ray.o + view_ray.d * tp;\n\t\tp = earth_center + normalize( p ) * max( earth_radius * 1.00001, length( p ) ); \/\/ make sure we don't start inside the earth when P is a hit point\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\ttppc = mkvec6( 0.0 );\n\t\tif ( !in_earth_shadow( p ) )\n\/\/\t\tif ( !in_moon_sun_shadow( p ) )\n\t\t{\n\t\t\tsun_ray.o = p;\n\t\t\tvec2 ta_sun = sphere_trace( sun_ray, earth_radius + atm_max, earth_center );\n\t\t\ttppc = opticalDepth( sun_ray, 0.0\/*p*\/, ta_sun.y\/*pc*\/ ); \/\/ note: ta_sun.y > 0.0\n\t\t\tvec6 tmp;\n\t\t\t#if 1\n\t\t\t\/\/ note: this is not the correct way to combine the r,m transmittance at all, but too late to fix\n\t\t\ttmp.r = rho.x * exp( -tppc.r - tppa.r );\n\t\t\ttmp.m = rho.y * exp( -tppc.m - tppa.m );\n\t\t\t#else\n\t\t\t\/\/ normally attenuation should affect both\n\t\t\tvec3 tr = exp( -tppc.r - tppa.r - tppc.m - tppa.m );\n\t\t\ttmp.r = rho.x * tr;\n\t\t\ttmp.m = rho.y * tr;\n\t\t\t#endif\n\t\t\tadd_vec6( Iv_sum, tmp, dl * ( ( i == 0 || i == num_view_ray_segments ) ? 0.5 : 1.0 ) );\n\t\t}\n\t\tadd_vec6( tppa, mkvec6( rho ), dl );\n\t\ttp += dl;\n\t}\n\n\tfloat cos_theta = dot( sun_direction, view_ray.d );\n\tvec3 Iv = Is *\n\t\t( ( Iv_sum.r \/ ( 4.0 * PI ) ) * calc_Fr_r( cos_theta ) + \n\t\t  ( Iv_sum.m \/ ( 4.0 * PI ) ) * calc_Fr_m( cos_theta, 0.8 ) );\n\n\tatm_out.Iv = Iv;\n\n\tvec3 Ie = vec3( 0, 0, 0 );\n\tvec6 tPaPb = mkvec6( 0.0 );\n\n\tfloat cloud_shadow = 0.0;\n\tfloat specular = 0.0;\n\n\tif ( atm_out.earth_surface )\n\t{\n\t\t\/\/return RED; \/\/ check earth pixel\n\t\tp = view_ray.o + view_ray.d * te.x; \/\/ note: we shouldn't need to update p here\n\t\tvec3 n = normalize( p - earth_center );\n\t\tfloat cos_alpha = dot( sun_direction, n );\n\t\tIe = calc_Ie_shaderfunc( cos_alpha );\n\/\/\t\ttPaPb = opticalDepth( view_ray, range.x\/*Pa*\/, te.x\/*Pb*\/ );\n\t\ttPaPb = tppa; \/\/ tppa already has the value\n\n\t\tatm_out.earth_p = p;\n\t\tatm_out.earth_n = n;\n\n\t\tRay cloud_shadow_ray;\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcloud_shadow_ray.o = p + n * max( 1.00001, cloud_start * 0.5 ); \/\/anything smaller than cloud_start and greater than a separation epsilon\n\n\t\tvec3 tangent = cross( sun_direction, n );\n\t\tvec3 np = normalize( cross( tangent, sun_direction ) );\n\n\/\/\t\tvec2 acs = unit_vector2( radians( 5.0 ) );\n\t\tvec2 acs = R01;\n\t\tfloat w1 = 1.0;\n\t\tfloat w2 = 0.5;\n\n\t\tCloudOut cs;\n\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w1 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x + np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x - np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow *= ( 1.0 \/ ( w1 + w2 * 2.0 ) );\n\n\t\tvec3 l = sun_direction;\n\t\tvec3 e = -view_ray.d;\n\t\tvec3 h = normalize( e + l );\n\t\tfloat dp = dot( n, l );\n\n\t\tfloat specular_power = 75.0;\n\n\t\tspecular = pow( max( dot( n, h ), 0.0 ), specular_power )\n\t\t\t* ( ( specular_power + 8.0 ) \/ ( 8.0 * PI ) )\n\t\t\t* max( 0.0, dp );\n\t}\n\n\tCloudOut co = cloudTrace( view_ray, camera, 0.0, lame_tweaks );\n\tfloat cloud = co.cloud;\n\n\tatm_out.vod_attn = exp( -tppa.r ); \/\/ for sun attn\n\n\tfloat dp = dot( co.sphere_normal, sun_direction );\n\n\tfloat s = ( 1.0 - saturate( cloud_shadow * ( 1.0 - cloud ) ) );\n\n\/\/\treturn vec3( ( 1.0 - s ) * 3.0, cloud, 0.0 );\n\n\tfloat earth_diffuse = 0.008;  \/\/ controls blue depth\n\n\treturn ( 0.0\n\t\t\t + earth_diffuse * s\n\t\t\t + specular * ( 1.0 - saturate( cloud ) ) * lame_tweaks.specular_hack * s * s\n\t\t\t + cloud\n\t\t\t * \/\/ this add specks of gold to the clouds in the penumbra zone\n\t\t\t ( 1.0\n\t\t\t   + smoothstep( -0.02, 0.012, dp )\n\t\t\t   * exp( ( cloud - cloud_shadow ) * lame_tweaks.cloud_hack.x )\n\t\t\t   * lame_tweaks.cloud_hack.y ) * lame_tweaks.cloud_hack.z\n\n\t\t\t) * Ie * exp( -tPaPb.r - tPaPb.m )\n\n\t\t   + Iv * ( 2.4 - ( 1.0 - s ) * 0.7 );\n}\n\n\/\/ linearly remap nl, cut is the value of nl that maps to 0\nfloat warp_nl( float nl, float cut ) { return max( 0.0, ( nl - cut ) ) \/ ( 1.0 - cut ); }\n\nfloat noise1s( in float x )\n{\n\tx -= 0.5;\n\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\n\treturn mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n}\n\nfloat calcFallOff( float sd, float r, float p1, float p2 )\n{\n\tfloat sd_last = sun_cos - r; \/\/length of rays\n\tfloat g = 1.0 - saturate( max( sun_cos - sd, 0.0 ) \/ ( sun_cos - sd_last ) );\n\treturn powerful_scurve( g, p1, p2 );\n}\n\nvec3 earthShader( Ray view_ray, mat4 camera, LameTweaks lame_tweaks, float exposure )\n{\n\tAtmOut atm_out;\n\n\tvec3 ret = calc_Iv( view_ray, atm_out, camera, lame_tweaks );\n\n\tvec3 sun_color = atm_out.vod_attn * vec3( 1.0, 0.85, 0.71 );\n\tfloat sun_intensity = 0.0;\n\n\tfloat sd = dot( normalize( view_ray.d ), sun_direction ); \/\/ assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\n\tbool long_sun_flare = true;\n\tbool thin_flares = true;\n\tbool sun_glare = true;\n\tbool earth_clamped_sun_glare = true;\n\n\tif ( !atm_out.earth_surface )\n\t{\n\t\tvec2 tm = sphere_trace( view_ray, moon_radius, moon_center );\n\t\tif ( tm.x != FLT_MAX && tm.x > 0.0 )\n\t\t{\n\t\t\tvec3 moon_P = view_ray.o + view_ray.d * tm.x;\n\t\t\tfloat moon_sun_shadow = warp_nl( dot( normalize( moon_P - moon_center ), sun_direction ), -0.01 );\n\t\t\tfloat earth_sun_shadow = in_earth_shadow( moon_P ) ? 0.0 : 1.0; \/\/ fixme: don't want sharp... precalc or fit something\n\n\t\t\tret += vec3( 0.04 );\n\t\t\tret += min( pow( moon_sun_shadow, 0.57 ), earth_sun_shadow ) * atm_out.vod_attn * 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( earth_clamped_sun_glare )\n\t\t\t{\n\t\t\t\tfloat gs = calcFallOff( sd, 0.01, 1.4, 0.05 );\n\t\t\t\tsun_intensity += 16.0 * gs;\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat theta = acos( clamp( sd, -1., 1. ) );\n\tfloat phi = calc_angle( view_ray.d.zx );\n\tvec2 phi_vec = unit_vector2( phi );\n\n\tfloat sun_visibility = 0.0;\n\tvec3 ep_sv = view_ray.o + sun_direction * dot( earth_center - view_ray.o, sun_direction );\n\t{\n\t\tfloat sh = sunh( length( ep_sv - view_ray.o ) );\n\t\tfloat h = length( ep_sv - earth_center );\n\t\tsun_visibility = saturate( smoothstep( -sh, sh, h - earth_radius ) );\n\/\/\t\tfloat darkness = saturate( smoothstep( 0, earth_radius - sh, h ) );\n\/\/\t\tif ( sun_visibility != 0.0 ) ret += RED;\n\t}\n\n\tfloat xsum = 0.0;\n\n\tif ( long_sun_flare )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-3 * 12., 1.2, 0.07 );\n\n\t\tfloat spacing = 2.0 * PI \/ 6.0;\n\t\tfor ( int i = 0; i < 6; ++i )\n\t\t{\n\t\t\tvec2 v = unit_vector2( float( i ) * spacing + 0.4 );\n\t\t\tfloat vv = abs( dot( phi_vec * theta, v ) );\n\t\t\tvv \/= PI;\n\t\t\tvv *= 0.4;\n\t\t\txsum += exp( -vv * 1500.0 ) * gs * 0.8;\n\t\t}\n\t}\n\n\tif ( thin_flares )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-5 * 4.0, 1.4, 0.3 );\n\n\t\t\/\/ thin flares\n\t\tfor ( int i = 0; i < 5; ++i )\n\t\t{\n\t\t\tfloat fi = float( i );\n\t\t\tfloat x = noise1s( phi * 3.5 + fi * 3.0 + 0.5 * sin( GLOBALTIME + fi ) );\n\t\t\tx = pow4( x );\n\t\t\tx = max( 0.0, contrast( x, 1.1 ) );\n\t\t\tx = gs * mix( 0.0, 1.0, x );\n\t\t\txsum += x * 2.0 * gs;\n\t\t}\n\t}\n\n\tret += xsum * ( atm_out.earth_surface ? 0.0 : 1.0 ) * pow( sun_visibility, 0.15 );\n\n\tif ( sun_glare )\n\t{\n\t\t\/\/ diffuse fall off\n\t\tsun_intensity += exp( -theta \/ PI * ( atm_out.earth_surface ? 70.0 : 27.0 ) ) * pow( sun_visibility, 0.20 );\n\t}\n\n\tret += sun_intensity * sun_color;\n\n\/\/\tfloat scene_luminance = 0.0;\n\/\/\tscene_luminance = max( 0.0, dot( view_ray.d, sun_direction ) );\n\n#ifndef NO_EXPOSE\n\/\/\tret = 1.0 - exp( -mix( 0.85, 0.05, scene_luminance\/**sun_visibility*\/ ) * ret );\n\tret = 1.0 - exp( -exposure * ret );\n#endif\n\treturn ret;\n}\n\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Kepler%27s_equation\nfloat kepler_eq_solve( float M, float e\/*,float& err*\/ )\n{\n\tfloat En = M;\n\tif ( e > 0.8 ) En = PI;\n\tfor ( int i = 0; i < 3; ++i ) En = En - ( En - e * sin( En ) - M ) \/ ( 1.0 - e * cos( En ) );\n\/\/\terr = max( fabsf( ( En - e * sin( En ) - M ) ), err );\n\treturn En;\n}\n\n\/\/ n = mean motion n https:\/\/en.wikipedia.org\/wiki\/Mean_motion (consider this as the \"angular speed\")\n\/\/ n = 2pi\/period\n\/\/ p,e see https:\/\/en.wikipedia.org\/wiki\/Kepler%27s_laws_of_planetary_motion\n\/\/ p is the scale of the trajectory\n\/\/ e the eccentricity, 0 for circle\n\/\/ becomes ellipsoid (and smaller, so compensate by increasing p) as we get closer to 1\n\/\/ above 0.8 kepler_eq_solve needs more iterations\n\/\/ rmin=p\/(1+e) closest distance to focus...perihelion\n\/\/ rmax=p\/(1-e) farthest distance to focus..aphelion\nvec2 kepler_orbit( float t, float p, float e, float n\/*, float& err*\/ )\n{\n\tfloat M = n * t;\n\tfloat E = kepler_eq_solve( M, e\/*,err*\/ );\n\tfloat a = p \/ ( 1.0 - e * e );\n\tfloat b = p \/ sqrt( 1.0 - e * e );\n\tfloat x = a * ( cos( E ) - e );\n\tfloat y = b * sin( E );\n\treturn vec2( x, y );\n}\n\n\/\/ calculate p given rmin\nfloat kepler_orbit_calc_p( float rmin, float e )\n{\n\treturn rmin * ( 1.0 + e );\n}\n\nstruct KeplerOrbit\n{\n\tfloat rmin; \/\/ min radius\n\tfloat period;\n\tfloat e; \/\/ ellipse eccentricity\n};\n\nstruct KeplerOrbitRetval\n{\n\tvec3 orbit_position;\n\tvec3 orbit_plane_normal;\n};\n\nKeplerOrbitRetval get_earth_camera_path_kepler( float t, in KeplerOrbit ko )\n{\n\tKeplerOrbitRetval ret;\n\t\/\/ you can can play with highly elliptical orbits here, see\n\t\/\/ http:\/\/www.polaris.iastate.edu\/EveningStar\/Unit4\/unit4_sub3.htm\n\tfloat n = 2.0 * PI \/ ko.period;\n\tvec2 p = kepler_orbit( t, kepler_orbit_calc_p( ko.rmin, ko.e ), ko.e, n );\n\tp = perp( p ); \/\/ start on y, where the sun is, symmetry more convenient to tweak orbit period\n#if 1\n\t\/\/ define trajectory plane here (theta must be non zero if you want an inclination)\n\/\/\tmat4 rep = zup_spherical_lookat2( radians( 90.0 ), radians( 90.0 ) ); \/\/ circle around penumbra zone\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); \/\/ trajectory inclination\n\tret.orbit_plane_normal = rep[2].xyz;\n\tret.orbit_position = ( rep * xy01( p ) ).xyz;\n#else\n\tret.orbit_plane_normal = vec3( 0, 0, 1 );\n\tret.orbit_position = xy0( xx );\n#endif\n\treturn ret;\n}\n\nvec3 get_earth_camera_path_iss( float t, inout vec3 up )\n{\n\t\/\/ needs high fov values\n\tfloat h = 340.0; \/\/ISS\n\tfloat er = earth_radius \/ atm_scale;\n\tfloat dtheta = t * ( 27.6e+3 \/ 3600.0 ) \/ ( er + h ); \/\/27.6km\/h\n\tvec2 xx = unit_vector2( dtheta ) * ( er + h );\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); \/\/ trajectory inclination\n\tup = rep[2].xyz;\n\treturn ( rep * xy01( xx ) ).xyz;\n}\n\nstruct TangentView\n{\n\tvec3 target_vector; \/\/ sphere center -> target unit vector\n\tvec3 tangent_disk_center;\n\tfloat tangent_disk_radius;\n};\n\nTangentView get_tangent_view( vec3 p, vec3 c, float r )\n{\n\tTangentView ret;\n\tret.target_vector = p - c;\n\tfloat dt = length( ret.target_vector );\n\tret.target_vector \/= dt;\n\tfloat e = ( r * r ) \/ dt;\n\tret.tangent_disk_radius = sqrt( r * r - e * e );\n\tret.tangent_disk_center = c + ret.target_vector * e;\n\treturn ret;\n}\n\n\/\/ set view center on tangent of a sphere c,r\nvec3 get_tangent_point( vec3 p, vec3 c, float r, vec3 up )\n{\n\tTangentView tv = get_tangent_view( p, c, r );\n\treturn tv.tangent_disk_center +\n\t\t   tv.tangent_disk_radius * normalize( cross( tv.target_vector, cross( up, tv.target_vector ) ) );\n}\n\n\/\/ reflect is builtin so use different name\nfloat myreflect( float x, float a ) { return a + ( a - x ); }\n\n\/\/ bounce time to make sure we are always travelling above the lit face of the earth\nfloat bounce_time( float t, float period, inout float fade )\n{\n\tt = mod( t, period );\n\tif ( t > period * 0.5 ) t -= period; \/\/ want mirrored time values\n\tfloat r = period * 0.005;\n\tfloat a = period * 0.25;\n\tfade *= 1.0 - smoothbump( a + r, r, clamp( abs( t ), a, a + r + r ) );\n\tif ( abs( t ) > ( a + r ) ) t = myreflect( t, ( ( t < 0.0 ) ? -1.0 : 1.0 ) * period * 0.25 );\n\treturn t;\n}\n\nvec3 rotate_around( vec3 c, vec3 z, vec3 p, float angle )\n{\n\tvec3 v = p - c;\n\tvec3 pp = project_on_line1( p, c, z );\n\tvec3 x = normalize( p - pp );\n\tvec3 y = cross( z, x );\n\tvec2 v2 = vec2( dot( v, x ), dot( v, y ) );\n\tv2 = rotate_with_angle( v2, angle );\n\treturn pp + v2.x * x + v2.y * y;\n}\n\n\/\/ can't find the source shadertoy for those functions...\n#define KEY_SPACE 32.\n#define KEY_RIGHT 39.\nbool key_toggle( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) \/ 256., 0.75 ) ).x > 0.); }\nbool key_state( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) \/ 256., 0.25 ) ).x > 0.); }\n\nmat4 get_earth_camera( inout float tan_half_fovy\n\t\t\t\t\t   , inout float fade\n\t\t\t\t\t   , float time\n\t\t\t\t\t   , out LameTweaks lame_tweaks\n\t\t\t\t\t   , inout float exposure )\n{\n\tvec3 eye = vec3( 0, 0, 2.0 );\n\tvec3 center = vec3( 0, 0, 0 );\n\n\tfloat roll = 0.0;\n\n#define IS_NEXT_INDEX(nn) ( abs( camera_index - nn ) < 0.01 )\n\n#ifdef FORCE_CAMERA\n\tfloat camera_index = FORCE_CAMERA;\n#else\n\tfloat camera_index = mod( floor( time \/ CAMERA_PERIOD ), CAMERA_NUM );\n#endif\n\tfade = pow2( saturate( tri( time, CAMERA_PERIOD ) ) );\n\n\tfloat camera_time = mod( time, CAMERA_PERIOD );\n\n\tfloat earth_rot_time_scale = 1.0;\n\tfloat earth_rot_time_offset = 0.0;\n\tfloat cloud_flow_time_scale = 1.0;\n\tfloat cloud_flow_time_offset = 0.0;\n\tlame_tweaks.specular_hack = 0.25;\n\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.5 );\n\n#ifdef CAMERA_TIME_RESET\n\ttime = camera_time;\n#endif\n\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, 0.0 );\n\n\tfloat x = camera_time * ( 1.0 \/ CAMERA_PERIOD );\n\tfloat xs6 = smoothstep_unchecked_6( x );\n\n\tif ( IS_NEXT_INDEX( CAMERA_ORBITING_CLOSE ) )\n\t{\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 180.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 20.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\t\/\/ time = 0; \/\/ eye should be on y=0,1,0 at time=0\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tvec3 up = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.98, up );\n\t\ttan_half_fovy = 0.09;\n\t\troll = time * 0.02;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 2000.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 1.5;\n\t\tmm_offset = vec2( 0.0, 0.0 );\n\/\/\t\texposure = 0.45;\n\t\tlame_tweaks.cloud_hack.z = 0.35;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_ORBITING_FAR ) )\n\t{\n\t\tvec3 up = vec3( 0, 0,  1 );\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 25.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 10.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tup = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.965, up ); \/\/ don't look at real horizon, show more earth\n\t\ttan_half_fovy = 0.3; \/\/ 0.3 for sphere\n\/\/\t\troll = time*0.02;\n\t\troll = PI * 3.0 \/ 4.0;\n\t\tearth_rot_time_scale = 12.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 12.0;\n\t\tcloud_flow_time_offset = -10.0;\n\t\tmouse_ctrl = 0.6;\n\t\tmm_offset = vec2( 0.37, -0.08 );\n\t\texposure = 0.75;\n\t\tlame_tweaks.specular_hack = 0.07;\n\t\tlame_tweaks.cloud_hack = vec3( 4.2, 0.12, 0.27 ); \/\/ too much decal\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_BLUE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.382552146, 3.343272924, -0.757502257 ) * cam_scale;\n\t\tvec3 n = normalize( eye );\n\t\tvec3 up = sun_direction;\n\t\teye += n * 500.0 * xs6;\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * mix( 1.0, 0.96, xs6 ), up ); \/\/ don't look at real horizon, show more earth\n\t\ttan_half_fovy = mix( 0.2, 0.09, xs6 );\n\t\troll = PI * mix( 0.25, -0.02, 1.0 - exp( -x * 2.0 ) );\n\t\tearth_rot_time_scale = 198.0;\n\t\tearth_rot_time_offset = 39.9;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tlame_tweaks.specular_hack = 0.25;\n\t\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.3 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_CLOUDS ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( -5.704154491, -0.459553778, -3.58820796 ) * cam_scale;\n\t\tcenter = vec3( -5.828063488, -0.007100194, -2.705070018 ) * cam_scale;\n\t\tcenter = eye + ( center - eye ) * mix( 0.8, 0.8, x );\n\t\teye = rotate_around( center, normalize( center ), eye, x * PI * 0.12 );\n\t\ttan_half_fovy = 0.05;\n\t\troll = mix( -0.2, -0.3, x ) * PI;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = -1600.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = -900.0;\n\t\tmouse_ctrl = 2.5;\n\t\texposure = 0.8;\n\t\tlame_tweaks.cloud_hack = vec3( 4.0, 0.12, 0.6 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_FAR ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat rt = 0.25;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * rt );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * rt );\n\t\ttan_half_fovy = 0.62;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 20.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 100.0;\n\t\tmouse_ctrl = 0.26;\n\t\tmm_offset = vec2( -0.5, -0.29 );\n\t\tlame_tweaks.specular_hack = 150.0;\n\t\tlame_tweaks.cloud_hack = vec3( 4.5, 0.15, 1.0 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_CLOSE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat r = 0.0603;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * r );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * r );\n\t\ttan_half_fovy = 0.3;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 22.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 0.9;\n\t\tmm_offset = vec2( -0.84, -0.28 );\n\t\tlame_tweaks.specular_hack = 100.0;\n\t\tlame_tweaks.cloud_hack = vec3( 3.4, 0.15, 0.9 );\n\t\texposure = 0.5;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_SUNRISE ) )\n\t{\n\t\tfloat at1 = exp( -x * 10.0 ); \/\/ anim time 1: approach\n\t\tfloat at2 = smoothstep_unchecked_6( remap( x, 0.3, 1.0 ) ); \/\/ anim time 2: ascension\n\t\tfloat r = earth_radius + cloud_start * 5.0 + atm_max * at2 * 200.0;\n\t\tvec3 up = vec3( 0, 0, 0 ); up.zx = unit_vector2( -PI * 0.56 );\n\t\tvec3 sun_pos = sun_dist * sun_direction;\n\t\tvec3 tangent_point = get_tangent_point( sun_pos, earth_center, r, up );\n\t\tcenter = tangent_point;\n\t\tvec3 rail = normalize( sun_pos - tangent_point );\n\t\tfloat d0 = earth_radius * 0.08; \/\/ distance to tangent point is d\n\t\tfloat d1 = earth_radius * 0.03;\n\t\teye = tangent_point + rail * mix( -d0, d1, x ); \/\/\n\t\tvec3 end_center = get_tangent_point( eye, earth_center, earth_radius * 0.984, sun_direction );\n\t\tcenter = eye + rail;\n\t\tcenter = mix( center, end_center, at2 );\n\t\ttan_half_fovy = 0.15;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 90.0;\n\t\texposure = mix( 0.4, 0.75, xs6 );\n\t\tlame_tweaks.cloud_hack = vec3( 3.0, 0.12, 0.65 );\n\t\tmm_offset = vec2( 0.0, -0.1 * xs6 );\n\t\tmouse_ctrl = 1.2;\n\t\troll = PI * 0.0;\n\t\tlame_tweaks.specular_hack = 0.1;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_MOON_WIP ) )\n\t{\n\t\tfloat d = earth_radius * 0.5; \/\/ distance to tangent point is d\n\t\tfloat r = earth_radius + 4.0 * atm_max;\n\t\tvec3 moon_pos = moon_dist * moon_direction * 1.0;\n\t\tvec3 tangent_point = get_tangent_point( moon_pos, earth_center, r, vec3( 0, 1, 0 ) );\n\t\tcenter = tangent_point;\n\t\teye = tangent_point + d * normalize( tangent_point - moon_pos ); \/\/\n\t\ttan_half_fovy = 0.045;\n\t\tearth_rot_time_scale = 30.0;\n\t\tearth_rot_time_offset = 1700.0;\n\t\tcloud_flow_time_scale = 3.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\troll = -PI * 0.5;\n\t\tlame_tweaks.cloud_hack = vec3( 2.6, 0.12, 0.22 );\n\t\tmouse_ctrl = 0.5;\n\t\tmm_offset = vec2( -0.07, 0.018 );\n\t}\n\n\tvec3 up = normalize( eye ); \/\/ horizontal views\n\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) \/ ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\/\/\tcamera_time = GLOBALTIME; \/\/ comment to always show the same time slice\n\tlame_tweaks.cloud_flow_time = ( cloud_flow_time_offset + camera_time ) * cloud_flow_time_scale;\n\tlame_tweaks.earth_rot_time = ( earth_rot_time_offset + camera_time ) * earth_rot_time_scale;\n\n\treturn lookat( eye, center, up ) * z_rotation( roll ) * yup_spherical_offset( mm.y, mm.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 pixel = fragCoord.xy;\n\tfragColor = vec4( 0., 0., 0., 1 );\n\n#ifdef HD_BLACK_BANDS\n\tfloat aspect = ( 16.0 \/ 9.0 ); \/\/ the ratio we want\n\tif ( iResolution.x < aspect * iResolution.y )\n\t{\n\t\tresolution.y = resolution.x * ( 1.0 \/ aspect );\n\t\tpixel.y -= ( iResolution.y - resolution.y ) * 0.5;\n\t\tif ( abs( pixel.y * 2.0 - resolution.y ) > resolution.y ) return;\n\t}\n\telse\n\t{\n\t\tresolution.x = resolution.y * aspect;\n\t\tpixel.x -= ( iResolution.x - resolution.x ) * 0.5;\n\t\tif ( abs( pixel.x * 2.0 - resolution.x ) > resolution.x  ) return;\n\t}\n#else\n\tfloat aspect = ( resolution.x \/ resolution.y );\n#endif\n\tvec2 uv = pixel \/ resolution.xy;\n\n\tfloat fade = 1.0;\n\tfloat tan_half_fovy = 0.06; \/\/ so we can see then sun\n\tfloat znear = 0.1;\n\tLameTweaks lame_tweaks;\n\tfloat exposure = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tmat4 camera;\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\tcamera[3].xyz *= 1e+3 * atm_scale;\n#else\n\tfloat fast_forward = ( key_state( KEY_RIGHT ) ? 5.0 : 1.0 );\n\tmat4 camera = get_earth_camera( tan_half_fovy, fade, GLOBALTIME * fast_forward, lame_tweaks, exposure );\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0 ) ).xyz;\n\n#ifdef SUPER_SAMPLE_HORIZON\n\t\/\/ do SS on edge pixels... still expensive\n\tfloat ss = vec3( 1 - exp( -abs( length( project_on_line1( earth_center, view_ray.o, view_ray.d ) - earth_center ) - earth_radius ) * 0.1 ) );\n\tfragColor = vec4( ss, ss, ss, 1.0 );\n\tif ( ss < 0.7 )\n\t{\n\t\tvec2 pmin = ( pixel + vec2( 0.0, 0.0 ) ) \/ resolution.xy;\n\t\tvec2 pmax = ( pixel + vec2( 1.0, 1.0 ) ) \/ resolution.xy;\n\n\t\tfragColor.rgb = vec3( 0 );\n\t\tfor ( int i = 0; i < 2; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 2; j++ )\n\t\t\t{\n\t\t\t\tvec2 uv2 = pmin + ( pmax - pmin )\n\t\t\t\t\t* vec2(\n\t\t\t\t\t0.5 + float( i ) \/ 2.0,\n\t\t\t\t\t0.5 + float( j ) \/ 2.0 );\n\t\t\t\tRay subray = get_view_ray( ( uv2 - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\t\t\t\tsubray.o = camera[3].xyz; \/\/ make sure all rays have same origin! we don't really care about havnig a znear here\n\t\t\t\tsubray.d = ( camera * vec4( subray.d, 0 ) ).xyz;\n\t\t\t\tfragColor.rgb += earthShader( subray, camera, lame_tweaks, exposure );\n\t\t\t}\n\t\t}\n\t\tfragColor.rgb \/= 4.0;\n\t\treturn;\n\t}\n#endif\n\n\tfragColor.rgb = earthShader( view_ray, camera, lame_tweaks, exposure ) * fade;\n\treturn;\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4l33W4","date":"1469348130","viewed":7359,"name":"[SH16C] Tron","username":"davidbargo","description":"Win the opponent 5 times to win the game\n\nIn main screen select the game mode with the arrows and press ENTER to start playing\nPlayer 1: Move with the arrows, SPACE for turbo\nPlayer 2: Move with W, A, S, D and SHIFT for turbo\nDEL to restart","likes":72,"published":3,"flags":112,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4djGRR","filepath":"https:\/\/soundcloud.com\/disney-music-group-emea\/derezzed-by-daft-punk-tron","previewfilepath":"https:\/\/soundcloud.com\/disney-music-group-emea\/derezzed-by-daft-punk-tron","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by David Bargo - davidbargo\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture( iChannel0, fragCoord.xy\/iResolution.xy ).xyz;\n    vec3 fontLayer = texture( iChannel1, fragCoord.xy\/iResolution.xy ).xyz;\n\n    col = mix(col, fontLayer, fontLayer.x + fontLayer.y + fontLayer.z > 0.01 ? 1.:0.);\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by David Bargo - davidbargo\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/ gameplay\n\n\/\/----------------------------------------------------------------------------------------------\n\n\nconst vec2 txP1PosDir        = vec2(124.0,1.0);\nconst vec2 txState           = vec2(124.0,3.0);\nconst vec2 txWins            = vec2(124.0,5.0);\nconst vec2 txBoosts          = vec2(124.0,7.0);\nconst vec2 txP2PosDir        = vec2(124.0,9.0);\nconst vec2 txOptions         = vec2(124.0,11.0);\nconst vec4 txCells           = vec4(0.0,0.0,108.0,124.0);\n\n\nconst float KEY_ENTER = 13.5\/256.0;\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_DEL   = 46.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_SHIFT = 16.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\n\nconst float speedPlayer = 60.0;\nconst float boostTime = 1.;\nconst float speedBoost = 150.0;\n\nfloat map( in vec2 p ) \n{\n    float x = abs(p.x - txCells.z*.5) - txCells.z*0.5;\n    float y = abs(p.y - txCells.w*.5) - txCells.w*0.5;\n\treturn x > -4. || y > -4. ? 1.:0.;\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > txCells.w + 1. || fragCoord.y>txCells.w + 1. ) discard;\n    \n    \/\/---------------------------------------------------------------------------------   \n\t\/\/ load game state\n\t\/\/---------------------------------------------------------------------------------\n    vec4  p1PosDir        = loadValue( txP1PosDir );\n    vec4  p2PosDir        = loadValue( txP2PosDir );\n    float state           = loadValue( txState ).x;\n    vec2  wins            = loadValue( txWins ).xy;\n    float cell            = loadValue( fragCoord-0.5 ).x;\n    vec4  boosts          = loadValue( txBoosts );\n\tvec2  options         = loadValue( txOptions ).xy;\n    \n    \/\/---------------------------------------------------------------------------------\n    \/\/ reset\n\t\/\/---------------------------------------------------------------------------------\n    if( iFrame==0 )\n    {\n        state = -10.0;\n        options = vec2(1, 0);\n    }\n\n    if (state < -9.)\n    {\n        \/\/ Main Screen\n        float pressEnter = texture( iChannel1, vec2(KEY_ENTER,0.25) ).x;\n        if( pressEnter<0.5 && options.y > 1.5)\n        {\n            options.y = 0.;\n        }\n        else if (options.y < 1.5) \n        {\n            if( pressEnter>0.5 )\n            {\n                state = -5.0;\n            }\n            else\n            {\n\n                float changeOption = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x + texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n                if (options.y > 0.5)\n                {\n                    if (changeOption < 0.5) options.y = 0.;\n                }\n                else if( changeOption > 0.5 )\n                {\n                    options.x = 1. - options.x;\n                    options.y = 1.;\n                }\n            }\n        }\n    }\n    else\n    {\n        if( state<0.5 )\n        {\n            p1PosDir  = vec4(txCells.z\/2.,13.0,0.0,3.0);\n            p2PosDir  = vec4(txCells.z\/2.,txCells.w - 13.0,0.0,4.0);\n            boosts    = vec4(3., -1., 3., -1.);\n        }\n\n        if( state < -4. )\n        {\n            state          = -3.0;\n            wins           =  vec2(0.);\n            if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                cell = map( fragCoord );\n\n        }\n        else if( state < 0.5 )\n        {\n            state += iTimeDelta*1.75;\n            if( state >= 0. )\n            {\n                state = 1.0;\n            }\n        }\n        else if( state < 1.5 ) \n        {\n\n            \/\/ controls p1\n            if( texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x>0.5 && p1PosDir.w > 2.5) p1PosDir.w = 1.;\n            if( texture( iChannel1, vec2(KEY_LEFT, 0.25) ).x>0.5 && p1PosDir.w > 2.5) p1PosDir.w = 2.;\n            if( texture( iChannel1, vec2(KEY_UP,   0.25) ).x>0.5 && p1PosDir.w < 2.5) p1PosDir.w = 3.;\n            if( texture( iChannel1, vec2(KEY_DOWN, 0.25) ).x>0.5 && p1PosDir.w < 2.5) p1PosDir.w = 4.;\n\n            if( texture( iChannel1, vec2(KEY_SPACE, 0.25) ).x>0.5 && boosts.x > 0. && boosts.y < 0. )\n            {\n                boosts.x--;\n                boosts.y = boostTime;\n            }\n\n\t\t\tif (options.x > 0.5)\n            {\n                \/\/ AI\n                \n                float bestDir = p2PosDir.w;\n                int bestCount = -1;\n\n                for (float i = 0.; i < 4.; i++)\n                {\n                    float d = mod(p2PosDir.w+i - 1., 4.) + 1.;\n                    vec2 destPos = p2PosDir.xy +dir2dis(d);\n\n                    if (loadValue(destPos).x < 0.25)\n                    {\n                        int count = 0;\n                        for (float i2 = 1.; i2 < 5.; i2++)\n                        {\n                            vec2 destPos2 = destPos.xy +dir2dis(i2);\n\n                            if (loadValue(destPos2).x < 0.25)\n                            {\n                                for (float i3 = 1.; i3 < 5.; i3++)\n                                {\n                                    vec2 destPos3 = destPos2.xy +dir2dis(i3);\n\n                                    if (loadValue(destPos3).x < 0.25)\n                                    {\n                                        for (float i4 = 1.; i4 < 5.; i4++)\n                                        {\n                                            vec2 destPos4 = destPos3.xy +dir2dis(i4);\n\n                                            if (loadValue(destPos4).x < 0.25)\n                                            {\n                                                count++;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\t\t\t\t\t\tif (count == bestCount)\n                        {\n                            float newDist2Player = length(destPos - p1PosDir.xy);\n                            float bestDist2Player = length(p2PosDir.xy +dir2dis(bestDir) - p1PosDir.xy);\n                        \tif (newDist2Player < bestDist2Player)\n                            {\n                                bestCount = count;\n                            \tbestDir = d;\n                            }\n                        }\n                        else if (count > bestCount)\n                        {\n                            bestCount = count;\n                            bestDir = d;\n                        }\n                    }\n                }\n                p2PosDir.w = bestDir;\n                \n                if( boosts.z > 0. && boosts.w < 0. && hash(float(iFrame)*13.1) > 0.995)\n                {\n                    boosts.z--;\n                    boosts.w = boostTime;\n                }\n            }\n\t\t\telse\n            {\n                \/\/ controls p2\n                if( texture( iChannel1, vec2(KEY_D    ,0.25) ).x>0.5 && p2PosDir.w > 2.5) p2PosDir.w = 1.;\n                if( texture( iChannel1, vec2(KEY_A   , 0.25) ).x>0.5 && p2PosDir.w > 2.5) p2PosDir.w = 2.;\n                if( texture( iChannel1, vec2(KEY_W ,   0.25) ).x>0.5 && p2PosDir.w < 2.5) p2PosDir.w = 3.;\n                if( texture( iChannel1, vec2(KEY_S   , 0.25) ).x>0.5 && p2PosDir.w < 2.5) p2PosDir.w = 4.;\n\n                if( texture( iChannel1, vec2(KEY_SHIFT, 0.25) ).x>0.5 && boosts.z > 0. && boosts.w < 0. )\n                {\n                    boosts.z--;\n                    boosts.w = boostTime;\n                }\n            }\n\n            p1PosDir.z += iTimeDelta*(boosts.y > 0. ? speedBoost : speedPlayer);\n            p2PosDir.z += iTimeDelta*(boosts.w > 0. ? speedBoost : speedPlayer);\n            boosts.y = max(boosts.y - iTimeDelta, -1.);\n            boosts.w = max(boosts.w - iTimeDelta, -1.);\n\n            vec2 off = dir2dis(p1PosDir.w);\n            vec2 np = p1PosDir.xy + off;\n\n            if( p1PosDir.z>=1.0 )\n            {\n                p1PosDir.z = 0.0;\n\n                float c = loadValue( np ).x;\n                if( c > 0.25 )\n                {\n                    state = 2.0;\n                }\n                else\n                {\n                    p1PosDir.xy = np;\n\n                    float isin = isInside( fragCoord, np );\n                    if( isin>0.0 ) cell = 2.;\n                }\n            }\n\n            off = dir2dis(p2PosDir.w);\n            np = p2PosDir.xy + off;\n\n            if( p2PosDir.z>=1.0 )\n            {\n                p2PosDir.z = 0.0;\n\n                float c = loadValue( np ).x;\n                if( c > 0.25 )\n                {\n                    state = state > 1.5 ? 4. : 3.0;\n                }\n                else\n                {\n                    p2PosDir.xy = np;\n\n                    float isin = isInside( fragCoord, np );\n                    if( isin>0.0 ) cell = 3.;\n                }\n            }\n\n            if (abs(p1PosDir.x -p2PosDir.x) < 0.5 && abs(p1PosDir.y -p2PosDir.y) < 0.5) state = 4.;\n\n            if (state < 3.5 && state > 1.5)\n            {\n                if (state > 2.5) wins.x++;\n                else wins.y++;\n            }\n        }\n        else\n        {\n            float pressEnter = texture( iChannel1, vec2(KEY_ENTER,0.25) ).x;\n            if( pressEnter>0.5 )\n            {\n                if (wins.x > 4.5 || wins.y > 4.5)\n                {\n                    options.y = 2.;\n                \tstate = -10.;   \n                }\n                else\n                {\n                    if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                        cell = map( fragCoord );\n                    state = -3.0;\n                }\n            }\n        }\n        \n        float pressDel = texture( iChannel1, vec2(KEY_DEL,0.25) ).x;\n        if( pressDel>0.5 )\n        {\n            if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                cell = map( fragCoord );\n            state = -10.0;\n            options.y = 2.;\n        }\n    }\n  \n\t\/\/---------------------------------------------------------------------------------\n\t\/\/ store game state\n\t\/\/---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n   \n    storeValue( txP1PosDir,         vec4(p1PosDir),              fragColor, fragCoord );\n    storeValue( txP2PosDir,         vec4(p2PosDir),              fragColor, fragCoord );\n    storeValue( txState,            vec4(state,0.0,0.0,0.0),     fragColor, fragCoord );\n    storeValue( txWins,             vec4(wins,0.0,0.0),          fragColor, fragCoord );\n    storeValue( txCells,            vec4(cell,0.0,0.0,0.0),      fragColor, fragCoord );\n    storeValue( txBoosts,           vec4(boosts),                fragColor, fragCoord );\n    storeValue( txOptions,          vec4(options,0.0,0.0),       fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Created by David Bargo - davidbargo\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/ rendering\n\nconst vec2 txP1PosDir    = vec2(124.0,1.0);\nconst vec2 txState       = vec2(124.0,3.0);\nconst vec2 txWins        = vec2(124.0,5.0);\nconst vec2 txBoosts      = vec2(124.0,7.0);\nconst vec2 txP2PosDir    = vec2(124.0,9.0);\nconst vec4 txCells       = vec4(0.0,0.0,108.0,124.0);\n\nconst vec3 p1Color       = vec3(1.,0.9,0.2);\nconst vec3 p2Color       = vec3(.0,0.9,1.);\n\n\/\/============================================================\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdDonut(vec2 pos, float radius, float width)\n{\n    return abs(length(pos)-radius)-width;   \n}\n\nvec2 rot(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn p * mat2(c, -s, s, c);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-(dist+0.01)*100.0, 0.0, 1.0);\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n\/\/============================================================\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/============================================================\n\nfloat IsGridLine(vec2 fragCoord)\n{\n\tvec2 vPixelsPerGridSquare = vec2(32.0, 32.0);\n\t\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\t\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate \/ vPixelsPerGridSquare);\n\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(2.3));\n\t\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\treturn fIsGridLine;\n}\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/iResolution.xy;\n    float xCells = txCells.w*(iResolution.x \/ iResolution.y);\n    vec2 p = uv-vec2(0.5-txCells.z\/(xCells*2.), 0.); \/\/ center\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    vec2 q = floor(p*txCells.w);\n    vec2 r = fract(p*txCells.w);\n\n    vec2 l = vec2((15.*fragCoord-iResolution.xy)\/iResolution.y);\n    l.x -= 0.55; l.y -= 0.5;\n    l = abs(fract(l) - 0.5) - 0.25;\n    l = step(0.0, l)*l*4.0;\n    l *= l; l *= l; l *= l;\n    l = 1. - l;\n    float val = 1.0 - l.x*l.y;\n    \n    vec3 bg = mix(vec3(0., 0.1, 0.15), vec3(1.), val);\n    col += bg*step(0., p.x)*step(p.x, txCells.z\/txCells.w);\n    if( q.x>=0.0 && q.x<=txCells.z )\n    {\n        float c = texture( iChannel0, (q+0.5)\/iResolution.xy, -100.0 ).x;\n        if( c>0.5 )\n        {            \n            float d = sdBox(r-0.5, vec2(1.));\n            float f = 1.0 - smoothstep( -0.01, 0.01, d );\n            \n            vec3 wco = c > 2.5 ? p2Color :\n            \t\t   c > 1.5 ? p1Color : vec3(0.25);\n            col = mix( col, wco, f );\n            \/\/col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*d*d);\n        }\n    }\n    return col;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) \/ txCells.w;\n    return c;\n}\n\n\nvec3 drawPlayer( vec3 col, in vec2 fragCoord, float player, in vec4 playerPosDir, bool dead )\n{\n    vec2 off = dir2dis(playerPosDir.w);    \n    vec2 mPlayerPos = playerPosDir.xy + off*playerPosDir.z;\n\n    vec2 uv = fragCoord.xy \/iResolution.xy;\n    float xCells = txCells.w*(iResolution.x \/ iResolution.y);\n    vec2 p = uv-vec2(0.5-txCells.z\/(xCells*2.), 0.); \/\/ center\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    vec2 q = p - cell2ndc( mPlayerPos );\n\n    float c = sdCircle(q, 0.023);\n\n    vec3 color = mix(p1Color, p2Color, player - 1.);\n    \n    float phase = 0.5+0.5*sin(2.0*6.2831*iTime);\n    if (dead) color = mix(color, vec3(1., 0., 0.), phase);\n    col += 0.1*color*exp((-100.0 - (dead ? 50.*phase : 0.))*c);\n\n    return col;\n}\n\n\n#define PI 3.141592\nvec3 drawMainTitle(vec3 col, vec2 fragCoord)\n{    \n    vec2 uv = fragCoord.xy \/iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    p *= 120.;\n    \n    \/\/ green lines\n    float f = abs((p.x)-32.);\n    f = min(f, abs((p.y)-48.));\n    col += vec3(0.,0.8,0.3)*exp(-1.5*f);\n    \n    p += vec2(130, -80);\n\n    \/\/ T\n    float d = sdBox(p + vec2(-32, 8), vec2(32, 8));\n    d = merge(d,  sdBox(p + vec2(-32, 32), vec2(16, 32)));\n    \n    \/\/ R\n    p.x -= 65.;\n    d = merge(d,  sdBox(p + vec2(-8, 16+32), vec2(8, 16)));\n    float r = sdBox(p + vec2(-26-16, 16+32), vec2(26, 16));\n    r = intersect(r, sdBox(rot(p + vec2(-30-12, 12+36), PI\/3.7), vec2(30, 8)));\n\td = merge(d, r);\n    \n    d = merge(d, sdBox(p + vec2(-12 -8, 8),     vec2(12, 8)));\n    d = merge(d, sdCircle(p + vec2(-12. -19., 8),     8.));\n    d = merge(d, sdCircle(p + vec2(-12. -21., 8),     8.));\n        \n    r = sdDonut(p + vec2(-32, 32), 24., 8.);\n    r = intersect(r, sdBox(p + vec2(-32 - 16, 16),         vec2(16, 16)));\n        \n    d = merge(d, r);\n    \n    \/\/ O\n    p.x -= 65.;\n    d = merge(d, sdDonut(p - vec2(32, -32), 24., 8.));\n    \n    \/\/ N\n    p.x -= 65.;\n    float nc = sdBox(rot(p + vec2(-32-13, 0), PI\/4.), vec2(64, 32));\n    float nd = sdBox(p + vec2(-32 , 32),         vec2(32, 32));\n    r = substract(sdBox(p + vec2(-32-16 , 32+18), vec2(32, 18)), substract(nc, nd));\n    d = merge(d, r);\n    r = substract(sdBox(p, vec2(32+16, 32)), intersect(nc, nd));\n    d = merge(d, r);\n    \n    \n    vec3 fontColor = mix(vec3(0., 0., 0.02), vec3(0., 0.5, 0.7), smoothstep(-32., -48., p.y));\n    fontColor = mix(fontColor, vec3(1.), smoothstep(-40., -56., p.y));\n\tcol = mix(col, fontColor, fillMask(d));\n\tcol = mix(col, vec3(.9,0,0), innerBorderMask(d, 2.));\n    \n    return col;\n}\n\n\/\/============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/------------------------\n    \/\/ load game state\n    \/\/------------------------\n       \n    vec4  p1PosDir  = loadValue( txP1PosDir );\n    vec4  p2PosDir  = loadValue( txP2PosDir );\n    float state     = loadValue( txState ).x;\n    vec2  wins      = loadValue( txWins ).xy;\n\tvec2  boosts    = loadValue( txBoosts ).xz;\n\n    \/\/------------------------\n    \/\/ render\n    \/\/------------------------\n    vec3 col = vec3(0.0);\n    \n    if (state < -9.)\n    {\n        col = drawMainTitle(col, fragCoord);\n    }\n    else \n    {\n        \/\/ map\n        col = drawMap( col, fragCoord );\n\n        \/\/ players\n        col = drawPlayer( col, fragCoord, 1., p1PosDir, (state > 1.5 && state < 2.5) || state > 3.5 );\n        col = drawPlayer( col, fragCoord, 2., p2PosDir, state > 2.5 );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Font rendering\n\nconst vec2 txState           = vec2(124.0,3.0);\nconst vec2 txWins            = vec2(124.0,5.0);\nconst vec2 txBoosts          = vec2(124.0,7.0);\nconst vec2 txOptions         = vec2(124.0,11.0);\n\nconst vec3 p1Color       = vec3(1.,0.9,0.2);\nconst vec3 p2Color       = vec3(.0,0.9,1.);\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/============================================================\n\/\/ Font rendering by Flyguy (https:\/\/www.shadertoy.com\/view\/llSGRm)\n\n\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n\nvec2 print_pos = vec2(0);\nfloat font_size = 5.;\n\/\/Automatically generated from the sprite sheet here: http:\/\/uzebox.org\/wiki\/index.php?title=File:Font6x8.png\nvec2 ch_spc = vec2(0.0,0.0);\nvec2 ch_exc = vec2(276705.0,32776.0);\nvec2 ch_quo = vec2(1797408.0,0.0);\nvec2 ch_hsh = vec2(10738.0,1134484.0);\nvec2 ch_dol = vec2(538883.0,19976.0);\nvec2 ch_pct = vec2(1664033.0,68006.0);\nvec2 ch_amp = vec2(545090.0,174362.0);\nvec2 ch_apo = vec2(798848.0,0.0);\nvec2 ch_lbr = vec2(270466.0,66568.0);\nvec2 ch_rbr = vec2(528449.0,33296.0);\nvec2 ch_ast = vec2(10471.0,1688832.0);\nvec2 ch_crs = vec2(4167.0,1606144.0);\nvec2 ch_per = vec2(0.0,1560.0);\nvec2 ch_dsh = vec2(7.0,1572864.0);\nvec2 ch_com = vec2(0.0,1544.0);\nvec2 ch_lsl = vec2(1057.0,67584.0);\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_col = vec2(195.0,1560.0);\nvec2 ch_scl = vec2(195.0,1544.0);\nvec2 ch_les = vec2(135300.0,66052.0);\nvec2 ch_equ = vec2(496.0,3968.0);\nvec2 ch_grt = vec2(528416.0,541200.0);\nvec2 ch_que = vec2(934929.0,1081352.0);\nvec2 ch_ats = vec2(935285.0,714780.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\nvec2 ch_lsb = vec2(925826.0,66588.0);\nvec2 ch_rsl = vec2(16513.0,16512.0);\nvec2 ch_rsb = vec2(919584.0,1065244.0);\nvec2 ch_pow = vec2(272656.0,0.0);\nvec2 ch_usc = vec2(0.0,62.0);\nvec2 ch_a = vec2(224.0,649374.0);\nvec2 ch_b = vec2(1065444.0,665788.0);\nvec2 ch_c = vec2(228.0,657564.0);\nvec2 ch_d = vec2(66804.0,665758.0);\nvec2 ch_e = vec2(228.0,772124.0);\nvec2 ch_f = vec2(401543.0,1115152.0);\nvec2 ch_g = vec2(244.0,665474.0);\nvec2 ch_h = vec2(1065444.0,665762.0);\nvec2 ch_i = vec2(262209.0,33292.0);\nvec2 ch_j = vec2(131168.0,1066252.0);\nvec2 ch_k = vec2(1065253.0,199204.0);\nvec2 ch_l = vec2(266305.0,33292.0);\nvec2 ch_m = vec2(421.0,698530.0);\nvec2 ch_n = vec2(452.0,1198372.0);\nvec2 ch_o = vec2(228.0,665756.0);\nvec2 ch_p = vec2(484.0,667424.0);\nvec2 ch_q = vec2(244.0,665474.0);\nvec2 ch_r = vec2(354.0,590904.0);\nvec2 ch_s = vec2(228.0,114844.0);\nvec2 ch_t = vec2(8674.0,66824.0);\nvec2 ch_u = vec2(292.0,1198868.0);\nvec2 ch_v = vec2(276.0,664840.0);\nvec2 ch_w = vec2(276.0,700308.0);\nvec2 ch_x = vec2(292.0,1149220.0);\nvec2 ch_y = vec2(292.0,1163824.0);\nvec2 ch_z = vec2(480.0,1148988.0);\nvec2 ch_lpa = vec2(401542.0,66572.0);\nvec2 ch_bar = vec2(266304.0,33288.0);\nvec2 ch_rpa = vec2(788512.0,1589528.0);\nvec2 ch_tid = vec2(675840.0,0.0);\nvec2 ch_lar = vec2(8387.0,1147904.0);\n\n\n\/\/Extracts bit b from the given number.\n\/\/Shifts bits right (num \/ 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,22.0); \/\/Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(vec2 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv\/font_size - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\/\/Returns the digit sprite for the given number.\nvec2 get_digit(int d)\n{    \n    if(d == 0) return ch_0;\n    if(d == 1) return ch_1;\n    if(d == 2) return ch_2;\n    if(d == 3) return ch_3;\n    if(d == 4) return ch_4;\n    if(d == 5) return ch_5;\n    if(d == 6) return ch_6;\n    if(d == 7) return ch_7;\n    if(d == 8) return ch_8;\n    if(d == 9) return ch_9;\n    return vec2(0.0);\n}\n\n\/\/============================================================\n\/\/============================================================\n\n\nvec3 mainScreenText(vec2 uv, float playerVsGpu)\n{\n    vec3 c = vec3(0);\n    \n    float col = 0.0;\n    \n    font_size = mix(5., 7., playerVsGpu);\n    print_pos = vec2(-STRWIDTH(13.0)\/2.0, -150.\/font_size -STRHEIGHT(1.0)\/2.0);\n    \n    col = char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_v,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_G,uv);\n    col += char(ch_P,uv);\n    col += char(ch_U,uv);\n    c += mix(vec3(0.5), vec3(1.,.9,0.1), playerVsGpu)*col;\n    \n    font_size = mix(7., 5., playerVsGpu);\n    print_pos = vec2(-STRWIDTH(16.0)\/2.0, -250.\/font_size -STRHEIGHT(1.0)\/2.0);\n       \n    col = char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_v,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    c += mix(vec3(1.,.9,.1), vec3(0.5), playerVsGpu)*col;\n    \n    return c;\n}\n\nvec3 gameStartCounter(vec2 uv, float state)\n{        \n    font_size = 16.;\n    print_pos = vec2(-STRWIDTH(1.0)\/2.0, -STRHEIGHT(1.0)\/2.0);\n    float col = char(get_digit(int(-state)+1),uv);       \n\n    return vec3(.1,.9,1.)*col;\n}\n\nvec3 gameHud(vec2 uv, float playerVsGpu, vec2 wins, vec2 boosts)\n{        \n    font_size = 6.;\n    print_pos = vec2(-490.*(iResolution.x\/iResolution.y)\/font_size, 490.\/font_size-STRHEIGHT(1.0));\n    float col = 0.;       \n\tcol += char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_1,uv);\n    \n    font_size = 4.;\n    print_pos = vec2(-490.*(iResolution.x\/iResolution.y)\/font_size, 400.\/font_size-STRHEIGHT(1.0));\n\tcol += char(ch_L,uv);\n    col += char(ch_i,uv);\n    col += char(ch_v,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(5 - int(wins.y)),uv);\n    \n    print_pos = vec2(-490.*(iResolution.x\/iResolution.y)\/font_size, 330.\/font_size-STRHEIGHT(1.0));\n\tcol += char(ch_T,uv);\n    col += char(ch_u,uv);\n    col += char(ch_r,uv);\n    col += char(ch_b,uv);\n    col += char(ch_o,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(int(boosts.x)),uv);\n    \n    if (wins.x > 4.5)\n    {\n        font_size = 8.;\n        print_pos = vec2(-460.*(iResolution.x\/iResolution.y)\/font_size + STRWIDTH(1.0)\/2., 0.);\n        col += char(ch_Y,uv);\n        col += char(ch_O,uv);\n        col += char(ch_U,uv);\n        print_pos = vec2(-460.*(iResolution.x\/iResolution.y)\/font_size, -STRHEIGHT(1.0));\n        col += char(ch_W,uv);\n        col += char(ch_I,uv);\n        col += char(ch_N,uv);\n        col += char(ch_exc,uv);\n    }\n    else if (wins.y > 4.5)\n    {\n        font_size = 8.;\n        print_pos = vec2(-460.*(iResolution.x\/iResolution.y)\/font_size + STRWIDTH(1.0)\/2., 0.);\n        col += char(ch_Y,uv);\n        col += char(ch_O,uv);\n        col += char(ch_U,uv);\n        print_pos = vec2(-460.*(iResolution.x\/iResolution.y)\/font_size, -STRHEIGHT(1.0));\n        col += char(ch_L,uv);\n        col += char(ch_O,uv);\n        col += char(ch_S,uv);\n        col += char(ch_E,uv);\n    }\n    \n    vec3 p1c = p1Color*col;\n    \n    font_size = 6.;\n    \n    if (playerVsGpu > 0.5)\n    {\n        print_pos = vec2(490.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(3.0), 490.\/font_size-STRHEIGHT(1.0));\n        col = char(ch_G,uv);\n        col += char(ch_P,uv);\n        col += char(ch_U,uv);\n    }\n    else\n    {\n        print_pos = vec2(490.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(8.0), 490.\/font_size-STRHEIGHT(1.0));\n        col = char(ch_P,uv);\n        col += char(ch_L,uv);\n        col += char(ch_A,uv);\n        col += char(ch_Y,uv);\n        col += char(ch_E,uv);\n        col += char(ch_R,uv);\n        col += char(ch_spc,uv);\n        col += char(ch_2,uv);\n\n        if (wins.y > 4.5)\n        {\n            font_size = 8.;\n            print_pos = vec2(460.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(3.5), 0.);\n            col += char(ch_Y,uv);\n            col += char(ch_O,uv);\n            col += char(ch_U,uv);\n            print_pos = vec2(460.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(4.0), -STRHEIGHT(1.0));\n            col += char(ch_W,uv);\n            col += char(ch_I,uv);\n            col += char(ch_N,uv);\n            col += char(ch_exc,uv);\n        }\n        else if (wins.x > 4.5)\n        {\n            font_size = 8.;\n            print_pos = vec2(460.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(3.5), 0.);\n            col += char(ch_Y,uv);\n            col += char(ch_O,uv);\n            col += char(ch_U,uv);\n            print_pos = vec2(460.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(4.0), -STRHEIGHT(1.0));\n            col += char(ch_L,uv);\n            col += char(ch_O,uv);\n            col += char(ch_S,uv);\n            col += char(ch_E,uv);\n    \t}\n    }\n    \n    font_size = 4.;\n    print_pos = vec2(490.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(9.0), 330.\/font_size-STRHEIGHT(1.0));\n    col += char(ch_T,uv);\n    col += char(ch_u,uv);\n    col += char(ch_r,uv);\n    col += char(ch_b,uv);\n    col += char(ch_o,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(int(boosts.y)),uv);\n    \n    print_pos = vec2(490.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(8.0), 400.\/font_size-STRHEIGHT(1.0));\n\tcol += char(ch_L,uv);\n    col += char(ch_i,uv);\n    col += char(ch_v,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(5 - int(wins.x)),uv);\n    \n    \n                \n    vec3 p2c = p2Color*col;\n    return p1c + p2c;\n}\n\nvec3 showContinue(vec2 uv)\n{        \n    font_size = 4.;\n    float col = 0.;       \n\n    print_pos = vec2(480.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(11.0), -490.\/font_size+STRHEIGHT(2.0));\n    col += char(ch_P,uv);\n    col += char(ch_r,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_s,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_E,uv);\n    col += char(ch_N,uv);\n    col += char(ch_T,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    print_pos = vec2(480.*(iResolution.x\/iResolution.y)\/font_size - STRWIDTH(11.0), -490.\/font_size+STRHEIGHT(1.0));\n    col += char(ch_t,uv);\n    col += char(ch_o,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_c,uv);\n    col += char(ch_o,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_u,uv);\n    col += char(ch_e,uv);\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/------------------------\n    \/\/ load game state\n    \/\/------------------------\n    float state  = loadValue( txState ).x;\n    float playerVsGpu  = loadValue( txOptions ).x;\n    vec2 wins  = loadValue( txWins ).xy;\n    vec2 boosts  = loadValue( txBoosts ).xz;\n    \n    \n    \/\/------------------------\n    \/\/ render\n    \/\/------------------------\n    \n    vec3 col = vec3(0);\n    vec2 uv = fragCoord.xy \/iResolution.xy;\n    vec2 p = -500. + 1000.*uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    if (state < -9.)\n    {\n        col += mainScreenText(p, playerVsGpu);\n    }\n    else\n    {\n     \tif (state < 0.)\n        {\n            col += gameStartCounter(p, state);\n        }\n        else if (state > 1.5)\n        {\n            col += showContinue(p);\n        }\n        col += gameHud(p, playerVsGpu, wins, boosts);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ldSGzR","date":"1382482572","viewed":7356,"name":"Screen space bump mapping","username":"iq","description":"Mikkelsen's technique for Bump Mapping Unparametrized Surfaces  (pretty much copy & pasted).","likes":67,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ Mikkelsen's technique for Bump Mapping Unparametrized Surfaces \n\/\/ https:\/\/dl.dropboxusercontent.com\/u\/55891920\/papers\/mm_sfgrad_bump.pdf\n\/\/ Pretty much copy & pasted, with minor changes. It aliases quite a bit :(\n\n\n\/\/ make GPU_DERIVATIVES 1 for dFdx()\/dFdy() based derivatives, which produces\n\/\/ 2x2 pixel artifacts (in a deferred renderer you could perhaps compute these\n\/\/ by manually differencing UVs in the uv buffer)\n\n#define GPU_DERIVATIVES 0\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\n\n#if GPU_DERIVATIVES==1\nvec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    vec3 dpdx = dFdx( pos );\n    vec3 dpdy = dFdy( pos );\n    \n    float dbdx = dFdx(signal);\n    float dbdy = dFdy(signal);\n\n    vec3  u = cross( dpdy, nor );\n    vec3  v = cross( nor, dpdx );\n    float d = dot( dpdx, u );\n\t\n\tvec3 surfGrad = dbdx*u + dbdy*v;\n    return normalize( abs(d)*nor - sign(d)*scale*surfGrad );\n}\n\n#else    \n\nvec3 doBump( in vec3 dpdx, in vec3 dpdy, in vec3 nor, \n             in float dbdx, in float dbdy,\n             in float scale )\n{\n    vec3  u = cross( dpdy, nor );\n    vec3  v = cross( nor, dpdx );\n    float d = dot( dpdx, u );\n\t\n\tvec3 surfGrad = dbdx*u + dbdy*v;\n    return normalize( abs(d)*nor - sign(d)*scale*surfGrad );\n}\n#endif\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = clamp( 2.0 * h \/ b, 0.0, 1.0 );\n    }\n    return res;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 3.1 + 0.25*iTime;\n\tro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy)\/iResolution.y;\n\t\n     \/\/ camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bump = smoothstep( -0.8, -0.7, cos( 0.5*iTime ) );\n\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\n    \n    \/\/ sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n\tvec3 mate = vec3(0.0);\n\t\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t\/\/ raytrace-plane\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\t\n        vec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\t\n            \n        #if GPU_DERIVATIVES==1\n\t\tmate = texture( iChannel0, 0.25*pos.zx, .1*l ).xyz;\n        float signal = dot(mate,vec3(0.33));\n\t\tnor = doBump( pos, nor, signal, 0.15*bump );\n        #else\n\t\t\/\/ computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)\/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)\/dot(ddy_rd,nor);\n\t\tvec3 dposdx = ddx_pos - pos;\n\t\tvec3 dposdy = ddy_pos - pos;\n\n        mate = texture( iChannel0, 0.25*pos.zx, .1*l ).xyz;\n        float signal = dot(mate,vec3(0.33));\n        float dsignaldx = dot(texture( iChannel0, 0.25*ddx_pos.zx, .1*l ).xyz,vec3(0.33)) - signal;\n        float dsignaldy = dot(texture( iChannel0, 0.25*ddy_pos.zx, .1*l ).xyz,vec3(0.33)) - signal;\n\t\t\n        nor = doBump( dposdx, dposdy, nor, dsignaldx, dsignaldy, 0.15*bump );\n        #endif\n\n        occ = 1.0 - dot(nor,di\/l)*1.0*1.0\/(l*l); \n\t}\n\n\t\/\/ raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n            pos = ro + tmin*rd;\n\t\t\tnor = normalize(ro+h*rd-sc); \n\n            #if GPU_DERIVATIVES==1\n            mate = texcube( iChannel0, 0.25*pos, nor ).xyz;\n            float signal = dot(mate,vec3(0.33));\n\t\t    nor = doBump( pos, nor, signal, 0.03*bump );\n            #else\n            \/\/ computer ray differentials\n            vec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)\/dot(ddx_rd,nor);\n            vec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)\/dot(ddy_rd,nor);\n            vec3 dposdx = ddx_pos - pos;\n            vec3 dposdy = ddy_pos - pos;\n\n            mate = texcube( iChannel0, 0.25*pos, nor ).xyz;\n            float signal = dot(mate,vec3(0.33));\n            float dsignaldx = dot(texcube( iChannel0, 0.25*ddx_pos, nor ).xyz,vec3(0.33)) - signal;\n            float dsignaldy = dot(texcube( iChannel0, 0.25*ddy_pos, nor ).xyz,vec3(0.33)) - signal;\n            \n            nor = doBump( dposdx, dposdy, nor, dsignaldx, dsignaldy, 0.03*bump );\n            #endif\n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    \/\/ shading\/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\t\n\t\tfloat sh = softShadowSphere( pos, vec3(0.57703), vec4(sc,1.0) );\n        vec3 lin = vec3(0.8,0.7,0.6)*sh * clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\t\t     lin += occ*vec3(0.2,0.3,0.4);\n\t\t     lin += sh*0.5*pow(clamp(dot(reflect(rd,nor),vec3(0.57703)),0.0,1.0),12.0);\n\t\tcol = mate * lin;\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XldSDs","date":"1482449991","viewed":7356,"name":"Mobius Object","username":"Shane","description":"An abandoned Mobius object sitting on an abstract geometric terrain.","likes":149,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n    Mobius Object\n    -------------\n\n\tI love looking at the Mobius-related renderings that artistically and scientifically inclined people\n\tput up on places like DeviantArt, etc. There are so many interesting variations and rendering styles \n\tout there. There's also a few interesting examples on this site. Anyway, here's yet another one.\n\n\tAesthetically speaking, I started with a clean look that emphasized the Mobius object, then lost focus \n    and got carried away with the surroundings, which for some reason, led to things resembling a grungey, \n\tbrooding early-2000s demo scene. :) I saved the cleaner version, so I might put that up later.\n\n\tTopology was a long time ago for me, so I'm not sure what the object is technically called, but it's \n\teasy to see that it's based on the Mobius strip. In descriptive terms, I guess it's a toroidal shape... \n\ttwisted in the poloidal direction about the toroidal axis? Either way, these things are not much more \n    difficult to code than a torus.\n\n\tAs for the Mobius object construction, it's pretty straight forward for anyone comfortable with the \n\tconcepts behind a toroidal distance field. As always, it was helpful to have examples on this site to \n\trefer to. One of Dr2's versions helped me correct an annoying quantization error I was making. I'm \n\thuman, and therefore prone to errors. Thankfully, Dr2 is not. :D\n\n\tOther examples:\n    \n\t\/\/ Interlinked Mobius strips. Really cool geometry.\n\tLinked Rings - Dr2    \n\thttps:\/\/www.shadertoy.com\/view\/XsGXR1\n\n\t\/\/ An Escher recreation: A lot of work went into it.\n\tMoebius Strip 2 - Dr2\n\thttps:\/\/www.shadertoy.com\/view\/MscXWX\n\n    \/\/ I love this one. More variation.\n\tTwisted Jewelry - vgs\n\thttps:\/\/www.shadertoy.com\/view\/MdjXzG\n\tBased on:\n\tM\u00f6bius Balls - xTr1m\n\thttps:\/\/www.shadertoy.com\/view\/ldl3zr\n\n*\/\n\n\n#define FAR 40.\n\n\/\/ Scene object ID to separate the Mobius object from the terrain and a Mobius object ID to separate \n\/\/ the rails from the slats. It was easier to do it this way, but I'll amalgamate them later.\nfloat objID;\nfloat mObjID;\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n\/\/ IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)\/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n\n\/\/ Smooth maximum, based on the function above.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n\/\/ vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    \/\/ Faster, but doesn't disperse things quite as nicely. However, when framerate\n    \/\/ is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    \/\/ amalgamation I put together, based on a couple of other random algorithms I've \n    \/\/ seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n);\n    \n}\n\n\/\/ 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n\/\/ up those if-statements. Since there's less writing, it should go faster. That's how \n\/\/ it works, right? :)\n\/\/\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n    \/\/ I'm not sure what the largest conceivable closest squared-distance would be, but I think \n    \/\/ values as high as 2.5 (center to non-diagonal outer square corner) are possible. Statistically, \n    \/\/ it's unlikely, so when scaling back the final value to the zero-to-one range, I divide by \n    \/\/ something less than my maximum and cap it to one... It's all a matter of what look you're \n    \/\/ trying to achieve.\n\tvec3 d = vec3(2.5);\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);\n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\n    \/\/ Final value, with rough scaling.\n    return min((d.y - d.x)*.6, 1.); \/\/ Scale: [0, 1].\n    \n}\n\n\n\/\/ The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n\/\/ See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} \/\/ Triangle function.\n\/\/vec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} \/\/ Smooth version. Not used here.\n\n\n\/\/ This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n\/\/ looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n\/\/ the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n\/\/ I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n\/\/ GPU-draining distance function. The really fine details have been bump mapped.\nfloat terrain(in vec3 p){\n    \n    \n    \/\/ This is just one variation on a common technique: Take a cheap function, then\n    \/\/ layer it by applying mutations, rotations, frequency and amplitude changes,\n    \/\/ etc. Feeding the function into itself, folding it, and so forth can also \n    \/\/ produce interesting surfaces, patterns, etc.\n    \/\/\n    \/\/ Good examples of the technique include IQ's spiral noise and Nimitz's triangle\n    \/\/ noise, each of which can be found on Shadertoy. \n    \/\/\n    float n = dot(tri(p*0.3 + tri(p.yzx*0.15)), vec3(0.44));\n    p = p*1.57;\/\/1.5773;\/\/ - n; \/\/ The \"n\" mixes things up more.\n    p.yz = mat2(.866025, .5, -.5, .866025)*p.yz;\n    p.xz = mat2(.866025, .5, -.5, .866025)*p.xz;\n    n += dot(tri(p*0.45 + tri(p.yzx*0.225)), vec3(0.222));\n    \n    return smoothstep(0.3, .95, n); \/\/ Smoothstep for peaks and troughs. Range [0, 1]\n\n\n}\n\n\/\/ The Mobius object: Take an object, sweep it around in a path (circle) at radius R, and twist (roll) \n\/\/ with the axial plane as you do it. Essentially, that's all you're doing.\n\/\/\n\/\/ By the way, I've explained the process in a hurry with a \"near enough is good enough\" attitude, \n\/\/ so if any topology experts out there spot any conceptual errors, mislabling, etc, feel free to \n\/\/ let me know.\nfloat Mobius(vec3 q){\n \n    \/\/\/\/ CONSTANTS \/\/\/\/\n    const float toroidRadius = 1.25; \/\/ The object's disc radius.\n    \/\/const float ringWidth = .15; \n    const float polRot = 4.\/4.; \/\/ Poloidal rotations.\n    const float ringNum = 32.; \/\/ Number of quantized objects embedded between the rings.\n    \n    \n    \/\/\/\/ RAIL SECTION \/\/\/\/\n    vec3 p = q;\n    \n    \/\/ Angle of the point on the XZ plane.\n    float a = atan(p.z, p.x);\n    \n    \/\/ Angle of the point at the center of 32 (ringNum) partitioned cells.\n    \/\/\n    \/\/ Partitioning the circular path into 32 (ringNum) cells - or sections, then obtaining the angle of \n    \/\/ the center position of that cell. The reason you want that angle is so that you can render \n    \/\/ something at the corresponding position. In this case, it will be a squared-off ring looking object.  \t\n    float ia = floor(ringNum*a\/6.2831853);  \n    \/\/ The \".5\" value for the angle of the cell center. It was something obvious that I'd overlooked.\n    \/\/ Thankfully, Dr2 did not. :)\n  \tia = (ia + .5)\/ringNum*6.2831853; \n    \n    \/\/ Sweeping a point around a central point at a distance (toroidRadius), more or less. Basically, it's\n    \/\/ the toroidal axis bit. If that's confusing, looking up a toroidal\\poloidal image will clear it up.\n    p.xz *= r2(a);\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  \/\/ Twisting about the poloidal direction (controlled by \"polRot) as we sweep.\n    \n\n    \/\/ The rail object. Taking the one rail, then ofsetting it along X and Y, resulting in four rails.\n    \/\/ This is a neat spacial partitioning trick, and worth knowing if you've never encountered it before.\n    \/\/ Basically, you're taking the rail, and splitting it into two along X and Y... also along Z, but since \n    \/\/ the object is contiunous along that axis, the result is four rails.\n    p = abs(abs(p) - .25); \/\/ Change this to \"p = abs(p),\" and you'll see what it does.\n\n    float rail = max(max(p.x, p.y) - .07, (max(p.y-p.x, p.y + p.x)*.7071 - .075)); \/\/ Makeshift octagon.\n    \n    \n    \/\/\/\/ REPEAT RING SECTION \/\/\/\/\n    \/\/ The repeat square rings. It's similar to the way in which the rails are constructed, but since the object\n    \/\/ isn't continous, we need to use the quantized angular positions (using \"ia\").\n    p = q;\n    \/\/ Another toroidal sweep using the quantized (partitioned, etc) angular position.\n    p.xz *= r2(ia); \/\/ Using the quantized angle to obtain the position of the center of the corresponding cell.\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  \/\/ Twisting about the poloidal direction - as we did with the rails.\n    \n    \/\/ Constructing some square rings.\n    p = abs(p);\n    float ring = max(p.x, p.y); \/\/ Square shape.\n    \/\/ Square rings: A flat cube, with a thinner square pole taken out.\n    ring = max(max(ring - .275, p.z - .03), -(ring - .2));\n    \n    \n    \/\/\/\/ WHOLE OBJECT \/\/\/\/\n    \/\/ Object ID for shading purposes.\n    mObjID = step(ring, rail); \/\/smoothstep(0., .07, rail - sqr);\n    \n    \/\/ Smoothly combine (just slightly) the square rings with the rails.\n    return smin(ring, rail, .07); \n\n}\n\n\n\/\/ Combining the Mobius object with the terrain.\nfloat map(vec3 p){\n    \n    \/\/ Mobius object, sitting a bit above the terrain.\n    float obj = Mobius(p - vec3(0, .4, 0));\n    \n    float ter = terrain(p); \/\/ The terrain.\n \n    float fl = p.y  - ter; \/\/ Adding it to a flat plane.\n    \n    \/\/ Creating a flat area to sit the Mobius object on.\n    fl =  smax(fl, -max(length(p - vec3(0, 2.5, 0)) - 3., - p.y - .0), .5);\n \n    \/\/ Object ID.\n    objID = step(obj, fl);\n    \n    \/\/ Putting the Mobius object on the terrain.\n    return min(fl, obj);\n \n}\n\n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.0;\n    \n    for (int i=0; i<96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.85;  \/\/ Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\/\/ The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n\/\/ with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef, float t){ \n\t\n    vec2 e = vec2(ef\/iResolution.y, 0); \/\/ Larger epsilon for greater sample spread, thus thicker edges.\n\n    \/\/ Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t\/\/ The hit point itself - Doubled to cut down on calculations. See below.\n     \n    \/\/ Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    \/\/ much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    \/\/ is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    \/\/ curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); \/\/ Etc.\n    \n    \/\/ Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    \/\/ do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n    \n    \n    \/\/crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\t\n    \/\/ Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.002, 0);\/\/*min(1. + t, 5.)\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    \/\/ Return the normal.\n    \/\/ Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/dist += min( h, stepDist ); \/\/ So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.5);\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5\/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n \n\n\/\/ The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    \/\/ A reproduction of the lattice at higher frequency. Obviously, you could put\n    \/\/ anything here. Noise, Voronoi, other geometrical formulas, etc.\n    return Voronoi(p.xz*6.);\n   \n   \n}\n\n\/\/ Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    \/\/ Resolution independent sample distance... Basically, I want the lines to be about\n    \/\/ the same pixel width, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(1.5\/iResolution.y, 0); \n    \n    float f = bumpFunction(p); \/\/ Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); \/\/ Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); \/\/ Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); \/\/ Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); \/\/ Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); \/\/ Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  \/\/ Sample in the opposite Z-direction.\n    \n     \n    \/\/ The gradient vector. Making use of the extra samples to obtain a more locally\n    \/\/ accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)\/(e.x*2.);  \n    \/\/vec3 grad = (vec3(fx, fy, fz ) - f)\/e.x;  \/\/ Without the extra samples.\n\n\n    \/\/ Using the above samples to obtain an edge value. In essence, you're taking some\n    \/\/ surrounding samples and determining how much they differ from the hit point\n    \/\/ sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge\/e.x);\n    \n    \n    \/\/ We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    \/\/crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    \/\/ Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    \/\/ do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); \/\/ Bump the normal with the gradient vector.\n\t\n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ I think it's based on a discrete finite difference approximation to the continuous\n\/\/ Laplace differential operator? Either way, it gives you the curvature of a surface, \n\/\/ which is pretty handy. I used it to do a bit of fake shadowing.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    \/\/ A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c*c*c*c, c*c, c); \/\/ Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); \/\/ Mixing in a bit of purple.\n\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lk = vec3(0, .25, 0);  \/\/ \"Look At\" position.\n\tvec3 ro = lk + vec3(cos(iTime\/4.)*2.8, cos(iTime\/2.)*sin(iTime\/4.)*.25 + .75, sin(iTime\/4.)*3.3); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.85, 1.75, -1);\/\/ Put it a bit in front of the camera.\n\t\n\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 1.25; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    \/\/ \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    \/\/ assuming no normalization is necessary? The only reason I ask is that lots of people do \n    \/\/ normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(fwd + (rgt*uv.x + up*uv.y)*FOV);\n\n    \n    \/*   \n    \/\/ Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)\/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n    *\/\n\t \n    \n    \/\/ Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    float svObjID = objID;\n    float svMObjID = mObjID;\n\t\n    \/\/ Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        \/\/ Edge and edge-factor. The latter was necessary, to even up the line width between\n        \/\/ the Mobius object and the terrain... but I ultimately didn't use it. :)\n        float edge, crv = 1., ef = 4.; \/\/ Curvature variable not used, and commented out in the function.\n        \n        \/\/ Texture scale factor.\n        float tSize0 = 1.;\n        \n        \/\/ Texture-based bump mapping factor.\n        float bf = .005;\n        \n        if(svObjID<0.5) { \/\/ Different setting for the terrain.\n            bf = .02;\n            tSize0 = 1.\/1.;\n            ef = 1.5;\n        }\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp, edge, crv, ef, t);\n        \n        \/\/ Texture-based bump mapping. Comment it out, if you prefer a cleaner look.\n        \/\/ I haven't decided yet. :)\n        sn = texBump(iChannel0, sp*tSize0, sn, bf);\n        \n        \/\/ Function-based bump mapping. Note the second edge variable used for bump mapped\n        \/\/ edging - as opposed to distance field edging. There's also a second curvature\n        \/\/ variable that isn't used.\n        float edge2 = 0., crv2 = 1.;    \n        if(svObjID<.5) sn = doBumpMap(sp, sn, .1\/(1. + t\/FAR), edge2, crv2);    \n        \n\n\t    \n        \n        \/\/ Obtaining the texel color. \n\t    vec3 texCol;        \n        \n        if(svObjID<0.5) { \/\/ Terrain texturing.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn);\/\/*vec3(1, .6, .4);\n            texCol = smoothstep(0.05, .5, texCol)*vec3(1, .75, .5);\/\/*vec3(1, .7, .6);\/\/\n            texCol *= terrain(sp)*.5 + .5;\n            \/\/texCol *= crv*.75 + .25;\n        }\n        else { \/\/ Mobius texturing.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn);\n            texCol = smoothstep(0.05, .5, texCol);\n            \n            \/\/ Coloring the Mobius rings. Mixing to avoid nesting an \"if\" call.\n            texCol = mix(texCol, texCol*vec3(1, .4, .2)*2., svMObjID);\n        }\n\n\n    \t\n    \t\/\/ Light direction vectors.\n\t    vec3 ld = lp-sp;\n\n        \/\/ Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vectors.\n\t    ld \/= lDist;\n\n        \n        \n        \/\/ Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \tfloat ao = cAO(sp, sn); \/\/ Ambient occlusion.\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 1.\/(1. + lDist*lDist*0.05);\n\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; \/\/ Ramping up the diffuse.\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n\n        \n        \n        \/\/ I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        \/\/ to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.; \/\/envMap(refract(rd, sn, 1.\/1.3))*3.;\n        if(svObjID<.5) { \/\/ Lowering the terrain settings a bit.\n            env *= .25;\n            \/\/diff *= .5;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        \/\/ Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.15 + vec3(.7, .9, 1)*fre) + env + vec3(.7, .9, 1)*spec*2.);\n\n        \n        \/\/ Distance function edging for the Mobius object, and bump mapped edging only\n        \/\/ for the terrain.\n        if(svObjID>.5) sceneCol *= (1. - edge*.8);\n        else sceneCol *= (1. - edge2*.7); \/\/*crv2;\/\/(1. - edge*.8)*\n        \n\n        \/\/ Shading.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    \/\/ Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    \/\/ the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));\n    sceneCol = mix(sceneCol, bg\/48., smoothstep(0., .95, t\/FAR));\n    \n    \/\/ Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsB3Wc","date":"1394102815","viewed":7355,"name":"Weird Thing","username":"iq","description":"Some broken experiment on something undefined","likes":98,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2014 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\/\/#define HIGH_QUALITY_NOISE\n\nvec3 hash( vec3 x )\n{\n\treturn textureLod( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)\/256.0, 0.0 ).xyz;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)\/256.0, 0.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+vec2(0.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+vec2(1.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+vec2(0.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+vec2(1.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec2 voronoi( in vec3 x, out vec3 cen )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    float res = 100.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = d;\n\t\t\tcen = p + r + f;\n        }\n    }\n\n    return vec2( sqrt( res ), id );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec3 q = 8.0*p;\n\tfloat n = 0.0;\n\tn  = 0.5000*noise( q ); q = q*2.02;\n    n += 0.2500*noise( q ); q = q*2.03;\n    n += 0.1250*noise( q );\n\t\n\tvec3 cen = vec3(0.0);\n\tvec2 vor = voronoi( 2.0*p, cen );\n\tfloat f = 1.0-1.5*vor.x; cen \/= 2.0;\n\tf -= smoothstep( 0.4, 0.5, n );\n\t\n    float d = 2.0*f;\n\t\n\td *= smoothstep( 0.0, 0.2, 1.0-length(p) );\n\td *= smoothstep( 0.0, 0.2, 1.0-length(cen) );\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec3 col = mix( vec3(1.0,0.85,0.7), vec3(0.2,0.0,0.0), d );\n\t\n\tcol -= 0.05*sin( 5.0*vor.y + vec3(1.0,2.0,3.0) );\n\t\n\treturn vec4( col, d );\n}\n\nconst vec3 sundir = vec3(0.0,0.5,-1.0);\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec2 tminmax, in vec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n    const int numSteps = 64;\n    \n\tfloat dt = 1.0\/float(numSteps);\n\t\n\tfloat t = tminmax.x + dt*textureLod(iChannel0, px\/iChannelResolution[0].xy, 0.0).x;\n\tfor(int i=0; i<numSteps; i++)\n\t{\n\t\tif( sum.a > 0.99 || t>tminmax.y ) break;\n\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\tfloat dif = clamp((col.w - map(pos+0.01*sundir).w)\/0.01, 0.0, 1.0 );\n        float occ = dot(pos,pos);\n        vec3 lin = vec3(0.2,0.2,0.2) + vec3(1.0, 0.9, 0.7)*dif;\n\t\tcol.xyz *= lin*2.5*occ*occ;\n\t\t\n\t\tcol.a *= 0.1;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a) * dt\/0.01;\t\n\n\t\tt += dt;\n\t}\n\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n\n\tvec3 ro = 2.0*vec3(cos(an), 0.17, sin(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = vec3(0.05,0.04,0.03);\n    vec2 seg = iSphere( ro, rd, vec4(0.0,0.0,0.0,1.0) );\n\tif( seg.x>0.0 )\n\t{\n        vec4 res = raymarch( ro, rd, seg, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n\t}\n\t\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\t\n\tcol = pow( col, vec3(0.45) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsfGzr","date":"1360964990","viewed":7350,"name":"Blobs","username":"PauloFalcao","description":"Color blobs using 1\/length for color value, changing makePoint function can give very cool results ;)","likes":115,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Blobs by @paulofalcao\n\n#define time iTime\n\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=x+sin(t*fx)*sx;\n   float yy=y+cos(t*fy)*sy;\n   return 1.0\/sqrt(xx*xx+yy*yy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   vec2 p=(fragCoord.xy\/iResolution.x)*2.0-vec2(1.0,iResolution.y\/iResolution.x);\n\n   p=p*2.0;\n   \n   float x=p.x;\n   float y=p.y;\n\n   float a=\n       makePoint(x,y,3.3,2.9,0.3,0.3,time);\n   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   \n   \n   float b=\n       makePoint(x,y,1.2,1.9,0.3,0.3,time);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);\n\n   float c=\n       makePoint(x,y,3.7,0.3,0.3,0.3,time);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);\n   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,time);\n   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,time);\n   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,time);\n   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,time);\n   \n   vec3 d=vec3(a,b,c)\/32.0;\n   \n   fragColor = vec4(d.x,d.y,d.z,(d.x+d.y+d.z)\/3.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4s2Sz3","date":"1414412032","viewed":7350,"name":"Train Ride","username":"dr2","description":"Take a long trip through the mountains and enjoy the view.","likes":65,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ \"Train Ride\" by dr2 - 2014\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ Borrows ideas and techniques published on Shadertoy.\n\/\/ Thanks everyone for a great learning resource!!\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) \/ r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p = mix (vec4 (c.bg, vec2 (-1., 2.\/3.)), vec4 (c.gb, vec2 (0., -1.\/3.)),\n     step (c.b, c.g));\n  vec4 q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  float d = q.x - min (q.w, q.y);\n  const float e = 1.e-10;\n  return vec3 (abs (q.z + (q.w - q.y) \/ (6. * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 BrickSurfCol (vec2 p) {\n  vec2 q = p * (1. \/ 20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y \/ 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (10. * p)) * (0.3 + 0.7 * q.x * q.y) *\n     (0.3 + 0.2 * sin (2. * Hashfv2 (i) + vec3 (1., 1.2, 1.4)));\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 150.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, vec2 b)\n{\n  return max (length (p.xz) - b.x, abs (p.y) - b.y);\n}\n\nmat3 trainMat[5], trMat;\nvec3 trainPos[5], trPos, qTrWin, sunDir, sunCol, moonDir, moonCol;\nvec2 trkOffset;\nfloat tCur, dirTrWin;\nint idObj;\nbool isNight;\nconst float dstFar = 250.;\n\nvec3 TrackPath (float t)\n{\n  float y = 0.01 + sin (0.021 * t) * sin (1. + 0.023 * t);\n  return vec3 (15. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     11. * sin (0.0032 * t) + 100. * trkOffset.x, 2. * y * y, t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = p * 0.06;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x \/ (1. + dot (vyz, vyz));\n    if (j == 4) {\n      ht += 50. * pow (Noisefv2 (0.003 * q), 4.) - 1.;\n      if (hiRes == 0) break;\n    }\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y += 0.07 * Noisefv2 (0.0001 * p) + 0.04 * Noisefv2 (2.1 * p) +\n     0.03 * Noisefv2 (2.3 * p.yx);\n  float g = smoothstep (4., 35., abs (p.x - pt.x));\n  return SmoothMin (ht, pt.y * (1. - g) + ht * g, 0.5);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.02, 0.1, 0.02), gCol8 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + gCol7);\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol8, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.06;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.1 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol1 = vec3 (0.05, 0.05, 0.15), sbCol2 = vec3 (0.2, 0.25, 0.5);\n  vec3 col;\n  if (isNight) col = 0.3 * clamp (sbCol1 - 0.12 * rd.y * rd.y, 0., 1.);\n  else col = sbCol2 + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const vec3 sCol1 = vec3 (0.06, 0.04, 0.02), sCol2 = vec3 (0.03, 0.03, 0.06),\n     mBrite = vec3 (-0.5, -0.4, 0.77);\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) \/ rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * (f - 0.4) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  if (isNight) {\n    vec3 bgCol = SkyBg (rd) + sCol1 * pow (clamp (dot (rd, moonDir), 0., 1.), 30.);\n    col = bgCol;\n    const float moonRad = 0.04;\n    vec3 vn;\n    bool mHit = false;\n    float bs = - dot (rd, moonDir);\n    float cs = dot (moonDir, moonDir) - moonRad * moonRad;\n    float ts = bs * bs - cs;\n    if (ts > 0.) {\n      ts = - bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - moonDir) \/ moonRad);\n        mHit = true;\n      }\n    }\n    if (mHit) {\n      col += 1.4 * moonCol * clamp (dot (mBrite, vn) *\n         (0.3 + Noisefv3 (5. * vn)), 0., 1.);\n    } else {\n      vec3 st = (rd + vec3 (1.));\n      for (int j = 0; j < 10; j ++) {\n        st = 11. * abs (st) \/ dot (st, st) - 3.;\n      }\n      col += min (1., 1.5e-6 * pow (min (16., length (st)), 4.5));\n    }\n    col = mix (col, sCol2, cloudFac) + bgCol;\n  } else {\n    float s = max (dot (rd, sunDir), 0.);\n    col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n       0.65 * min (pow (s, 256.), 0.3));\n    col = mix (col, vec3 (0.55), cloudFac);\n  }\n  return col;\n}\n\nfloat TrainDf (vec3 p, float dHit, float dir)\n{\n  const float eRad = 0.25;\n  vec3 q;\n  float d;\n  q = p;\n  if (dir == 0.) {\n    q.y -= 0.15;\n    d = length (max (abs (q) - vec3 (0.42, 0.25, 0.95), 0.)) - eRad;\n  } else {\n    q.yz += vec2 (2.6, 0.7 * dir);\n    d = length (vec4 (max (abs (q.x) - 0.45, 0.), max (2.5 - q.y, 0.),\n       max (- q.z * dir, 0.),\n       max (length (q.yz + vec2 (0., - 0.2 * dir)) - 3., 0.))) - eRad;\n  }\n  if (d < dHit) {\n    dHit = d;  idObj = 21;\n    if (dir == 0.) q.y -= 0.1;\n    else q.y -= 2.85;\n    qTrWin = abs (q);\n    dirTrWin = dir;\n  }\n  q = vec3 (p.y + 0.32, abs (p.x) - 0.46, p.z + 0.4);\n  vec2 ww = vec2 (0.12 - sign (q.y) * 0.02, 0.04);\n  d = min (PrCylDf (q, ww), PrCylDf (q - vec3 (0., 0., 1.), ww));\n  if (d < dHit) {\n    dHit = d;  idObj = 22;\n  }\n  if (dir != 0.) {\n    q = p;\n    if (dir > 0.) {\n      q.x = abs (q.x) - 0.2;\n      q.yz += vec2 (0.2, -1.6);\n      d = PrCylDf (q.xzy, vec2 (0.05, 0.1));\n      if (d < dHit) {\n        dHit = d;  idObj = 23;\n      }\n    } else {\n      q.yz += vec2 (0.15, 1.6);\n      d = PrCylDf (q.xzy, vec2 (0.07, 0.1));\n      if (d < dHit) {\n        dHit = d;  idObj = 24;\n      }\n    }\n  }\n  return dHit;\n}\n\nfloat RailDf (vec3 p, float dHit)\n{\n  vec2 w = vec2 (abs (p.x) - 0.5, p.y + 0.57);\n  float d = min (length (max (abs (w - vec2 (0., 0.14)) - vec2 (0.02), 0.)),\n     SmoothMin (length (max (abs (w - vec2 (0., 0.08)) - vec2 (0.01, 0.08), 0.)),\n     length (max (abs (w - vec2 (0., -0.02)) - vec2 (0.04), 0.)), 0.06));\n  if (d < dHit) {\n    dHit = d;  idObj = 10;\n  }\n  vec3 q = vec3 (p.x, p.y + 0.7, mod (p.z, 2.4) - 1.2);\n  d = PrOBoxDf (q, vec3 (0.75, 0.03, 0.15));\n  if (d < dHit) {\n    dHit = d;  idObj = 11;\n  }\n  return dHit;\n}\n\nfloat BridgeDf (vec3 p, float dHit, float hg)\n{\n  vec3 q = p;\n  float d = max (abs (q.x) - 0.85, q.y + 0.68);\n  q.y += 4.5;\n  q.z = mod (q.z + 1.3, 2.6) - 1.3;\n  d = max (max (d, - max (length (q.yz +\n     vec2 (4. * clamp (q.y \/ 4., -0.5, 0.5), 0.)) - 5.5, abs (q.z) - 0.9)), - hg);\n  if (d < dHit) {\n    dHit = d;  idObj = 12;\n  }\n  return dHit;\n}\n\nfloat PlatformDf (vec3 p, float dHit, float hg)\n{\n  vec3 q = vec3 (p.x, p.y, mod (p.z, 150.) - 75.);\n  vec3 qq = q + vec3 (-1.9, -0.4, 0.);\n  float d = min (min (PrBoxDf (vec3 (abs (q.x) - 1.7, q.y + 0.5, q.z),\n     vec3 (0.7, 0.05, 5.)), max (PrBoxDf (qq, vec3 (0.1, 0.7, 2.)),\n     - PrBoxDf (qq, vec3 (0.15, 0.5, 1.5)))),\n     max (PrCylDf (vec3 (abs (abs (q.x) - 1.7) - 0.4, q.y + 4.5, abs (q.z) - 4.4),\n     vec2 (0.13, 4.)), - hg));\n  if (d < dHit) {\n    dHit = d;  idObj = 13;\n  }\n  d = PrCylDf (q + vec3 (-1.9, -1.2, 0.), vec2 (0.1, 0.06));\n  if (d < dHit) {\n    dHit = d;  idObj = 14;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = TrainDf (trainMat[0] * (p - trainPos[0]), dHit, -1.);\n  dHit = TrainDf (trainMat[1] * (p - trainPos[1]), dHit, 0.);\n  dHit = TrainDf (trainMat[2] * (p - trainPos[2]), dHit, 0.);\n  dHit = TrainDf (trainMat[3] * (p - trainPos[3]), dHit, 0.);\n  dHit = TrainDf (trainMat[4] * (p - trainPos[4]), dHit, 1.);\n  float hg = p.y;\n  p.xy -= TrackPath (p.z).xy;\n  p.y -= 0.9;\n  dHit = RailDf (p, dHit);\n  dHit = BridgeDf (p, dHit, hg);\n  dHit = PlatformDf (p, dHit, hg);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nvec4 ObjCol (vec3 p, vec3 n)\n{\n  vec3 col = vec3 (0.);\n  float sp;\n  float dkFac = 1.;\n  if (idObj >= 10 && idObj <= 19) {\n    sp = 0.;\n    if (idObj == 10) {\n      col = vec3 (0.3);\n      sp = 1.;\n    } else if (idObj == 11) {\n      col = vec3 (0.12, 0.08, 0.04) * (1.5 + Noisefv2 (30. * p.xz));\n    } else if (idObj == 12) {\n      if (n.y > 0.9) col = vec3 (0.025) * (2. + Noisefv2 (15. * p.xz));\n      else col = 0.1 * BrickCol (0.5 * p, n);\n      dkFac = 0.4;\n    } else if (idObj == 13) {\n      p.xy -= TrackPath (p.z).xy;\n      col = vec3 (0.26, 0.22, 0.2) * BrickCol (0.3 * p, n);\n      dkFac = 0.2;\n    } else if (idObj == 14) {\n      if (isNight) col = vec3 (1., 0., 0.);\n      else col = vec3 (0.7, 1., 0.7);\n    }\n  } else if (idObj >= 21 && idObj <= 29) {\n    sp = 0.7;\n    if (idObj == 21) {\n      col = vec3 (0.7, 0.2, 0.2);\n      dkFac = 0.02;\n      sp = 0.7;\n    } else if (idObj == 22) {\n      col = vec3 (0.7, 0.3, 0.);\n      dkFac = 0.1;\n    } else if (idObj == 23) {\n      col = vec3 (1., 0., 0.);\n    } else if (idObj == 24) {\n      if (isNight) col = vec3 (1.);\n      else col = vec3 (1., 1., 0.);\n    }\n  }\n  if (isNight) col *= dkFac;\n  return vec4 (col, sp);\n}\n\nvoid TrainCarPM (float t)\n{\n  vec3 vp, vd, ve, vf;\n  trPos = TrackPath (tCur + t);\n  vp = TrackPath (tCur + t + 0.1) - trPos;\n  vd = - normalize (vec3 (vp.x, 0., vp.z));\n  ve = normalize (vec3 (0., vp.yz));\n  trPos.y += 0.9;\n  trMat = mat3 (vec3 (1., 0., 0.), vec3 (0., ve.z, - ve.y), ve) *\n      mat3 (vec3 (- vd.z, 0., vd.x), vec3 (0., 1., 0.), vd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec2 vDir)\n{\n  const float eps = 0.01;\n  vec4 col4;\n  vec3 col, vn;\n  float f;\n  vec3 roo = ro;\n  float dstHit = dstFar;\n  float dstGrnd = GrndRay (ro, rd);\n  idObj = 0;\n  float dstObj = ObjRay (ro, rd);\n  int idObjT = idObj;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y \/ rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.6;\n  }\n  bool isLit = true;\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    if (idObjT == 21 && (qTrWin.y < 0.2 &&\n       (qTrWin.x < 0.45 || qTrWin.x > 0.65) || dirTrWin == 0. &&\n       qTrWin.x < 0.3 && qTrWin.z < 0.7)) idObjT = 20;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObjT == 20) {\n      rd = reflect (rd, vn);\n      ro += eps * rd;\n      dstGrnd = GrndRay (ro, rd);\n      if (dstGrnd < dstFar) {\n        ro += dstGrnd * rd;\n        dstHit = dstGrnd;\n        refFac *= 0.4;\n        isGrnd = true;\n      } else {\n        col = refFac * SkyCol (ro, rd);\n        isLit = false;\n      }\n    } else {\n      col4 = ObjCol (ro, vn);\n      col = refFac * col4.xyz;\n      if (! isNight) {\n        col *=  sunCol * (0.3 + (max (0., dot (sunDir, vn)) +\n           col4.w * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 20.)));\n      } else {\n        if (idObjT == 21) col *= moonCol * (0.6 +\n           col4.w * pow (max (dot (rd, reflect (moonDir, vn)), 0.), 40.));\n      }\n      dstHit = dstObj;\n      isLit = ! (idObjT == 14 || (idObjT >= 20 && idObjT <= 29));\n    }\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n      isLit = false;\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    if (! isNight) {\n      f = dot (sunDir, vn);\n      col = sunCol * mix (col * (max (f, 0.) + 0.1), vec3 (refFac),\n         step (f, 0.) * col4.w * pow (max (dot (reflect (sunDir, vn), rd), 0.), 3.));\n    }\n  }\n  if (dstHit < dstFar) {\n    f = dstHit \/ dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  if (isNight && isLit) {\n    vec3 vLight = ro - trainPos[0];\n    vLight.z -= 2.2;\n    float dstLightI = 1. \/ length (vLight);\n    vLight *= dstLightI;\n    f = dot (vLight.xz, vDir);\n    if (dstLightI > 0.02 && f > 0.4) {\n      col *= (0.1 + pow (f, 8.)) * min (1., 100. * dstLightI * dstLightI);\n    } else {\n      col = RgbToHsv (col);\n      col.y = 0.1;\n      col.z *= col.z;\n      col.z *= 0.3 * col.z;\n      col = HsvToRgb (col);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x \/ iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 1.8;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (0.4, 0.5, 0.5));\n  moonDir = normalize (vec3 (0.3, 0.25, 0.5));\n  sunCol = vec3 (1., 0.9, 0.8);\n  moonCol = vec3 (1., 0.9, 0.5);\n  float dt = 0.3;\n  isNight = mod (floor (tCur \/ 1000.), 2.) != 0.;\n  float trStart = 12.;\n  float trGap = 2.2;\n  float tz;\n  tz = tCur + trStart - 2. * trGap;\n  vec2 vDir = normalize ((TrackPath (tz + dt).xz -\n     TrackPath (tz - dt).xz) \/ (2. * dt));\n  float dGap = sqrt (1. - vDir.x * vDir.x);\n  TrainCarPM (trStart);\n  trainPos[0] = trPos;  trainMat[0] = trMat;\n  TrainCarPM (trStart - trGap * dGap);\n  trainPos[1] = trPos;  trainMat[1] = trMat;\n  TrainCarPM (trStart - (2. * trGap + 0.25) * dGap);\n  trainPos[2] = trPos;  trainMat[2] = trMat;\n  TrainCarPM (trStart - (3. * trGap + 0.5) * dGap);\n  trainPos[3] = trPos;  trainMat[3] = trMat;\n  TrainCarPM (trStart - (4. * trGap + 0.5) * dGap);\n  trainPos[4] = trPos;  trainMat[4] = trMat;\n  bool fixCam = mod (floor (tCur \/ 500.), 2.) == 0.;\n  mat3 scMat;\n  vec3 ro, rd, vd;\n  if (fixCam) {\n    tz = ceil (tCur \/ 100.) * 100.;\n    ro = TrackPath (tz - 40.);\n    float dx = 2. * mod (tz \/ 100., 2.) - 1.;\n    ro.x += 13. * dx;\n    float gh = GrndHt (ro.xz, 0);\n    ro.xy += vec2 (-3. * dx, 3. + 0.1 * gh * gh);\n    vd = normalize (TrackPath (tCur + 8.) - ro);\n    vec3 u = - vd.y * vd;\n    float f = 1. \/ sqrt (1. - vd.y * vd.y);\n    scMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  } else {\n    tz = tCur + trStart - 6. * trGap * dGap;\n    ro = TrackPath (tz);\n    ro.y += 4.;\n    vd = TrackPath (tz + dt) - TrackPath (tz - dt);\n    vd.y = 0.;\n    vd = normalize (vd);\n    scMat = mat3 (vd.z, 0., - vd.x, 0., 1., 0., vd);\n  }\n  rd = scMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd, vDir);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XtlGW4","date":"1422130309","viewed":7350,"name":"[2TC 15] old skool 3d driving","username":"mattz","description":"Inspired by a recent perusal of http:\/\/www.extentofthejam.com\/pseudo\/ to see if I could fit this type of effect into the \"2 tweet\" challenge.","likes":93,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"void mainImage( out vec4 f, vec2 p ){\n    \n    vec3 q=iResolution,d=vec3(p-.5*q.xy,q.y)\/q.y,c=vec3(0,.5,.7);\n    \n    q=d\/(.1-d.y);\n    float a=iTime, k=sin(.2*a), w = q.x *= q.x-=.05*k*k*k*q.z*q.z;\n\n    f.xyz=d.y>.04?c:\n    \tsin(4.*q.z+40.*a)>0.?\n        w>2.?c.xyx:w>1.2?d.zzz:c.yyy:\n\t    w>2.?c.xzx:w>1.2?c.yxx*2.:(w>.004?c:d).zzz;\n    \n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WtGXWm","date":"1582809862","viewed":7348,"name":"Echeveria II","username":"tdhooper","description":"This time I'm distributing leaves on a hemisphere. Using brute-force AO as the usual approach looks bad with this model; it's slow so you can toggle it with the define\n\n[url=https:\/\/media.giphy.com\/media\/Y0mfLzgzBIfgmCqyqF\/source.gif]GIF version[\/url]","likes":184,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/#define AA 3\n#define AO\n\/\/#define GIF\n\n\/\/ voronoi - adapted from iq https:\/\/www.shadertoy.com\/view\/ldl3W8\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi( in vec2 x )\n{\n    vec2 cell = floor(x);\n\n    float d = 1e12;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n        vec2 pos = hash2( cell + offset );\n        vec2 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n\n    return d;\n}\n\n\/\/ HG_SDF \n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) \/ k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) \/ (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n\/\/ Modelling\n\nfloat time;\nbool lightingPass;\nmat3 modelMat;\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n};\n\nModel leaf(vec3 p, vec3 cellData) {\n    \/\/cellData = vec3(0,0,.1);\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    \/\/cell.x = 0.;\n    \/\/cell.y = .1;\n    \/\/cellTime = .2;\n\n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    \/\/ orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n    len = pow(len, .33);\n    float llen = len;\n\n\n    if (cellTime > 0.) {\n\n        \/\/ wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        \/\/ wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,.4));\n        float wedge2 = -dot(p, n);\n        wedge2 = max(wedge2, dot(p, n * vec3(1,1,-1)));\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len \/ 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - .05;\n        d2 = max(d2, top);\n        \n        float d3 = smax(d2, wedge, .05);\n        float d4 = smax(d2, wedge2, .05);\n        wedges = smin(wedge, wedge2, .01);\n        d3 = smin(d3, d4, .01);\n        d = d3;\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz \/ len;\n        return Model(d, p, uv, cell, wedges, slice, len);\n    }\n\n\treturn Model(d, p, vec2(0), vec2(0), 0., 0., 0.);\n}\n\nvec3 calcAlbedo(Model model) {    \n    vec3 col = vec3(.15,.15,.4);\n\n\tvec3 p = model.p;\n    float len = model.len;\n    vec2 cell = model.cell;\n    float wedges = model.wedges;\n    float slice = model.slice;\n    vec2 uv = model.uv;\n    \n    float v = voronoi((uv+4.)*30.);\n    float v2 = voronoi((uv+4.)*4.+cell.x);\n\n    col = mix(col, vec3(.125,.2,.4), 1.-v2);\n    float tip = length(p - vec3(0,.2,len*.9));\n\n    tip = smoothstep(.5, .0, tip);\n    tip *= smoothstep(.07, .0, abs(slice+.01));\n    tip *= smoothstep(-.2, .0, wedges);\n    tip = pow(tip, 1.5);\n    col = mix(col, vec3(1,.2,.5), tip);\n\n    float vs = 1.-uv.y*1.;\n    vs *= smoothstep(.0, -.1, wedges);\n    vs *= smoothstep(.0, .05, abs(slice));\n    v = smoothstep(vs + .1, vs - .5, v*1.5);\n    col = mix(col, vec3(.05,.05,.2), v*v2);\n\n    col *= mix(vec3(1), vec3(.5,5.,1.8), smoothstep(.2, 1.8, cell.y) * .75);\n  \n    return col;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t\n) {\n\n    float sz = maxBloomOffset + PI \/ 2.;\n\n    cell = transform * cell;\n\n    \/\/ Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    \/\/ Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch \/ sz \/ stretchStart;\n    cell.y = max(cell.y, .5\/stretchStart); \/\/ clamp, not sure why this magic number\n    cell.y \/= stretch \/ sz \/ stretchStart;\n    cell = transform * cell;\n\n    \/\/ Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    \/\/ calculate cell time\n    float y = cell.y * (stretch \/ sz);\n    float cellAppearTime = (stretchStart - y) \/ (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x \/ cc.y);\n    float scale = (PI*2.) \/ sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1.\/scale,0,0,1.\/scale);\n\tphyllotaxis = mRot * mScale;\n}\n\nModel bloom(vec3 p, float t) {\n\n    p.y -= .05;\n\n    vec2 move = vec2(0, t);\n    float stretchStart = .25;\n    float stretchEnd = 1.;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI \/ 2.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n\n\tModel res = Model(1e12, p, vec2(0), vec2(0), 0., 0., 0.);\n    \/\/res.d = length(p) - 1.; return res;\n\n    \/\/ compile speed optim from IQ\n    for( int m=min(iFrame,0); m<3; m++ )\n    for( int n=min(iFrame,0); n<3; n++ )\n    {\n    \tres = opU(res, leaf(p, calcCellData(cell, vec2(m, n) - 1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t)));\n    }\n\n    return res;\n}\n\nModel map(vec3 p) {\n    p *= modelMat;\n    float t;\n    \n    float bound = length(p) - 1.3;\n    if (bound > .01 && ! lightingPass) {\n\t\treturn Model(bound, p, vec2(0), vec2(0), 0., 0., 0.);\n    }\n\n    pR(p.xy, time * -PI);\n\n    vec3 pp = p;\n    \n    float side = sign(p.y);\n    p.y = abs(p.y);\n\tp.z *= side;\n\n    t = time + .5 * side;\n    t = sin(t * PI - PI\/2.) * .5 + .5;\n    pR(p.xz, time * PI);\n    Model model = bloom(p, t);\n    \n    if (abs(p.y) < .34) {\n        p = pp;\n    \tside *= -1.;\n        p.yz *= side;\n        t = time + .5 * side;\n    \tt = sin(t * PI - PI\/2.) * .5 + .5;\n        pR(p.xz, time * PI);\n        Model model2 = bloom(p, t);\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n\/\/ compile speed optim from IQ https:\/\/www.shadertoy.com\/view\/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/3dyXzD\nvec3 randDir( vec3 n, vec2 seed ) {\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n    vec3  vv = cross( uu, n );\n    \n    float ra = sqrt(seed.y);\n    float rx = ra*cos(6.2831*seed.x); \n    float ry = ra*sin(6.2831*seed.x);\n    float rz = sqrt( 1.0-seed.y );\n    vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nfloat hitLength(vec3 pos, vec3 dir, float maxDist) {\n    float len = 0.;\n    const int steps = 15;\n    float dist = maxDist \/ float(steps);\n    vec3 rayPos;\n    for (int i = 0; i < steps; i++) {\n        len += dist;\n        dist = map(pos + dir * len).d;\n        if (abs(dist) < .001) {\n            break;\n        }\n        if (len > maxDist) {\n            len = maxDist;\n            break;\n        }\n    }\n    return len \/ maxDist;\n}\n\nfloat calcAO(vec3 pos, vec3 nor, vec2 seed, float maxDist) {\n    float len = 0.;\n    const float SAMPLES = 3.;\n    for (float x = 0.; x < SAMPLES; x++)\n    for (float y = 0.; y < SAMPLES; y++)\n    {\n        vec2 s = seed + vec2(x, y) \/ SAMPLES;\n        s = hash2(s);\n        vec3 dir = randDir(nor, s);\n        len += hitLength(pos, dir, maxDist);\n    }\n\n    len \/= SAMPLES * SAMPLES;\n    return len;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nmat3 rotX(float a) {\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a) {\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a) {\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nfloat pat(vec2 uv) {\n    vec2 p = vec2(atan(uv.x\/uv.y), log(length(uv)));\n   \n   \tp *= phyllotaxis;\n    p = p * 4.;\n    \n    p -= vec2(0,8) * time;\n\n    p = mod(p, 1.);\n    float d = length(p - .5) - .1;\n    float fw = fwidth(d);\n\n    d = abs(d) - .01;\n    d \/= fw;\n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime \/ 4., 1.) + .35;\n    time = mTime;\n    \n    calcPhyllotaxis();\n    modelMat = rotZ(-.9) * rotX(.05) * rotY(-1.1);\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \/\/ pixel coordinates\n    o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n    \/\/ time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n    #endif\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\n        vec3 camPos = vec3(0,0,-2.6);\n        #ifdef GIF\n        \tcamPos.z = -2.8;\n       \t#endif\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-.05,0), 0.);\n        vec3 rayDirection = normalize( camMat * vec3(p.xy,1.8) );\n\n        vec3 rayPosition = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        Model model;\n\n        lightingPass = false;\n        \n        for (int i = 0; i < 300; i++) {\n            rayLength += dist;\n            rayPosition = camPos + rayDirection * rayLength;\n            model = map(rayPosition);\n            dist = model.d;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 5.) {\n                bg = true;\n                break;\n            }\n        }\n        \n        lightingPass = true;\n        \n        col = vec3(.4,.4,1);\n        #ifndef GIF\n        \tcol = mix(col, vec3(.0,1.5,1.5)*1.5, (1.-pat(p))*.5);\n        \tcol = mix(col, vec3(.63,.7,1), smoothstep(2.5, .5, length(p)));\n        #else\n        \tcol = mix(col, vec3(.63,.7,1), .95);\n        #endif\n        col *= vec3(.9,1.,1.);\n        col += .1;\n        \n        \/\/bg = true;\n        \n        if ( ! bg) {\n\n            vec3 pos = rayPosition;\n            vec3 rd = rayDirection;\n            vec2 seed = hash2(p + time);\n            \n            #ifndef AA\n            \tseed *= .0000001;\n            #endif\n            \n            vec3  nor = calcNormal(pos);\n            \n            float occ = 1.;\n            #ifdef AO\n            \tocc = calcAO(pos, nor, seed, .85);\n            \tocc = clamp(pow(occ*1.25, 1.5), 0., 1.);\n            #endif\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            vec3 lin = vec3(0);\n            lin += 1.70 * amb * vec3(1.30,1.00,0.70) * occ;\n            lin += 0.90 * amb * vec3(0.30,0.80,1.30);\n            lin += 1.00 * fre * vec3(1.00,1.00,1.00) * occ;\n\n\n            vec3 albedo = calcAlbedo(model);\n            col = albedo * lin;\n            \n            \/\/col *= mix(vec3(1), vec3(.0,.5,.7)*.5, 1.-occ);\n\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot \/= float(AA*AA);\n    #endif\n\n    col = tot;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=948&num=12">80</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=960&num=12">81</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=972&num=12">82</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=984&num=12">83</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=996&num=12">84</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=948&num=12">80</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=960&num=12">81</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=972&num=12">82</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=984&num=12">83</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=996&num=12">84</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
